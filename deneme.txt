In this course, I'm going to teach you everything you need to know to get started programming in Python. Now, Python is one of the most popular programming languages out there. And it's by far one of the most sought after for jobs. And so if you're trying to get a job or you're trying to, you know, automate your life, or you're trying to write awesome scripts to do a bunch of different things, then Python's for you. Honestly, more and more developers every day are moving their projects over to Python because it's such a powerful and it's such an easy to use language. A lot of programming languages out there just aren't very beginner friendly. There's a lot of syntax. There's a lot of like little things that if you get wrong, the program will yell at you. Python is the complete opposite of that. You basically just type out what you want to do and Python does it. It's that simple. There's not a whole lot of syntax to learn. The learning curve is literally zero. You jump in, you can start writing your first program in seconds. In this course, I'm going to teach you guys everything you need to know to get started in Python. I designed this course, especially for Python. And each lesson has been specially designed with examples that will help you along the way with so many people starting to learn Python. The question isn't, why should you learn Python? The question is, why shouldn't you? And I think for a lot of people, the reason they might not want to learn Python is because they're intimidated or they're afraid that it's going to be too hard. Trust me, I am going to hold your hand through this entire course. We're going to talk about all the core concepts in Python. We're going to look at everything you need to know to start programming in Python and start being confident and start writing scripts and start writing programs that are awesome and doing cool things in your life. Anyway, I'm super pumped to be teaching you guys Python. I can't wait to get started in this course. And I hope you guys stick around and follow along with the course and learn this amazing programming language. In this tutorial, I'm going to show you guys how to install Python onto your computer. And we're also going to install a text editor that we can use to write our Python programs in. So the first order of business is to actually install Python on your computer. So what we want to do is head over to our web browser. And you want to go over here to this page, it's just www.python.org forward slash downloads. And on this page, there's going to be two buttons down here. And it's just going to say download Python 3.6.3. And at least that's the version that I have right now or download Python 2.7.1.4. So here's the thing about Python, there's actually two major versions of Python that are in use currently. There's Python two, and there's Python three. So you can see over here, this is like 2.7.1.4. Basically, any Python two version we would just refer to as like Python two. And here's like the latest Python three version. And so there's these two versions that you can download. And the first thing we have to decide is which version do we want to download. And here's the basic difference, Python two is a legacy version of Python, which basically means that it's like an old version, and it's not being like actively maintained or supported like officially by Python anymore. Python three is like the future of Python. It's like the newest version. It's the one that's getting actively maintained and supported. And so there's pros and cons to picking either one. A lot of people will say like Python two has been around longer. And so there's more like libraries, there's basically just more Python code written in Python two. So therefore, like there's a few more things that you can do in Python two, then you can do in Python three. But then again, Python two is not supported. And you know, five or 10 years from now, probably no one's going to be using it. Python three, like I said, is like the future of Python. It's the newest version. It's the one that, you know, is sort of being maintained going forward. So for the purposes of this tutorial, I'm going to be teaching you guys Python three. So we're going to want to download Python three. Now here's the thing, like, if you learn Python three, or you learn Python two, the differences aren't very big. There are a few differences in like some syntax and just some, you know, little things here and there. But if you learn Python three, you'll be able to jump right in and code in Python two as well. Don't let anyone, you know, tell you that you have to learn one or the other, we're going to learn Python three just because it's I think probably the best for a beginner to learn. And so that's the one that we want to download. So I'm just going to click download Python three. And we're going to go ahead and download this version. And when that's done downloading, I'm just going to head down to my downloads folder. And you'll see here, we just have this file, I'm just going to double click. And we get this like Python installer. So I'm just going to click through here. And we'll be able to install Python three on our computer. All right, when that's done installing, we can just close out of this and we should be good to go. So now we have Python three installed on our computer. The next step is we need to choose a text editor. So we're going to be writing a bunch of code. So we're going to need some, you know, environment or some program that we can write all that code in. And really, you can write Python in any text editor, you could write it in like notepad or text edit, it doesn't really matter. But there are special text editors that are designed just for writing Python code. And these are called IDEs. And that stands for integrated development environment. It's basically just a special environment where we can, you know, run and execute our Python code. And it'll, you know, basically, like tell us how we're doing. So if we're, you know, if we write something that's wrong, or we have errors, it'll kind of point us in the right direction of what we need to do to fix that stuff. So in this course, we're going to be using an IDE. And one of my favorites, and one of the most popular IDEs for Python is called pie charm. So I'm over here on this website, it's called jetbrains.com forward slash pie charm. And this is the IDE that we're going to be using in this course. So I'm just going to come over here and click this big download now button. And we'll go ahead and download this pie charm program. Alright, so I'm getting this page over here. You can see there's two versions of pie charm. One is a professional version, and that one's like paid, so you have to pay for it. But then there's this community version down here, and that's free and open source. So I'm just going to download this one. And this should have everything we need to get started using Python. Alright, when that finishes downloading, I'm just going to pull that up in my downloads folder. And again, we can just sort of run this guy. And I'm on a Mac. So I'm going to have to drag it over to my applications folder. Alright, so we now have pie charm. And we have Python three installed on our computer. So we're ready to start programming in Python. And this tutorial, we're going to create our first Python program. And we're going to be able to run it and see how everything works. The first thing I want to do is open up pie charm. So pie charm was the IDE, the integrated development environment that we downloaded in the last tutorial. So I'm just going to go ahead and search for it on my computer. And I can just open it up. And when we first open up pie charm, we should basically just get a window prompting us to create a project. So you can see that down here. Actually, the first thing I want to do though is come over here to configure. And I'm just going to click on preferences. And I actually want to change the appearance. So I'm going to go ahead and give this a theme. So I just went over here to appearance and behavior, appearance. And I'm going to change the theme to dark. Just because I think it's a little bit easier to use and look at. But you don't have to do that if you don't want to. And so down here, I'm just going to click create new project. And it's going to give us this little window right here. So I can just name my project. And I'm just going to name this draft. And then there's this other option down here where it says interpreter. Now, what we want to select is Python version three. So if I click down here, you'll notice that there's a couple different options. So I'm on a Mac computer. And by default, Mac has Python version two installed on it. If you're on a Windows machine, I'm not sure if it does. But in this tutorial, we're going to be using Python three. So you want to make sure that you have Python three selected as the interpreter. Otherwise, you might not be able to fully follow along with what we're doing in this video. So now I'm just going to come down here and click create. And this is going to go ahead and create our project for us. All right, so now we have our Python project up and running. And I want to show you guys how we can create our first Python program. So over here in this draft folder, and this is just that project that we created, I'm just going to right click and I'm going to say new. And I'm going to come down and click Python file. So we want to create a new Python file, this will be our first Python program. And I can just give this a name. So why don't we just call this app? And I'm just going to click okay. All right, so now we have our first Python file open. And we can just start typing in some Python. So I want to show you guys just a very basic Python program. And this is just going to be a hello world program. So we're just going to print something out onto the screen. So what I want to do is I want to type out PRINT print. And I want to type in open and closed parentheses. Now inside of this parentheses, we can make some quotation marks. And inside of the quotation marks, I'm just going to type out hello world. So this is like a very basic Python program. And what this is going to do is it's just going to print out hello world onto the screen. And so now what I can do is I can actually run this file and we're actually getting a little error here. It wants us to create a new line at the end of the file. And so now in order to run our Python program, I'm just going to come up here to the top. And I'm just going to click run. And we'll click this run button right here. And now we'll see what happens. So it's asking me what I want to run. I can just click app. And down here at the bottom, you'll notice that we have this text that just got printed out hello world. And so whatever I print, or whatever I put inside of this print statement is going to get printed out down below in the console. So as long as you're getting that print statement to work, then you've actually written your first Python program. And as we go through forward in the course, we're going to be writing all sorts of awesome Python programs. And we're going to be doing all sorts of cool stuff. In this tutorial, I want to talk to you about writing a basic Python program. So we're going to write just a very simple Python program. We're going to look at how we can go ahead and write our programs, we're going to talk about how our programs are getting executed by Python. And we're also going to draw out a little shape onto the screen. So this is going to be pretty cool. I'm excited to talk to you guys about just the bare basics of Python, and really just sort of give you an introduction. So over here, we have our basic text editor. And so any of the Python code that I write inside of this file is actually going to get executed by Python. So this Python file has a bunch of Python code inside of it. And basically what we're doing when we're programming in Python is we're just giving the computer a set of instructions. Right, that's really what programming is, it's just like we're specifying a set of instructions. And the computer is going to go off and execute those instructions that we give it. And so the more complex the instructions we give to the computer, the more complex the tasks the computer can carry out. So I want to show you guys how we can use some Python instructions or some Python code in order to draw out a shape onto the screen. So I'm actually going to draw out a little triangle. So over here, we can actually print something out onto the screen and Python using something called print statements. So I can just type out print. And inside of these parentheses, I can just type some quotation marks and inside the quotation marks, we can put whatever we want to print out onto the screen. So I'm going to copy this and I'm actually going to make a few of these little print statements. And we're going to actually draw a shape. So we're going to draw like a triangle type shape. So down here, I'm just going to draw a forward slash. And then up here, I'll make a space and we'll do another forward slash. Here, we'll make two spaces, we'll do another forward slash. And over here, we're going to make three spaces and a forward slash. And now I'm going to draw like vertical bars going all the way down. And actually, we can do some underscores here as well. That'd be kind of cool. All right, so now we have our triangle looking shape and you can see it looks kind of like a right triangle. So I can save my file. And I can either come up here to run and click run app. Or if you're using PyCharm, you can also just come over here and click this play button. And when I click the play button, I want you to notice what happens down here. So down here, we have this little window and this is called the console. And basically, the console is just a place where Python is going to output some information. So when we use this print statement, we're basically telling Python like, Hey, can you print something out onto the console? So there's a lot of situations where we're going to want to see what's going on in our code. And we can use that print statement and print things out to the console. And we can basically like have a little window into what our program is doing. In our case, we're just going to be printing out this triangle onto the console. So I'm going to come over here and click this play button. And you'll see down here, we're actually printing out that triangle. So mission accomplished, we were able to print out our shape. So I could really draw any shape I wanted as long as I was able to specify it inside of these print statements. So essentially, what Python's doing when I click that play button, is it's going into this file and it's looking at all of these instructions in order. So the first thing it does is it goes to this instruction, and it says, okay, they want me to draw out these like little forward slash in this vertical bar onto the screen. Once it does that, it goes down to this instruction, it says, okay, they want me to print something out again. When it prints that out, it goes down to this instruction, etc. So Python is actually going to execute the lines of code that we write in order. So the order in which I write the instructions matters a lot. So for example, if I was to take this last line here, and put it up here at the top. Now when I save the file, instead of just drawing out that triangle, it's going to draw out this little upside down bottom thing at the top, and then the rest of the triangle down here. So the order of the instructions actually matters a lot. So this is basically how your Python programs are going to go. As we go through this course, we're going to learn more and more of these little lines. So here, we're just using this little print function, basically, it just prints something out onto the screen. There's a bunch of little things like this that we can learn as we go through, we'll learn more and more instructions that we can give to the computer. But in this lesson, I just want to kind of show you guys the basics, right? We can essentially just define these little instructions for the computer, and the computer will execute them in order. In this tutorial, I want to talk to you guys about using variables in Python. Now in Python, you're going to be dealing with a lot of data. So a lot of times in our program, we're going to be working with all types of information and data and values. And sometimes that data can be difficult to manage. So in Python, we have this thing called a variable. And it's basically just a container, where we can store certain data values. And when we use a variable, when we put those data values inside containers, it makes it a lot easier for us to work with and manage all of the different data inside of our programs. So variables are extremely helpful. And it's sort of like a core topic in Python that you're really going to want to know in master. So in this tutorial, I'm going to teach you guys everything you need to know to get started with variables, we're going to look at what they are, why they're useful, and we'll look at the different types of variables and the different types of data that we can store inside of variables. But over here in my Python file, I just have a very simple program. And it's basically just printing some text out onto the screen. And so this is actually a little story that I wrote. It says there once was a man named George, he was 70 years old. He really liked the name George, but didn't like being 70. So this is a valid Python program. I could go ahead and run this program. And you'll see down here in the console, everything prints out and it looks great. So we have an awesome little Python program here. But let's say that inside of our story, I wanted to change the character's name. So instead of naming the character George, let's say I wanted to name the character John. Well, I'm going to have to go through and I'm going to have to manually change the name George to the name John at every place inside of this story where it's mentioned. So I'm going to have to go over here and I'll say, okay, John, I'm going to have to manually change that. And then, okay, down here, we're gonna have to again, manually type in John and change it to John. So in order to change the character's name, I had to manually go in and change it in both places. And now let's say, okay, maybe we want to change the character's name age also. So in addition to changing the name, we also want to change the age, let's make them a little bit younger. So why don't we say John is going to be 35. And so you'll see here, I had to come here and manually change the age and then come down here and manually change it again. Right. And now that we changed it, like it's going to work, it's going to be updated in our program. But you'll notice that in order to make that change, like I had to look through the entire program, find it where that value was and change it. And this was only with four lines of the story. Imagine if I had a story that was like, thousands of lines long. And we mentioned the character's name and age, like hundreds of times. I mean, I'd have to look through each one of those lines and manually change the character's name. And that is not a very good way for us to do this. And it's really not a good way for us to manage the data in our program, right, the character's name and the age. And so we can actually use a variable in order to store the character's name and the character's age. And when we use that variable, it'll make it a lot easier for us to put the character's name and age inside of our little program here. So I'm going to show you guys how we can create a variable for the character's name and age. And I'm just going to go up here above this print statement. And up here, I want to create a variable. So when we create a variable in Python, we actually need to give Python a couple pieces of information. The first piece of information we need to give Python is the name of the variable. So I need to actually assign a name to this container where we're going to be storing information. And so all I have to do is just type out the name of the variable that I want to create. So I'm going to create a variable called character name. So I'm just going to say character. And I'm going to say underscore name. And so generally, when you're creating a name for a variable in Python, you want to separate different words with an underscore. So I have two words here, and I'm separating them with an underscore. And now what I need to do is I need to put a value inside of this variable. So basically, what I can do is I can just say equals, and over here, I can type a value. So I'm just going to type out the character's name inside of quotation marks. So we're just going to type out john. So now we have a variable for the character's name. And below this character name variable, I want to create another variable called character age. So we're just going to type out character underscore age. And I'm going to set this equal to the character's age, which is 35. So we now have two variables, one representing the character's name and one representing the character's age. So what I can do now is I can replace the character's name inside of the story with this variable. And I'm going to show you guys how to do that. So if we want to put a variable inside of this print statement, I'm actually going to have to do a couple of things. The first thing I'm going to have to do is end off this text in here. So I'm going to have to put a quotation marks here at the end. And you can see I'm basically wrapping this whole thing into a single like quoted line. And now I also have this text over here at the end. So I'm going to have to put a quotation mark here. So now I have a bunch of text here in quotation marks. And then I also have text over here in quotation marks. Now inside of here, instead of saying the character's name, I want to refer to that character name variable. So I'm just going to say plus character underscore name. And I want to say another plus sign. So I basically am saying I want to print out all of this text, plus the value that's stored inside of character name, plus all of this text. And what this will do is actually print out the character's name. We print this. So I'm going to go ahead and run this program. And you'll see down here, and actually let me put a space over here. And we'll run it again. So you can see down here, we still are printing out there once was a man named John. And so what Python is doing is when it executes this line of code, it's coming over here and it's seeing, okay, they want to print out the value inside of character name. So it Python is going to go up here, it's going to get the value. And it's going to insert it inside of there. So I can basically do this for every instance of the character name in my file. So I can, you know, I'll just copy this guy right here. And I can just paste it down here where the character's name is. So I'll paste this. And you can see now we're doing exactly the same thing that we did up there. I can also do this for the character's age. So I'm going to come down here and I'll paste in what we just paste it in. And I'm going to change this instead of character name, we'll change it to character age. And I'm going to do this in one more spot. So we're going to do this over here where we're mentioning the age. And again, I'll just change this to character age. And so now when I run this program, it's going to print out the same story that we were printing out before. But now I don't actually have to type in the character's name and the character's age. I can just refer to this variable. And the cool thing about variables is if I wanted to change the character's name, now all I have to do is change it up here. So I could change the character's name to like Tom or something. And we could also change their age. So I could change the age to be like 50. And now that's going to automatically update throughout our entire story. So when I click this play button, you'll see now we're using the name Tom. And he's 50 years old. So that's where variables can come in handy. And this can be a really awesome way to control and manage the data that's inside of our programs. With variables, you can also modify their values. So for example, let's say that halfway through the story, I wanted to change the character's name. Well, I can just make some new lines over here. And down here, I can actually assign a new value to one of these variables. So I could say like character underscore name. And in order to give it a different value, all I have to do is just say equals, and we'll give it a different value. So let's say halfway through the story, we want to change the character's name to Mike. Well, now when I run on my program, you'll see here in the first part of the story, it says there once was a man named Tom. And in the second part of the story, it's referring to the name as Mike. So I actually updated the variable inside of my program over here. And that's a really awesome way. You know, a lot of times in these programs, you're going to want to be modifying the values of variables. So you can do it just like that. So finally, I want to talk to you guys about the different types of data that we can store inside of these variables. So over here, I have the character name and the character age. And I'm actually storing what are called strings. So a string is basically just plain text, right? So the name Tom, that's just plain text. Down here, these guys are strings as well. So there's a data type in Python called a string, and it's just basically going to store plain text. So, you know, any text that you would have like in a story, or you know, someone's name, you can store inside of a string. There's also another type of data that we can store inside of Python, which is numbers. So in addition to storing text, we can also store numbers. So if I wanted to store a number, for example, let's say we want to store the character age instead of inside of a string, we could store it inside of a number. So I could just type out 50. And when we're storing a number, we don't need these quotation marks, you only need that quotation mark when you're storing a string. So if I want to store a number, I can just write it out like this. And in addition to using whole numbers, I could also use decimal numbers. So I could say like 50.5678213. And Python's going to be able to store that number as well. So you can store all different types of numbers. And we can also store what's called a Boolean value. And a Boolean value is essentially a true or a false value. And there's a lot of instances in programming where we're going to want to represent true or false data. For example, I could have a variable called like is mail. And this would tell me whether or not someone was a male. And in my case, it would be true because I'm a guy, right? So I can actually this needs to be capital. So I could sort of value of either true or false. And actually, if we were naming this in Python, we want to use an underscore. So I would say is underscore mail. And this can be either true or false. So true or false values is maybe not something that you're used to dealing with like in the real world. But in programming, we're going to be using true or false values all the time. They're super important. So like I said, there's three basic types of data that we can work with in Python. There's strings, which is just like plain text numbers, which would be like either decimal numbers or whole numbers like this. And there's true or false values. And these are the basic types of data. I mean, there's a bunch of other types of data that we can use. But I would say 99% of the time as a new user and a new programmer to Python, you're just going to be dealing with these three types of data. So those are the basics of the data and also with variables. And you're going to be using variables all the time in Python. So you definitely want to practice up and get comfortable using them. In this tutorial, I want to talk to you guys about working with strings in Python. Now one of the most common types of data that we're going to be working with in Python is going to be strings. And strings are basically just plain text. So any text that we want to have inside of our program, we can store inside of a string. So I want to talk to you guys about all the cool things we can do with strings. And we're basically just going to get a full introduction into why strings are awesome. So over here, I'm just going to actually print out a string. So I'm just going to say print and inside of these parentheses, I can type out a string. In order to create a string, I need to use quotation marks. So I can make an open and close quotation marks just like that. Now inside of the quotation mark, I can put whatever text I want the string to have. So we could say like, draft Academy. And so now we have a string with the text draft Academy inside of it. So if I run my program, now down here, we're going to print out draft Academy, as you can see. And when we have these strings, there's actually a bunch of cool things that we can do with them. So one thing I could do would be to create a new line inside of the string. So if I want it, I can come over here, and I could say backslash n. And you can see it got highlighted in a different color. And what this is going to do is it's actually going to insert a new line into the string. So now it's going to say draft on one line and Academy on another line. So I'm going to click play. And you'll see down here, we just get draft Academy. In addition to the backslash n, I could also use a backslash quotation mark. So if I wanted to put a quotation mark inside of my string, I can't just put a quotation mark like that, because Python is going to think that I'm trying to end this string. So if I want to include a quotation mark, I can just use this special backslash character. And that's called the escape character. And it basically just tells Python that whatever character comes after it, we want to render literally. So when I say backslash quotation mark, it basically means like, Hey, Python, I want to print out a quotation mark. And so now we'll be able to print out a quotation mark right there. I can also use this to print out a backslash. So if I needed to print out a backslash, I could say backslash. And it'll just print out a normal backslash now. So you can see just like that. So if you want, you can use that backslash to make new lines or print out quotation marks, or you can just use it as a normal backslash. In addition to just typing out a string here, I could also create a string variable. So I could come down here up here, and we can create a variable and we'll just call it phrase. And I'm going to set it equal to draft academy. So I can store this string value inside of a variable called phrase. And then when I want to print out that variable, or I want to access that string variable, I can just type the name of the variable. And you'll see that it's going to print out the value that was stored inside of it. I can also use something called concatenation. And concatenation is basically the process of taking a string and appending another string onto it. So I could come over here and I could say phrase, and I can say plus. And now I can add in another string. So I could say like, is cool. And now this is going to say draft academy is cool. So I'm basically appending another string onto another one, they call that concatenation. And so in addition to doing all that stuff, we can also use special things called functions. And a function is basically just a little block of code that we can run. And it will perform a specific operation for us. So we can use functions to modify our strings. And we can also use functions to get information about our strings. So I'm going to show you guys a couple common functions we can use with these strings. And they're actually going to do awesome stuff. So in order to access one of these functions, I can just say phrase, and then I can say dot. And I'm going to show you guys a function that we can use to convert this string entirely into lower case. So I could just say phrase dot lower. And I'm going to want to type an open and close parentheses. And this will take this phrase, it'll take my string and it'll convert it to lowercase. So you can see now we just have draft academy down here, but it's entirely in lowercase. I could also do the same thing for uppercase. So I could say phrase dot upper. And this will convert the entire string into uppercase. You can see now it's entirely uppercase. So in addition to converting the string into uppercase and lowercase, I could also check to see if a string is entirely uppercase or entirely lowercase. So for example, I could say phrase dot is upper. And this is going to give me back a true or a false value. So it's going to be true. If the string is entirely uppercase, or false, if it's not. And you can see here, we're getting a false value because this is an uppercase. I can also use these functions in combination with each other. So for example, I could say phrase dot upper, and then parentheses. And then after this, I could say dot is upper. And now what it's going to do is it's going to run this upper function, it's going to convert it into uppercase. And then it's going to run this is upper function right after that. And you'll see now we're going to get a true value back because it will have converted the whole thing into uppercase. So you can see now we're getting a true value. So you can use these functions one after another, it can be really useful. And there's a few other ones that I want to show you. So we can also figure out the length of this string. So if I wanted to figure out how many characters were inside of this string, I could just say LEN. And I'm actually going to make an open parentheses. And I'm going to make a closed parentheses. So I'm essentially saying LEN. And this is another function, it's the length function. And inside of this LEN function, I'm actually passing this phrase variable, I'm basically giving the length function this, and it's going to spit out a number. So it'll tell me how many characters are inside of this string. And so you can see here we get 15 because there's 15 characters inside of draft academy. So that's how we can get the length of a string. And that's going to be really useful as we go forward and Python, we can also get individual characters inside of a string. So imagine if I wanted to just grab one of these characters, like imagine if I wanted to figure out what the first character in this string is, we can actually use an open and closed square bracket, just like that. And in here, I can specify the index of the character that I want to grab. So if I wanted to grab the first character in this string, I can put in a zero. So if I say phrase square bracket zero, this is going to give me that capital G. And you can see down here, that's what gets printed out. Now I want to point something out in Python, when we're working with strings, a string gets indexed starting with zero. So you'll notice that in order to access this G, I had to put a zero in here. And that's because in Python, when we use indexes on a string, we start with zero. So if Python is counting the characters, or it's indexing the characters in a string, it's going to start with zero. So it's going to say G is zero, i is one, r is two, a is three. So we would say that G is at position zero in the string, i is at position one, r is at position two, a is at position three, etc. So we start counting at zero. So if I wanted to access the first character in the string, this G, I have to say phrase zero, and that's just a special thing in Python, and actually most programming languages do that. So they'll start with zero. So for example, if I wanted to access this a, I'm going to have to put zero 123. So if I put three inside of here, now we'll be able to access that first a, as you can see, we get an a right here. So this is actually really useful being able to grab a specific character inside of a string, and you're going to be using that a lot as we go forward in Python, there's also another really awesome function that we can use and it's called the index function. And basically what the index function will do is it'll tell us where a specific character or string is located inside of our string. So I could say phrase dot index. And I can actually give this a value. So sometimes when we use these functions in Python, we can actually give them information. So I can give this a value. And we would call this passing a parameter. So I would call a value that I would give to a function a parameter, and you'll hear that word a lot. So for example, I could say inside of here capital G. And now this is going to return the index of the capital G inside of our string. So it should give us back a zero because G is at the zero of index. And you'll see down here that we get a zero because that's where G is. So for example, if I put an a inside of here, like a lowercase a, it should give me 0123, because that's where the first a is inside of this string. So I can click the play button. And you'll see it's giving us a three, you can also put actual words in here. So for example, I could put like Academy in here, or I could even just put like a C A D. And this is going to tell me where this starts inside of my string. So when I click play, it's going to give me an eight because that's where Academy starts right 012345678. If I put something in here that wasn't in the string, so for example, if I put a Z in here, that's not in here, it's actually going to throw an error. So when I play this, you'll see that we get this error down here because Z is not found inside of our program. So that index function, again, can be really useful. And we'll be using that a lot. There's also one more that I want to show you, which is called replace. So we can say phrase dot replace. And in here, I can actually give this to parameters. So I can give this replace function to values that it can use. And the first thing I want to you to give it is what I want to replace. So for example, I could say draft. And then I'm going to put a comma in here. And I want to put in here what I want to replace draft with. So I could just say like elephant. And now instead of saying draft Academy, this is going to print out elephant Academy. So you can see down here, it just says elephant Academy. So this replace function can be really awesome because we can replace certain words or even certain letters inside of our strings with other ones. So those are just some basic ways that we can work with strings inside of Python. And there's a lot of these different functions that we can use with strings. These are some of the most common the ones that I just showed you right now. But if you just do a Google search, you can find all sorts of Python functions that you can try out and use and you know, see what they do. But you definitely want to get comfortable working with strings in Python, because you're going to be working with them a lot. In this tutorial, I want to talk to you about working with numbers in Python. Numbers are one of the most common data types in Python. And any Python program you write is most likely going to be dealing with numbers at some point. So I want to talk to you guys about just the basics of using numbers, we're going to talk about the different types of numbers that we can represent in Python. And I also want to show you guys some awesome functions that we can use with numbers. So we can do certain like mathematical operations, we can do some awesome things with numbers. I'm going to show you guys all of that in this video, it's going to be awesome. So first thing we can do is we can actually just like print out a number. So if I want to write a number in Python, it's really easy. I basically just write the number. So I could say like print two. And this is just going to print the number two out onto the screen. So I can use a whole number like this. I could also use a decimal number. So I could say like 2.0987. And Python is going to be just fine with that. We'll be able to print that out under the screen as well. I can also make numbers negative. So I could make this 2.0987 a negative number. And Python will be able to handle that just fine too. And Python, we can also use basic arithmetic. So I could do things like addition subtraction multiplication. So I could say like three plus four. And now this is going to print this out. Or why don't we say like three plus 4.5. And this will be able to print out the answer. So we get 7.5. And we can do addition, we can do subtraction, we can do division, or we could do like multiplication as well. So you can pretty much do whatever you want inside of Python. And if you want to make more complex mathematical equations, we can also use things to specify order of operations. So I could use parentheses. So for example, if I said three times four plus five, what Python's going to do is it's going to multiply three and four together. So it's going to be 12. And then we'll add five to that. So we should get 17. But let's say that we wanted to change up the order, right? I could actually put a parentheses around four and five. And now it's going to add them first. So it'll add four and five. So we'll get nine, and we'll multiply that times three. So we should end up with 27. So you can see we can use those parentheses to specify order of operations. So I could make like a very complex, a little equation here just by using numbers and parentheses. We can also use one other operation, which is called the modulus operator. So I could say like 10, and use this percent sign, three. And this is actually read 10 mod three. And basically what this is going to do is it's going to take the first number divided by the second number, and it's going to spit out the remainder. So it's basically going to say, okay, 10 divided by three, that's going to be three with a remainder of one. And so this is going to give us the remainder. And you'll see down here, we get one, because that's the remainder of 10 divided by three. And that modulus operator can come in handy quite a bit. We can also store these numbers inside of variables. So we can store them inside of these variable containers. So I could come over here, and I could create a variable called like my underscore num. And we'll just store a value of let's say like five in here. And so I could come down here, and I can just print out my underscore num. And we'll be able to print that number out to the screen just fine. So in addition to doing things like a basic arithmetic, we can also do some other stuff. So one thing I could do is I could actually convert this number into a string. So if I wanted to convert this number into a string, I can just say str, and I can put the number that I want to convert inside of these parentheses. And so what's going to happen now is this number is going to be converted into a string. So when I click the run button, you'll see it's just printing out five, but now instead of being a number, this is actually a string. And this is going to come in handy when you want to print out numbers alongside strings. So I can come over here and I can say like, my favorite number, and we'll be able to print this number along with this string. So I can click play. And it says five my favorite number. If I was to get rid of this string right here, and I wasn't converting the number into a string, now Python is going to have a problem with this. It's not going to allow us to do that. You can see we get an error. So anytime you want to print out a number next to a string, you got to make sure that you use that little string function. So there's a bunch of other stuff that we can do with numbers. And a lot of times in Python, you're going to want to be using specific, like more advanced math operators. So there's a bunch of different math functions that we can use on our numbers. And a function is basically just like a little collection of code that does something. So a function could perform an operation like a mathematical operation on our number. It could also give us information about our number. So I'm going to show you guys some of the most common functions that you'll be using in Python related to numbers. The first one is called ABS, and it stands for absolute value. So we can get the absolute value of a number. And so over here, I'm just going to make this variable negative five. And basically, I can just say ABS, and I can make an open and closed parentheses over here. And this is going to give me the absolute value of this number up here. So when I click the play button, you'll see it's just giving us five, because five is the absolute value of negative five. I can use a few other functions. There's another one which is called pow. It's so it's just POW. And I'm actually not going to use this variable. We just use a normal number. And this function is going to allow us to pass it two pieces of information. So I can give this function two pieces of information. The first is going to be like a number. And the second is going to be the power that I want to take that number to. So I could say like three comma two. And this is basically just going to be three raised to the power of two. So it's just going to be three squared. So we should get nine down here. You can see that we do. So I could pass in like, you know, some crazy number, like we could pass in a four and we could raise it to the power of six. And so we should get like a pretty big number here. And you can see we get 4096. So this pow function is really useful for taking numbers to specific powers. So in addition to using this pow function, we can also use another function which is called max. So I can say max. And what this is going to do is it's basically going to return the larger of the two numbers that we pass into it. So right now I'm giving this a four and a six. And this should tell us which number is higher. So over here, it's just printing out six because that's the bigger number. I can also use another function called min. And this is going to do the opposite. So now instead of printing out the max number, it's going to print out the smallest number. And it's going to print out four down here, as you can see, another cool function is called the round function. And this is going to allow us to round a number. So it's just going to follow like standard rounding rules. So if I said like 3.2 inside of here, now it's going to round it down to just normal three. But if I said like 3.7, it's going to round it up to four. So that'll allow you to round a number. So there's a few other functions that I want to show you guys, but in order to get access to them, I'm actually going to have to do something called importing. And in Python, we can actually import external code into our files. And so if I want to access these specific math functions, I have to import something called Python math. So I can just say from up here, math, import, and this star. And basically, what this is going to do is it's going to go out and it's going to grab a bunch of different math functions that we can use. So I already showed you guys a few of these different math functions, but there's actually a bunch more. And in order to access them, we're going to need to include this line of code inside of our file. So once we have that, now I can access a few others. So there's another function which is called the floor method. And it's just FLOR. And what this will do is it'll basically just grab the lowest number. So it's essentially just going to chop off this decimal point. And you can see over here, now we get a three, because we're using that floor function, there's also another one called seal. And that's just going to do the exact opposite. So that's just going to round the number up no matter what. So no matter what, we'll always get four with we have a three point whatever here. And there's another one which is called square root. So it's just SQRT. And essentially, this is just going to return the square root of a number. So I could say like 36. And now we should get six back. So those are awesome, very interesting functions. And inside of this math module, so we would call this a module. And you don't have to worry too much about what that is right now. Just know that when we put this line of code into our program, it gives us access to a lot more math function. So it basically allows us to do a lot more things with math inside of our program. And there's a bunch of different math functions in Python. And if you want, you can basically just go online and search for different math functions. I showed you guys a few here. And I would say the ones that we looked at here are probably the most commonly used, but there's a bunch more. And like I said, you know, there's tons of documentation on all this stuff. So you can just look up, you know, math functions in Python. And there's going to be tons and tons like lists of these things that you can use inside of your programs to perform different math operations. But for now, that's just been a little bit about using numbers a little bit about doing, you know, certain math operations and using functions with those numbers. In this tutorial, I'm going to show you how to get input from a user. So we're basically going to allow a user to input information into our program. And I'm actually going to take the information that the user inputs, I'm going to store it inside of a variable. And then we're going to be able to do something with that variable. So I want to show you guys how we can actually go about getting input from someone. And down here in my Python file, all I have to do to get input from someone is I just have to type out input, and then an open and closed parentheses. And what this is basically going to do is it's going to tell Python like, hey, we want to get input from a user and Python will allow the user to type in some information. And inside of these parentheses, we can actually type a prompt. And so generally, when we want the user to enter in some information, we want to tell them what we want them to enter. And that's what we can put inside of here. So I'm just going to say, enter your name. So we're actually going to create a little Python app, which is going to allow the user to enter in their name. And then we'll store the name inside of a variable, and then we'll basically just say hi to the user. So we'll say like, hi, and then whatever the name they entered was. So what I want to do is I actually want to store whatever the user inputted into our program inside of a variable. So I can actually go over here, and I can create a variable, I could just call it name. And I could set this variable equal to input. So what I'm doing now is I'm taking the value that the user inputs, and I'm storing it inside of this variable container called name. And so now I have access to whatever they entered in. So what we can do is we can say print. And inside of the parentheses, I can just print out hello. And then I'm just going to add on to this name. And actually, why don't we put an exclamation point? So essentially, we're getting a name from the user, we're storing it inside of the name variable. And I'm printing it out onto the screen. So I'm going to go ahead and play this. And when we run the program, you'll notice down here, Python is giving us this little prompt. So it's saying enter your name. Now in here, I can actually type in a value. So I can type in Mike. And then I can just hit enter. And Python's going to go ahead store this value inside of that variable. And then it's going to print out hello, Mike. And so this is kind of cool. And actually, what we could do is we could prompt the user to enter in more than one piece of information. So I could actually copy this line of code. And I'm going to paste it below here. And why don't we have the user enter in another variable? So we could have them enter in, for example, their age. And over here, we just want to say enter your age. And so now we're able to get two pieces of information from the user. And I could say hello, name. And then I can say, you are, and I'll print out their age. So I'm just going to print age. So now I'm basically able to get both of these pieces of information from the user, I can get their name. And I can get their age. So when we run this program, I can type in both of those pieces of information. So to say, answer your name. So we could just make up a name like john, and then enter the age, let's say john is 25. And now it's going to say, Hello, john, you are 25. So the program is able to get input from the user. And then it's able to use that information in order to say hi to the user and tell them how old they are. And so getting input from the user is a great way to make your programs more interactive. And here, we're just scratching the surface, right? We're just basically getting to, you know, a piece of information from the user, but you can use these inputs to do awesome things in Python. And as we go through this course, you're going to see some really cool things that we can do with these inputs. In this tutorial, I'm going to show you how to build a very basic calculator in Python, we're basically going to build a calculator where we'll get two numbers from a user, and then we'll add those numbers together and print the answer out onto the screen. So let's look at some practice in getting input from users. And we'll also talk about getting numbers from users as opposed to just strings. So I'm really excited to get started on this calculator. The first thing we want to do is create two variables and inside of those variables, we want to store the two numbers that the user wants to add together. So down here, I'm just going to say, num one. And that's what we'll call our first variable is equal to. And now I need to get input from the user. So I'm going to say input. And inside these parentheses, I'm going to say, enter a number. And now I basically want to do the same exact thing, but for the second number. So we'll paste this guy down here. And I'm just going to say num two. And then we'll just say, enter another number. So now we're able to store the user's input inside of these two variables. So now all I want to do is just print out the result. So I'm actually going to create a variable called result. So I'm just going to say result is equal to, and basically, we just want to add these two numbers together. So I'm going to say num one plus num two. And now all we have to do is just print out the result. So I'm just going to print result. So we basically have our entire program written out here. And this will allow us to enter in two numbers, and then we'll add them together and print out the answer. So I'm going to click play. And down here, we can enter our number. So I'm going to enter the first number, we'll say five. And I'm going to enter my second number. So let's say 8.0, or let's say 8.3. So now we should print out the answer. But if you look over here, that's not quite the answer we were looking for, right, five plus 8.3 is definitely not 58.3. And here's what happened. When we get input from a user by default, Python is just going to convert it into a string. So it doesn't matter what we put down there when we're entering the numbers, Python's always just going to be like, okay, this is a string, that's it. Sounds good, right? It's just going to make it a string. In order for us to make these num one and num two variables numbers, we're actually going to have to convert the strings that we get from the user into numbers. And so the way that we can do that is by basically just coming over here. And when we add the two numbers together, I can use a special Python function in order to convert those strings into numbers. And there's actually two Python functions that we could use for this. The first is called int. So I could say int, I can make an open parentheses and I can make a closed parentheses. And basically what this is going to do is it's going to convert whatever is inside of these open and closed parentheses into an integer number. And an integer number is basically a whole number. So it's like one, two, three, four, five. So it's a, it's a whole number. In other words, it can't have a decimal point. And so what I could do is I could say, int, and I could put these inside of parentheses. And now what this is going to do is it's going to convert both of these numbers into integers. In other words, into whole numbers that don't have decimals. And it's going to add them together and we'll print out the results. So why don't we do that? And we'll just see if this works. So I'm going to click the play button. And down here, we'll enter our first number. So I'm just going to enter in a four. And then I'll enter in a five. And now you can see it's printing out the correct answer four plus five. And so that's essentially our basic calculator. But we do have one problem with this calculator. So I'm going to run it again. And I'll show you guys with that problem is if I wanted to add in a decimal number, so we'll add 4.3 and 5.5. You'll see that we're getting this error. And that's because I'm using this int function up here. And this int function is looking for a whole number. So if I put decimal numbers inside of there, it's going to break the program. There's another function we can use instead of an int, we can say float. And a float is basically just a number that has decimal. So it's a decimal number. So I can convert both of these guys into floats. And now I'll be able to use decimal numbers. So I can click play. And I can just enter in some numbers. So I could say like four. And I could also say like 5.5. And now it's going to be able to add both of those numbers, even if one of them is a decimal. And that's the beauty of using that little float function. So in certain circumstances, you might want the user to only be able to enter in an integer to a whole number. But in a lot of cases, like in this calculator, we want them to we want them to be able to enter any number that they want. So we're going to use this float function. So I'm just going to recap what we did one more time, we created two variables, num one and num two. And we basically stored the two numbers that the users input into those variables. And then we converted them into numbers. And we added them together and we printed out the results. So this is a pretty cool calculator. I'm happy with it. Hopefully you guys learned something. And as we go forward in this Python course, you're going to learn all sorts of ways that we can make this calculator more complex. In this tutorial, I want to show you guys how to build a madlibs game in Python. So a madlibs game is basically just a game where you can enter in a bunch of random words. So like, you know, verbs, nouns, names, colors. And you basically take all of those words and put them into a story randomly. So over here, my web browser, I just have an example of a madlibs. So, you know, down here, we're basically just taking random words, like an adjective or a noun or a plural noun, and entering them in side of a story. So like you read through the story and then like some random word pops up and madlibs can be pretty fun. And I'm sure you guys have, you know, at least heard of madlibs before. But if not, that was just a little introduction. So I want to create a madlibs in Python. And this is going to be really cool. So down here, I have this like little poem, which just says, roses are red, violets are blue, I love you. And so, you know, this is kind of like a classic poem. But I think we should mix it up a little bit and create a madlib for this poem. And so instead of having this red color over here, I want to have the user enter in their own color. Instead of having violets, why don't we have them enter in a plural noun? And instead of saying I love you, why don't we have them say I love and then some celebrity? So celebrity. So this is the basic structure for our little madlib, right? I want to basically have the user enter in a color, enter in a plural noun, and enter in a celebrity. And then I'll take all of those words and put them inside of our madlib. And hopefully we end up with something that's pretty funny. So how can we actually go about building this in Python? Well, the first thing we're going to have to do is we're going to have to be able to get these words from the user, right? That's pretty obvious. So I think what we should do is we should create three variables called color plural noun and celebrity. And we'll store the user's inputs inside of those variables. So up here, let's create those variables. The first variable I want to create is going to be called color. So say color. And I want to set this equal to the input. So I'm going to say input. And inside of here, I'm just going to give them a prompt. So I'll say enter a color. And we can basically just copy this line of code. And I'm going to paste it down below. And we'll paste one more time. So now we're going to create our plural noun variable. So I'll say PL, URL, plural noun. And we'll just say enter a plural noun. And actually, over here, I want to make a colon as well. So then finally, we'll create our celebrity variable and we'll say enter a celebrity. And so now basically, we're creating three variables called color plural noun and celebrity. And inside of them, we're storing the color that the user enters, the plural noun, the user enters and the celebrity, the user enters. So last thing we have to do is replace these guys with those variables. So I'm basically just going to add in the color over here. And we're going to add in the plural noun. So I can just go like this. And finally, we'll just add in that celebrity. So now we have a pretty cool mad lib. And it should be functional. Everything should work. It looks like it's good to go. So let's come over here and we'll run our program. And then down here in the console, we can play our little mad libs game. So let's say enter a color, I'm just going to say magenta, enter a plural noun. Why don't we say microwaves and enter a celebrity, let's say Tom Hanks. So when I click enter, what should happen is we should get our mad libs printed out. So I'm going to click enter. And now we have our mad libs. So it says roses or magenta, microwaves are blue. I love Tom Hanks. So it's a pretty good mad lib. And obviously, you know, the more the more print statements we put over here, you know, the better the mad lib could could be. And we could store as many, you know, variables up here as we wanted. This was just a very simple mad lib. We only took in three inputs, but you know, you can see how you could take something like this and create a little mad libs game. So your homework for this lesson is to go off and make your own mad libs game. Hopefully one that's a little bit funnier than mine. But that's the basics of creating a mad libs game in Python. In this tutorial, I want to talk to you guys about working with lists in Python. A lot of times when you're programming in Python, you're going to be dealing with large amounts of data. And when you're dealing with large amounts of data, you want to make sure that you can manage it and organize it properly. And the list is essentially just a structure that we can use inside of Python to store lists of information. So we can take a bunch of different data values, we can put them inside a list, and it allows us to organize them and keep track of them a lot easier. So generally, you would create a Python list, and you would put a bunch of related values inside of that list, and then you can use it throughout your program. So I'm going to show you guys just the basics of using lists, we're going to look at some of the common use cases and really just get you up to speed with what lists are and why they're useful. So over here in my program, I'm actually going to create a list. And we create a list a lot like we create a Python, just like a normal Python variable. So the first thing we want to do when we're making a list is give it a name. So we want to give it a descriptive name, something that's going to basically describe what's inside the list. In my case, for this example, let's make a list of like friends. So we could say like here's a list of all my friends. So I can say friends. And I'm going to set this equal to the list of values that represent my friends. And we want to create a list, we can use these open and closed square brackets. So whenever you use these open and closed square brackets, Python basically knows, okay, they want to store a bunch of values inside of this list. So why don't we go ahead and start adding some values? So we can say like my friends are like Kevin, Karen, and let's say Jim. So here I have three values inside of my friends array. So when we're creating a normal variable in Python, generally, we just give it one value, right? So I would create a variable, I would give it one value, maybe a string or a number or a boolean. But when we make lists, we're able to store multiple values inside of the same like little item inside of the same object, right? And then what I can do is I can access these individual items inside of my program. So inside of this friends list, we're basically storing all of these different values, and that can be really useful. So now that we've stored some values, let's talk about what you can put inside of a list. So you can really put any piece of information in Python, we could put things like strings, numbers, or booleans. So if I wanted, instead of just putting strings here, I could change like one of these to a number, and I could change one of these to a boolean, and it wouldn't matter, Python is going to be fine with that. But let's change these back to strings just for the sake of the example. So now that we've created our list, how can we access individual elements inside of this list? It's a good question. I'm gonna go ahead and print something out to the screen. The first thing we can do is we can just print out the actual list. So I can just say print friends. And then when I run this program, if we look down here in the console, you can see it's just printing out the actual list of friends, right? But let's say that I wanted to print out a specific element inside of this list. Well, I can actually refer to elements by their index. So each one of the elements inside of this list has a particular index. And the index is actually start at zero. So we would say that this first element in the list, Kevin has an index of zero. We would say that this other element Karen has an index of one. And this third element Jim would have an index of two. So even though Jim is technically the third element inside of the list, it has an index of two. And that's because we start indexing index position one. And so that's just kind of how lists work. And that's how list indexes work. So if I wanted to access a specific element inside of my friends list, I can just refer to it by its index. So over here after we type out friends, I'm just gonna type an open and closed square bracket. And inside of this open and closed square bracket, I want to put the index of the element inside the list that I want to access. So if I wanted to access this guy right here, this element, I can just put a zero. So I can say friends zero. And now when I run my program, it's just gonna print out that value, it's just gonna print out Kevin. If I wanted to access this Jim value over here, I can put a two. And that will give us that Jim value, you can see right there. So we can access elements based off of their index, we can also access elements based off of their index from the back of the list. So for example, if I said negative one inside of here, this is gonna give me access to this value right here for Jim. And you can see that sort of does so when we use negatives, it starts indexing from the back of the list. So if I said negative two, this is gonna give us Karen. And so you can use the negatives to access items at the back of the list. Just keep in mind though, and this is kind of interesting. We would say this first element here is index position zero, right? But we would say the first element at the back of the list is index position negative one. So just keep that in mind. So there's actually other ways that we can access like just portions of this list. So for example, let's say I just wanted to select the last two elements in this list. And I didn't want to select the first one. Well, in here, I can just say one with a colon. And this will grab the element at index position one and all of the elements after that. So now we should just grab Jim and Karen or Karen and Jim in that order. I could also specify a range. So actually, let me add in a couple other elements just so we can illustrate this better. So I'll add in two more names. So if I wanted to, I could select like the element at index position one up to the element at index position three. So it's going to grab this one. So that's one, two. And it's actually not going to grab the third one. So it's it's going to grab all the elements up to but not including three. So it'll grab Karen and Jim. So let's go ahead and run this. And you can see it grabs Karen and Jim. So you can either just put like one with a colon after it, and then it'll grab that index position and everything after it, or you can specify like a range that you want to grab from. So that's how we can access elements inside of this list. But we can also modify elements. So for example, I could come down here, let's say I want to modify this value right here, Karen. Well, all I have to do is just access that element. So I could say friends and Karen is at index position one. And I can change this to whatever I want. So I could say friends index position one is equal to Mike. And now when we print out friends index position one, that value is going to be updated. So it's just going to say Mike instead of saying Karen. So it can be really useful to modify values inside of arrays. So it can be really useful to modify values inside of Python lists. So those are kind of the basics of working with lists in Python. And actually in the next tutorial, I'm going to show you guys even more ways that we can use these lists, we're going to learn how to like add elements to a list, delete elements from a list, copy lists, and a bunch of cool stuff with these lists. But for now, this has just been sort of like the basics of working with lists. In this tutorial, I want to talk to you guys about using functions with lists in Python. And Python, a list is one of the most important structures where we can store our information. A list basically allows you to take a bunch of different values and organize them and store them inside of their own little list structure. So down here in my program, you can see I have two lists. I have a list of lucky numbers. And this is just a bunch of different numbers. And then I have a list of friends. So this could be like a list of somebody's friends. And it's basically just a bunch of strings with names in them. So these two lists are storing a bunch of different values. And what makes lists awesome is not only could I store like this many values, I mean, I could store hundreds or thousands or millions of values. And when you're working with a lot of data and a lot of information in Python, these lists are invaluable. So because lists are so important, there's actually a bunch of different functions that we can use with lists. And those functions allow us to do things like modify the lists and get information about the list. So in this tutorial, I just want to show you a bunch of those functions, we're going to talk about some of the most common and the most popular functions that you would use on lists to make them more powerful and make them more easy to use. So the first thing we can do is obviously just print out a list. So down here, I'm printing out this friends list. And when I want to run my program, you see down here, we're just printing out all the elements in the list. So it's always good to be able to print out all the elements inside of a list. But there's a lot of other functions that we can use. So one function is called the extend function. And the extend function will basically allow you to take a list and append another list onto the end of it. So I could say like friends dot extend. And inside of these parentheses, I can pass in the list that I want to add on to the friends list. So I could say like lucky numbers. And now when I print out this friends list, not only is it going to have all the elements in the friends list, it's also going to have all the elements inside the lucky numbers list. You can see down here, we have all of our friends. And then we also have the numbers over here. So that's a really easy way to essentially just like, add two lists together. We can also just add individual elements onto a list. So I could come down here and I could say friends dot append. And this will actually allow me to append another item onto the end of this list. So over here, I could just add another name. So we could say creed, for example, and now I'm like adding another friend onto the end of this list. So when I run the program, in addition to having the original items that were in the list up here, we also have this additional item at the end, and that append function is always going to add the item onto the end of the list. But let's say that you wanted to add an item into the middle of the list. So like right here or right here, there's another list function called insert. And insert is going to take two parameters. The first parameter is going to be the index where you want to insert the item. So why don't we insert it here at index position one? I'm just going to say one. And then I'm going to type in the name of the element that I want to add. So we can just say like Kelly. And now at index position one, we're going to have the value Kelly, and all of these other values are going to get pushed up, they're going to get pushed to the right one index position. So now I run the program, you can see we have Kevin, this new element Kelly, and then all the other elements have been pushed off to the right, we can also remove elements. So for example, let's say I wanted to remove this gym value, all I have to do is just say friends dot remove. And I can just type in whatever element I want to remove. So I want to remove this gym element. And so now when we run the program, Jim is going to be gone from the list, and we just have these four guys left, you can also remove all of the elements from the list. So if I just wanted to completely like reset the list and get rid of everything, I could just say friends dot clear. And this is going to give us an empty list. So it'll get rid of every single element inside the list. There's also another really cool method, which is called pop. And you can just type out pop like that. And basically what pops going to do is it's going to pop an item off of this list. So when I click the play button, you'll see here that we're left with Kevin, Karen, Jim, and Oscar. So we basically got rid of the last element inside the list. And that's what pop does, it pops an element off of the list. So it basically removes the last element in the list. So we have our list, but let's say that we wanted to figure out if a certain element was in this list, right, if a certain value is in here, so let's say I wanted to check to see if my friend Kevin was in this list, well, I could say friends dot index. And in here, I can just pass a value. So I could say like, Kevin, and this is going to tell me the index of Kevin. So it'll tell me if Kevin's in the list. So now when I click play, you can see down here, it says zero. If I was to say like Oscar in here, for example, now it'll give me the index of Oscar. So that's it three. But if I put a name that wasn't in here, so like, if I put Mike, that's not in the list. And so now we're going to get back in air, because it says Mike is not in the list. So that's an easy way to figure out if a specific element is inside of the list. And if it is, then you know what index it's at, you can also count the number of similar elements in the list. So I'm actually going to come down here, copy this gym element, and we'll add another gym element into here. So I could come down here and I could say friends dot count. And we'll pass in gym. And this will tell me how many times the value gym shows up inside of this list. So it should say two, which it does down there, because we have two values with the text gym. And so we have all these values, we could also sort this list. So I could come over here and I could say friends dot sort. And what this will do is it'll sort the list in ascending order. So we have a bunch of text here, and you'll see what it does. Basically, what it's going to do is it's going to put it in alphabetical order. So you can see we have J K O and T. So the list went from being just random order, like whatever we had up here to now it's in alphabetical order. And that's also going to work for lucky numbers. So I could say like lucky numbers dot sort, and then we'll print out lucky numbers. And these should now be in ascending order, which I'm realizing they already are up here. But if I was to take this 42 and put it down here, now it will figure everything out and put it in ascending order. Anyway, we can also reverse a list. So if I wanted, I could reverse this lucky numbers list, I could say lucky numbers dot reverse. And now when we print it out, instead of being 4815 1623, it's going to be 2316 15 842. So it's basically just reverse the order of the list. And finally, there's one more list function I want to show you guys which is copy. So I could actually create another list, and I could make it as a copy. So I could say like, friends to, and we could set this equal to friends dot copy. And now friends to is going to have all the same attributes as friends. Because it's basically just like copied it basically took a copy of that friends list. So you can see it's the same exact thing and copying lists can come in handy in a lot of different situations. So those are just some basic list functions and just to kind of like, you know, get your feet wet and working with lists. Obviously, like the more you work with them, the more you practice using these different functions, the more comfortable you're going to get. But that's just kind of like a basic overview of what you can do. In this tutorial, I want to talk to you guys about tuples in Python. Now a tuple is a type of data structure, which basically means it's a container where we can store different values. Now if you're familiar with lists in Python, a tuple is actually very similar to a list. It's basically a structure where we can store multiple pieces of information. But a tuple has a few key differences from lists that we're going to talk about in this tutorial. First thing I want to do is I want to show you the how to create a tuple. So I can come down here and I can create a tuple. And one of the most common examples of tuples is coordinates. So let's say I had a series of like XY coordinates, I could create a variable called coordinates. And I'm just going to set this equal to an open and closed parentheses. And whenever we want to create a tuple inside of Python, we're going to use these open and closed parentheses. And inside of here inside of these parentheses, we're going to put the values that we want to store. So I could, for example, put a list of numbers. So this could be like my coordinates, I could have like four and five. So this would be my tuple with coordinates inside of it. And one of the things about tuples that makes them unique is a tuple is immutable. And you'll hear that word a lot when we're talking about tuples immutable, it basically means that the tuple can't be changed or modified. Once we create our tuple up here, you cannot modify it, you cannot change it, you can't add elements to it, you can't erase elements from it, you can't change any of the elements inside the tuple. What you see is what you get, once you create the tuple, it's, it's as it is, it can't change. So I could come down here and I can print out some of the attributes inside the tuple. And the way I can access them is just by using an open enclosed square bracket. And in here, I can pass in a index. So tuples are indexed starting at zero. So technically, we would say that four is at index position one and sorry, four is at index position zero and five is at index position one. So if I said coordinate zero, now it should print out four. And down here, we're printing out four. So if I wanted to print out that five, we can just put a one inside of those square brackets. And now we'll print out that five. So I can access the elements inside of a tuple, I can easily access each, each entry. But if I was to come over here and try to change one of the elements, so if I said coordinates, and coordinates one, and I tried to set it equal to something else like 10, Python's actually going to give us an error when we run this program. So I'm going to run the program, you see we get this error, it says, type error tuple object does not support item assignment, because it's immutable, because we can't change it. So that's basically what tuples are how we can create them. And you know, a tuple, like I said, it's very simple, you just create it, and then you have it. And now I want to talk to you guys about a common topic in Python, which is the difference between tuples and lists. So remember, a list is basically doing the same thing a list. If we wanted to create a list, we would just use square brackets instead of those parentheses. And if I was using a list, I could assign different values to it, I could I could basically mutate any of the elements I could add delete, modify change, whatever I wanted with the list. But with a tuple, we can't do that. And that's sort of the basic difference. And really, Python doesn't say anything more than that. It basically just says like one of them's immutable, one of them's not. But in practical use cases, generally, people will use tuples for data that's never going to change. So you'll you'll store data inside of a tuple, when that data doesn't need to be mutated. That's why something like coordinates is such a good candidate for a tuple, because once you have coordinates, like, we're probably not going to modify them, right, we might add other coordinates. So for example, if I wanted, I could create a list of tuples. So I can say like 4567, maybe we have some other coordinates, like 8034. So here I have, you know, I have a list and inside of it, we have these tuples. But remember, these tuples can't be modified, the values can't be changed. So really, it's just a case by case basis, I would say by a huge majority, you're going to be using lists most of the time. Tuples are more of a niche, you know, they're using more special situations. But there are plenty situations where you want to use tuples. So if you're in a situation where you want to store data that can't be changed or mutated, then tuples are the way to go. So yeah, that's just some basics about tuples, some basics about the difference between lists and tuples. And so a tuple is a great thing to add into your Python repertoire. In this tutorial, I want to talk to you guys about using functions in Python. Now a function is basically just a collection of code, which performs a specific task. So I can take a bunch of lines of code that are basically doing one thing, I can put them inside of a function. And then when I wanted to do that task or do that one thing that the function was doing, I can just call the function. And so functions really help you to organize your code a lot better, they allow you to kind of break up your code into different, you know, little chunks that are doing different things. And they're really just awesome. So functions are like a very core concept when we're talking about programming in Python. So I'm going to show you guys how to create an awesome function today. Let's say for the purposes of this tutorial, we want to create a function that says hi to the user. So the one task that our function performs is basically just saying hi to whoever is writing the program. So over here, if I want to write a function, the first thing I have to use is a keyword in Python, it's called death. So D E F. And basically, when Python sees this keyword, it's going to say, okay, this person wants to use a function. So after we type out death, we need to give this function a name. So just like when we are creating variables, we give them descriptive names, we also want to do the same thing with functions. So if I'm creating a function, I can just give it a specific name, which basically says like what it's doing. So we're going to create a function that says hi. So I'm just going to call this function, say hi, just like that. And once we type out the name of the function, and so also I could type out say hi with no underscore or I can type out say hi with an underscore, both are considered like good practices in Python. A lot of times, if you just have a simple like two word function like this, you don't need to put an underscore, but we could put an underscore there. If we wanted, after we type out the name of the function, I'm just going to type an open and close parentheses. And then I'm going to type a colon. And basically, what this is doing is it's saying to Python, like, all right, all the code that comes after this line is going to be inside of our function. And in order to write code that's going to end up being inside the function, we actually have to indent it. So over here, you'll notice that when I clicked enter, my text editor automatically indented the text. So it's automatically like, using this indent here. And that's kind of like one of the rules in Python is like, the code that goes inside of this function needs to be indented. So if I was to write some code, like out here, this is no longer going to be considered inside the function. So you can see, as I type out code, and obviously, this isn't real code, but as I type text over here, that's indented, this little like marker over here is basically saying like, Oh yeah, that's inside the function. But then when I write code over here, that is like not at the same indentation level as this stuff, it's no longer considering it inside the function. So that's just a little thing. Any code inside this function needs to be indented. Alright, so our function is just going to say hi to the user. So I'm just going to have it print out some text, it's going to say hello, user. So this is a very simple function. Obviously, we just have one line of code and inside of a function, you could have, you know, as many lines of code as you want. But for our purposes, we only need one line in order to perform our function. So now all we have to do is call this function. So if I want to execute the code inside of this function, I have to do something called calling it. So if I was to just run my program as it is right now, I'm just going to run it, you'll see that nothing happens over here, right? Even though this function is printing out hello user, when I run the program, it's not doing it. And that's because the code inside of a function isn't going to get executed by default. The code inside of a function is only going to get executed when we specify that we want to execute it. And in order to do that, we're going to have to do something called calling the function. So in order to call the function, you basically just type out the functions name and those open and close parentheses. So I'm just going to type out say hi, and open and close parentheses. And now when we run this program again, you'll see that it prints out hello user. So we're executing the code inside of the function. And I want to show you guys just one more thing here, just talking to you guys about how these functions actually work. So up here, I'm going to print top. And then down here, I'm going to print bottom. So I want to show you guys the flow of these functions inside the program. So when I run this program, you'll see we print out top hello user, and then bottom. So essentially, what's happening is when Python goes through and executes this program, it goes over here to this first line, it says, okay, we want to print out the word top. And then it goes down here and it says, okay, we want to execute the say hi function. So Python actually jumps up, and it goes over to this say hi function, and it's going to execute all of the code inside of this function. So it's going to go through execute all this code. And then once it's done executing all the code in the function, it's going to jump back down here, and it's going to move on to the next line, which is bottom. So that's kind of like the flow of functions. Again, with functions generally, when we're naming these functions, you want them to be named in all lowercase. And usually, when we're naming stuff in Python, if there's two or more words, we're going to use an underspace or an underscore in between them. So I could write this out as say underscore high. But in a lot of situations, though, if I have a function like this where the name is really short, I might just be easier to leave it without an underscore, but why don't we just put an underscore in there just to be a super Python official. All right, so now we can actually make these functions a little bit more powerful. And what we can do is we can give them information. So a lot of times when we write a function, we're going to want to have additional information that gets passed in. And these are called parameters. So a parameter is a piece of information that we give to the function. So over here, I can actually specify that this function needs to receive some parameters. So I can basically say like, Hey, if you're going to call this function, you need to give us some information, you need to give us some parameters. And all I have to do to do that is just type out the name of the parameter that I want to receive. So why don't we allow the code calling this function to tell it what name to say hi to up here, I can just say name. And basically, what this means is it means whenever I call this say hi function, we have to give it a name. So down here, if I was to call this, I have to include a name in here. So I can say like, Mike, and what we can do now is we can actually access this parameter or this variable inside of our function. So I could come over here and instead of saying hello user, I could say hello name. And basically, what this is going to do is it's just going to say hello to whatever name got passed in here. So I'm actually going to copy this and we will do this twice. So I'll say hello, Mike hello, Steve. And now when I run this program, you'll see that instead of just saying hello user, it's saying hello to whichever name I passed into the function. So that's why this can be really useful, right? We can give the function information, and depending on the information we give it, it'll perform its task a little bit differently. I could also include more than one parameter. So you can, I mean, technically, you could have like as many parameters as you want. So I can put another one in here, we can say age. And now I'm going to have to pass in an age along with these. So I'm just going to pass in age and pass in an age for down here. And I'm just going to pass in strings. So we can say hello name. You are age. So I'm passing in two pieces of information. And now when we run this program, it's going to call the function. And it's going to use both of those pieces of information. So I say hello, Mike, you are 35. Hello, Steve, you are 70. So essentially, we're writing out this one line of code, which just prints out like hello to someone. And we're allowing this function to receive two parameters. So the name and the age, and depending on the name and the age, the function's going to print out hello a little bit differently. And that's kind of the beauty of using function. So you could pass anything you want into a function. So for example, I could pass in a integer instead of a string for the age. So like I could pass in the number, the only difference is over here, we're going to have to convert this into a string. But it's going to work just the same. So you could pass in strings, numbers, bullions, arrays, you can really pass any type of data into a function. And it's going to work. So you can see here, we get the same result. So that's the basics of functions. And as you go through with Python, you're going to be using functions more and more. And generally, it's a good idea to break your code up into different functions. So whenever you have like a grouping of code that's designed to perform a specific task, that's usually a good candidate to be put inside of a function. In this tutorial, I want to talk to you guys about using the return statement in Python functions. Now Python function is basically just a collection of Python code that performs a specific task. And when we want to perform that task in our Python programs, we can call a Python function. And a lot of times when we're calling a Python function, we just kind of call it and it does its thing. And then we move on with the program. But sometimes when we call a function, we're actually going to want to get information back from that function. So when I call the function, I want it to basically execute its task, I want it to execute all the code. And then I want it to like give me some information back. So that could be like a particular value, it could be something like telling me how the task went. Basically, the function can just communicate back to us like, Hey, here's some information. And that's what the return keyword can allow us to do the return keyword can basically allow Python to return information from a function. So I'm going to show you guys how we can do this, I want to create a very simple function. And it's just going to cube a number. So when we cube a number, we take it to the power of three. So if I was going to cube like two, it'd be like two raised to the power of three. Right, it's just pretty basic math. So we're going to make a function that will cube a number. And I'll show you guys how we can use that return statement. So first thing we want to do is make a function, I'm just going to say death cube, we'll call the function cube. And over here, we can specify any parameters that this function will take. So basically, any values that we want to give this function. So we're going to give it one function, which is just going to be a number. So I'm just going to call it num. And then over here, I'm going to type out a colon. And then down here, we can put any of the code that we want to be included in this function. So basically, this function is just going to cube this number. So we could just type out num, times num, times num. Right, that's going to give us num cubed. So that's all well and good. And if I come down here, I can execute this function. So I can basically just call it, I'll say cube. And why don't we pass it a three? So I'm going to go ahead and pass it to three. And I'm going to save this. And now let's go ahead and run this code. So we're on the code. And you'll see down here, nothing happened, right? So nothing got printed out in our program. In fact, when we call this cube function, it didn't really do anything. So let me try to print this out. So maybe if we print this function out, it'll give us back the information that we want. So type out print, and we'll print out the value of the function, I'm just going to click play. You look down here, it says none. So when I printed out the value of this function, it told me none. But really, this function is supposed to be cubing the number. And here's how we can use the return statement in Python. I can come over here and I can just say return. And now Python is going to return whatever value we put over here to the right. So when I call this cube function, and I give it a three, Python is going to go off, it's going to execute this function. When it sees this return statement, it's going to say, okay, I want to give a value back to whatever call of this function. And it's going to return this value. Now, when I print out cube three, it should print out the answer because we get an answer back. So when I play this, you'll see down here, it says 27. So we got the correct answer. So I could do this with anything, why don't we cube like four or something? So now we're on this. And you can see we're constantly getting the correct answer back. So that's the basics of using this return statement, it allows us to return a value back to the caller. In other words, back to whatever's calling the function. So I just want to illustrate this point a little bit further, I'm going to come up here, I'm actually going to create a variable. So I'm going to create a variable called result. And I'm just going to set it equal to cube four. This variable result is going to store the value that gets returned from the cube function. So it's not going to store like cube four, it's going to store the value that gets returned from executing that function. So now if I came down here and printed out result, it's actually just going to print out 64 again, because that's the value that it's storing. So this return statement can be really useful for like getting information back from a function, we can use something like a parameter, like this four as a parameter, and we can give information to a function. And then we can use the return statement to get information back from a function. And I do just want to point out one more thing, I'm actually not able to put any code after this return statement. So if I came down here and tried to put like a print statement, this actually isn't going to work. So this is never going to get printed out. So if I just typed out like code right here, when we run this program, it's not going to type out code. That's because when I use this return keyword, it breaks us out of the function. So Python's going to go through, it's going to execute the code in the function, whenever it sees this return keyword, it's just going to break back out and we're going to be done. So we'll never be able to reach this line of code. So that's the basics of using return statements. And you can return any data type you want, we could easily return like a string or a Boolean or an array, it doesn't really matter, you can return whatever you want. And a lot of times in a lot of situations, you're going to want to get a value back from a function. In this tutorial, I want to talk to you guys about using if statements in Python. Now if statements are a special structure in Python, where we can actually help our programs to make decisions. So by using an if statement, I could execute certain code when certain conditions are true. And I can execute other code when other conditions are true. So basically if statements allow our programs to respond to the input that they're given. So depending on the data that we're using in the program, our programs will be able to respond. So when certain data is certain values, we can do certain things. And when other data is other values, we can do other things. So you know, your programs are essentially becoming a lot smarter. And actually, if statements are things that we as human beings deal with every day. So you know, as you go throughout your day, generally, you're dealing with if statements all the time. So I want to kind of give you guys a brief introduction into if statements, and we'll talk about some of the common if statements that you'd see in everyday life. And then we'll go ahead and do a really awesome example to kind of like show you guys what if statements can do for us. So over here in my text editor, I just have this little text file. And in here, I wrote out a bunch of if statements that a lot of people will encounter on a daily basis. So here's the first one, it says I wake up, if I'm hungry, I eat breakfast. So let's break this down a little bit up here, it says if I'm hungry. And this is a condition, right? This is either going to be true, or it's going to be false, right? If it's true, I'm going to go ahead and eat breakfast, right? If it's false, I'm just going to skip whatever was in here and move on, right? So that's the basics of an if statement, right? We have a condition, in this case, if I'm hungry, if the condition is true, then we do the action. So we eat breakfast. Otherwise, we just skip it. So down here, we have another one, it says I leave my house. If it's cloudy, I bring an umbrella. Otherwise, I bring sunglasses. And so this one is a little bit more complex than the one we just looked at. You'll see we have our condition, right? It says if it's cloudy, if that condition's true, we're going to bring the umbrella. But in this case, if the condition's false, there's something else that we want to do. So in the case up here, if this condition was false, we just moved on. But now if this condition's false, then we're going to go ahead and bring sunglasses. So that's another example of an if statement, it's a little bit more complex. Finally, I have one more down here, and this one's even more complex, it says I'm at a restaurant. If I want meat, I order a steak. So if this condition's true, we order the steak. But if this condition is false, then we're going to move on, and we're actually going to check another condition. So I'm going to say otherwise, if I want pasta, I order spaghetti and meatballs. This is another condition. If this condition's true, we get the spaghetti. If it's not true, then finally, we're going to move on down here, and we'll just default to ordering the salad. So all three of these if statements are valid if statements, it's just they get more and more complex as we go down the list. So hopefully that's, you know, it can kind of wrap your head around what if statements are we're basically specifying conditions. If those conditions are true, we're going to do certain things. And if those conditions are false, we can do other things, or we can check other conditions. All right, so let's head over to our Python file, and we'll start writing some actual Python. So in here in my app dot Python file, I want to create an if statement. And I'm going to show you guys a very basic if statement in this tutorial. And then in the next tutorial, we're going to look at some more advanced if statements. And so what I want to do is create a Boolean variable. So I'm going to create a Boolean variable that's going to store whether or not the user is a mail. So it's just going to be called is underscore mail. And I'm going to set this equal to true, because I'm a male. So we have this Boolean variable, right? And right now we have it set equal to true. I can actually use an if statement to check to see what the value of this variable is. And if it's true, I can do something. So if I want to use an if statement, all I have to do is just type out if, and then I just need to type out a condition. So basically, I would have to type out like something that's going to be true or false. Like, for example, in the other page, we were specifying like, if I'm hungry, or if it's cloudy, here, we're just going to check to see if is mail. So in other words, if the person is male. And so remember, this has to be a, like, it has to be able to be reducible to a true or a false value. So in our case, we're just using a Boolean, because that's like the easiest thing we can do. So I said if I specified my true or false condition, and now I want to just type a colon. And what I want to do now is make a new line. And so anything that I put below this with an indentation is actually going to be executed when that conditions true. So I could put print. And down here, I could just put you are a male. And now you'll see what happens when I run this program, it's going to go down here, and it's going to say you are a male. But if I changed is mail to false. So instead of this being true, I just change it to false. Now all of a sudden it's not going to print anything. So it's just going to be blank down here. That's because this condition wasn't true. So anything that I put below this if declaration and that has an indentation like that is going to be executed when the if statement is true. We can also use another keyword in Python, which is called else. And else is basically going to be like otherwise. So you remember before we said, if it's cloudy, I'll bring an umbrella. Otherwise, I'll bring sunglasses. Well, this is going to be like our otherwise. So I can say down here else. And now anything that I put below else is going to get printed out when that condition isn't true. So why don't we just put you are not a male. So now we're able to cover both of the situations for this variable. If it's false, we can cover that situation. So it says you are not a male. If it's true, we can cover that situation as well. So it'll say you are a male. So that's pretty cool. But we can also make these more complex. And actually before I talk about that, you can put as much code as you want inside of an if statement. So I could have like, you know, dozens of lines of code if I wanted. I'm just giving you guys a very simple example. So why don't we make this more complex? And I'm going to add another variable into the mix. So I'm going to add another, you know, Boolean attribute into this mix. I'm going to make another variable called is tall. And we're going to set this equal to true as well. So now I have two variables in the mix. Let's say I wanted to write an if statement that will check both of those variables. So I could write an if statement that's like, if they're male and they're tall, or if they're male and they're not tall, or if they're not male and they're tall, like I could write out a bunch of if statements to check the combination of these variables. And so the way I can do that is by using one of two keywords. So the first keyword I want to show you guys is the or keyword. So I can come over here and I can say if is male, or is underscore tall. And what this is basically going to do is it's going to say if the person is either male, or if they're tall, then we want to do something. So this is only going to be true when one of these values is true, when one or both of those values is true. So down here, we could actually put instead of you are a male, we could put you are a male or tall or both, that's going to be more appropriate. And then down here, we would say you are neither male nor tall. And that's because if we execute the code inside of this else, that means that both of these guys are false. Right, so I'm saying if they're male or they're tall, we're going to execute whatever is in here. Otherwise, that means they're neither male nor tall. We're just going to execute this down here. So let me show you guys how this works. I'll click play. And these are both true. So it's going to say you are a male or tall or both. If I was to set one of these to false. So let's set is male equal to false. Now, it's still going to say you are a male or tall or both. But if I set them both equal to false, now it's going to say you're neither male nor tall. So that's kind of the basics of using the or operator. And there's another operator we can use which is called and, and basically it's similar to or except both of these conditions have to be true. So this is basically saying if the person is male and they're also tall, then we're going to execute whatever is in here. So we could actually change this text to say you are a tall male, because we know for a fact that if this is getting executed, they're both male and tall. We can also change this print statement down here. This could say you are either not male or not tall or both. So you can see it's basically just saying that you're either not one of them or you're not both of them. So we click the play button and you'll see because they're both false, it's going to say you are either not male or not tall or both. But if I make them both true, now it's going to say you are a tall male. If I was going to make one of these false, though, so let's make is tall false. Now it's not going to execute this first print statement. It's going to execute the one inside of the else. So to say you are either not male or not tall or both. So that's the basics of and an or and you'll be using those a lot as you use your if statements. But there's actually one more thing we can do. We can add in some more conditions. So up here I'm checking if they're male and they're tall. But what if I wanted to check if they're and they're not tall? So if they're like a short male, I can use another keyword in Python called else if or really it's just typed out E L I F and it stands for else if and after this we can put another condition. So over here I want to check to see if they're male and they're not tall. So I'm going to say else if male is male and now I can type in not tall and the way I can do that is by saying not an open and close parentheses and saying is tall. And basically when I use this not function it's going to negate whatever is inside of here. So if this was true it's going to make it false and if this was false it's going to make it true. So basically that'll tell us whether or not they're tall. And then I'm going to use a colon and now down here inside of here we're basically just going to type out any of the code that we want to happen when this condition's true. So down here we can just print out you are a short male and there's actually one more condition that we want to check for which would be if they're not male and they're tall. So we can make one more else if and I'm actually just going to copy this guy and we'll paste it down here. And so I want to say if not is male and is tall. So now we're checking to see if they're male and or if they're not male and they're tall. So here we could say you are a you are not a male but are tall. So essentially here we have an if statement that's going to cover every single condition for these two variables. So in every single situation of the two values of these variables we're going to be able to print something out for it. So if I made both of these true it's basically going to tell us you are a tall male. If I make is male false it's going to tell us you are not a male but are tall. If I made is male true and is tall false then it's going to tell us you are a short male. And if I made both of these false it's going to tell us you are either not male or not tall or both. And actually we need to change this. So this should say you are not a male and not tall. So that would be a better print out for that situation. So you can basically see how we can use if else ifs and else in order to help our program to make decisions and really to respond to the different data in our programs. So I'm able to respond to every combination of the values for these two variables. And that's really cool. So in this example we were just using simple Boolean variables but in the next tutorial I'm going to show you guys how you can actually use something called comparison operators. So we could compare like two numbers or two strings and we could use those as our conditions. But for now I think this is a good introduction into if statements. So I'll see you guys in the next tutorial. In this tutorial I want to talk to you some more about if statements in Python. More specifically we're going to be looking at using comparisons inside of our if statements. So if you're following along with the course in the last tutorial I talked to you guys about just the basics of if statements and we used a couple different Boolean variables. And depending on the values of those bullions we were able to do certain things. In this tutorial we're going to look at another way to use if statements which is with comparisons. So instead of just using Boolean values we can actually compare different values. So I could compare a couple numbers or I could compare a couple strings. And depending on the results of those comparisons we can do certain things. So this is going to be pretty cool. And this is really going to give you guys a full understanding of what you can do with if statements. So for this tutorial I actually want to create a Python function. And this function is going to give us the maximum number that we pass into it. So this function is going to take three parameters as input and it's going to print out the biggest number that we give it. So let's create this function. I'm just going to say death. And I'm just going to call it max num. And inside of these parentheses I'm going to specify that I want three parameters as input. So I'm going to say num one, num two and num three. So basically we're passing it three numbers and this function will return the largest of the three. So in order to figure out which of these numbers is the largest we're going to have to use an if statement. So I can say if and over here I need to specify a condition right so I need to put like a true or a false value. And so what we can actually do is we can compare these different numbers. So I could say if num one is greater than or equal to num two. And num one is greater than or equal to num three. So basically what I'm doing here is I'm comparing these different numbers. So I'm saying if the first number is greater than or equal to the second number. And this is a comparison. So when you think about it, when we compare these two numbers, we're going to end up with a true or a false value. Right, num one is either greater than or equal to num two or it's not. It's actually a Boolean value right it's either true or it's false. Same thing over here. The result of this comparison is either true or it's false. So technically I'm putting a true or false value in there. I'm just getting that true or false value by using a comparison. And you'll notice over here we're using something called a comparison operator. And basically this is just like how we want to compare them. So we're saying like greater than or equal to in this case. So down here, if this whole condition is true, in other words, if the results of these two comparisons end up being true, then we know that num one is the biggest. So I can just return num one, I can say return num one. But we also want to check some other conditions. So I can say L if, and now I want to do some other comparison. So I'm going to say else if num two is greater than or equal to num one. And num two is greater than or equal to num three. So I'm doing essentially what I did up here, except for num two. So again, I'm comparing these different numbers. And this is going to end up being a true or a false value, depending on the result of the comparison. So down here, again, we can just return num two, because if all of this is true, that means we're going to end up returning num two. And then finally, we can just say else. So if num one isn't the biggest and num two isn't the biggest, then we can pretty much assume that num three is the biggest. So now we have our function. So down here, I'm actually just going to call this function. So I'm just going to say, actually, I'll print out the result. So I'll say max num, and we'll pass in like three, four, five. So we're basically calling that new function that we just made. And I'm going to go ahead and run this program. So you can see down here in the output, we print it out five, because that was the biggest. If I was to change this middle one to the biggest, so we make the middle 140, now it'll be able to take on that situation. And finally, I can make this like 300. And it'll be able to handle that. So no matter which number num one num two or num three ends up being the biggest, it's able to tell us without a problem. So these comparisons are a really, really, really common way to make if statements. And a lot of times, you're going to want to be comparing different values inside of Python. So over here, we're comparing numbers, but we could also compare strings. So I could easily make these both like, you know, I could make this like dog, and I can make this dog. And I could say a different operator. So I could say like this double equal sign would mean equal. So I could basically say like, if this string is equal to that string, so you can basically like compare all different data types, you know, I could compare numbers, strings, you could also compare bullions. So once again, these are comparison operators. And this one is greater than or equal to, but there's a bunch of other comparison operators we can use. So the most basic is just going to be a double equal sign. And that basically checks to see if the two values are equal. So it'll say like, if number one is equal to number two, we can also say not equals. And this and this exclamation point will basically mean not equal. So it's if num one is not equal to num two, we also have greater than less than greater than or equal to less than or equal to. And those are kind of all of the operators are all the, you know, the basic comparison operators that you're going to be using in Python. So using comparisons is really awesome. And there's going to be tons and tons of situations inside of Python where you're going to want to compare different values. So these can be extremely useful. In this tutorial, I'm going to talk to you guys about building a calculator in Python. Now, if you've been following along with this course, you'll know that in the beginning of the course, we actually created a very basic calculator. Basically, the user could just enter in two numbers and our calculator would add the numbers together and spit out the answer. In this tutorial, I want to show you guys how to build a more advanced calculator. So this calculator is going to be able to perform all of the basic arithmetic operations. So we can add, subtract, multiply and divide. And we'll actually allow the user to specify which one of those they want to do. So the user will enter in a number, they'll enter in whatever operator they want to use. So plus minus divide, multiply. And then they'll enter in the second number and we'll perform the operation for them. So this can be pretty cool. And it's going to show you how we can use if statements in like a practical application. So let's get started. The first thing we want to do is get input from the user. So I'm going to create three variables, one for the first number, one for the second number, and one for the operator. And we'll basically store the values that the user inputs into those variables. So the first one will just be num one. And I'm going to set this equal to input. And we're going to give this a prompt. So I'll say enter first number. And here's actually the thing is whatever the user enters, we're going to want to convert it into a number. So generally in Python, when we get input from the user, no matter what they put in, it just gets converted into a string. But we don't want a string, because we're going to have to be adding or subtracting or multiplying these numbers together. So whenever they enter in the number, I just want to immediately convert it to an actual like number data type instead of a string. So what I can do is I can actually say float, and I can surround this entire input tag with parentheses. And now what this is going to do is it's going to immediately convert whatever the user inputs into a float. Now that's going to mean that they're going to have to insert a number, otherwise we'll get an error. But for the most part, this should work out for us. So I'm actually just going to copy this guy. And we'll go ahead and paste it over here. And we'll paste it one more time. So we're basically just trying to get three pieces of input from the user. So the second thing we want to get is the operator. So I'm just going to say op for operator. And I'll actually get rid of this float, because we want to keep this as a string. And I'll just say enter operator. So that's going to be like plus minus multiplication, whatever. And then finally down here, we'll get num two. And again, we're going to want to convert this to a float. So I'll say enter second number. So now basically what we're doing is we're getting the first number, we're getting the operator and we're getting the second number from the user. So what we need to do now is we need to figure out what is inside of this op. In other words, we need to figure out what operator the user was trying to do. So are they trying to do addition or they trying to do subtraction like we want to figure that out. So we can use an if statement in order to figure that out. So I'm going to come down here and I'm basically just going to create an if statement. So I'm going to say if, and we want to check a condition. So I'm basically going to check to see if this operator is equal to a plus sign. So I can say if op equals plus sign. And now if the operator is equal to plus sign, I'm just going to print out num one plus num two. But let's say that instead of a plus sign they entered in something else. So we can say out if op is equal to, and now we'll check if it's a minus sign. And so here we'll just print num one minus num two. And actually forgot to put a colon here. So we can just do these for everything. So now we can say L if op is equal to division and here we'll just divide the two numbers so I can print out num one divided by num two. And finally, we'll do the same thing for multiplication. So I'll say l if op is equal to asterisk. And we'll just print out num one times num two. Alright, so basically over here we have every, you know, condition. But I also want to put in an else statement. So in the case that the user enters in an operation, that's not like one of the four that we specified up here, I just want to throw an error. So I'm just going to say op or actually we just say else. And here we'll just print out like invalid operator. Alright, so this if statement should give us everything we want. Basically, I'm just checking to see if it's equal to a plus sign a minus sign a division sign or a multiplication sign. Depending on which one it's equal to, we'll do a different operation. So let's go ahead and run this program and see how we do. So I'm going to run this program and it says enter first number. Let's enter five, enter an operator. So why don't we just do addition and enter a second number. Let's do 23. So now it prints out the answer 28. So a calculator actually works. Let's try another operator just to make sure. So we'll do six and why don't we multiply it by, I don't know, 5.23. So now we go off and we do the multiplication and looks like we got our answer. So our calculator seems to be working. And so basically all we did was we got the input from the user and then we used if statements to figure out what they wanted to do. So we can check to see if they wanted addition. We can check to see if they wanted subtraction or division or multiplication. And we can also check to see if they entered in an invalid operator. So actually why don't we try that too. So I'll enter in like five and now we'll just enter in like an open and close parentheses and a four. So you can see here it's able to tell like the program's smart enough to know that that's not a valid operator. So these if statements can be really powerful and we can use them in combination with getting the user input to create a little calculator. In this tutorial I want to talk to you guys about using dictionaries in Python. Now a dictionary is a special structure in Python which allows us to store information in what are called key value pairs. So essentially I can just create a bunch of these different key value pairs and then when I want to access a specific piece of information inside of the dictionary I can just refer to it by its key. So the word dictionary is actually pretty appropriate here. If you guys are familiar with a normal dictionary you know in a normal dictionary you'd have a word and then you'd have a definition associated to that word. So in this situation the word would be the key. In other words the word is what like uniquely identifies it inside of the dictionary and then the value would be the actual definition. So this is going to make more sense once we start working with this but I just wanted to give you guys a quick introduction. So in this tutorial I want to create a little program that will allow us to convert a three digit month name into the full month name. So I could convert for example like JAN to January or I could convert M A R into March. Like I want to be able to have a program that can do that for us and that's actually a pretty good use case for a dictionary. So we're actually going to create a dictionary and I'm going to show you guys how we can do that. So the first thing we need to do in creating a dictionary is just give it a name. So I want to give this a specific name. So I'm just going to call this month conversions. And now I just want to set this equal to an open and closed curly bracket. So whenever we create a dictionary in Python we're always going to want to create it inside of these open and closed curly brackets. So inside of the dictionary now we can start defining what are called key value pairs. So I can define a key and then I can give it a corresponding value. And the way that we can do that is just by typing out the key and then typing out the value. So in our case we're converting three digit month names into the full month names. So I would want to type out for example JAN and then I can type a colon and I want to type out the value I want to associate with it so we could say January. I can basically do this for every combination. So I could say like FEB and this would be February. And actually after each one of these we're going to need to put a comma. So I could do the same for March, say M.A.R. So essentially what I can do is I can specify an entry inside of this dictionary for each one of these. So this over here would be the key and this over here would be the value. And here's one thing is all of these keys have to be unique. So if I was to come down here and change this to JAN, this is actually going to give us a little warning. So you can see down here it says dictionary contains duplicate keys. That's a no no when we're creating dictionaries. So you always want to make sure that the keys are unique. All right. So I'm going to go ahead and create one of these for each one of the months and then we'll come back and we'll talk about it. All right. So I've gone ahead and created an entry for all 12 of the months. So now we have a bunch of unique keys and each one of those keys is associated with a different value. So this is the basics of creating a dictionary is we have a bunch of these different key value pairs. And now what we can actually do is we can access them from inside of this dictionary. So if I wanted to access a specific key or a specific value, all I have to do is come over here and I'm actually just going to print it out onto the screen so we can see it. All I have to do is refer to the dictionary by name. So it's just called month conversions. And there's actually a bunch of different ways that I can access these month names. So I could access different entries inside of this dictionary. The first way is just by making a open and close square bracket and inside here, I can just type in one of the keys. So for example, inside here, I could type in NOV. And what this should do is it should give us back the full name for November. So when I print this out, you'll see that we get back down here November. So I could do the same thing for, you know, any of these, we could say like M A R. And now we should get March back. So I'm able to refer to the key. And it's going to go into the dictionary and it's going to give me the value that's associated to that key. There's actually another way we could do this too. So I could say month conversions dot get an inside of here. I could also pass in the name of a key. So I could pass in like D E C. And now we'll be printing out December. And what's cool about using this get function is I can actually specify a default value that I want to use if this key is not found. So there's going to be certain cases when we're dealing with dictionaries where you're going to put in a key that might not necessarily map to a value inside of the dictionary. So you put in an invalid key. So let's just try to do that. So I'll just put like L U V. That's not a month abbreviation. So when I try to run this, you'll see we get this none down here. And in a lot of cases, you're going to want to create some sort of a default value. So if I'm in this situation where I have a key that's not mapable to any values inside of this dictionary, I can actually pass it a default value. So inside this dot get function, I can make a comma. And now I can pass in like a default value to get printed out. So I can say like not a valid key. And now when I put in the invalid key, instead of saying none, it's going to go ahead and say not a valid key. So this is going to give us like a default value that we can fall back on. So these dictionaries are really awesome. And the keys over here don't have to be string. So you could also use numbers. So for example, I could say like zero, one, 10, like I can put any numbers I want over here as keys as long as they're unique. And then I could access those keys, just like I normally would down here with this get function or with those open and close square brackets. So that's sort of the basics of using dictionaries. It can be really useful to store key value pairs. And honestly, you're going to be using them a lot in Python to store different types of data. In this tutorial, I want to talk to you guys about while loops in Python. Now a while loop is basically a structure in Python, which allows us to loop through and execute a block of code multiple times. So I can specify like a few different lines of code, and then I can put that code inside of a while loop. And it would basically loop through that code, executing it repeatedly until a certain condition was false. So while loops can be awesome. And there's a lot of situations in Python where we're going to want to loop through specific lines of code. So in this tutorial, I just want to show you guys the like bare basics of how while loops work. And then in future tutorials, we're going to use while loops to create little games and stuff like that. So let's talk about while loops. When I create my while loop, the first thing I want to do actually is create an integer. I'm basically creating a variable that's a number and you don't have to do this for a while loop, but just for our demonstration I'm going to. So I'm just going to call this I and I'm going to set it equal to one. And now what I want to do is I want to create a while loop. So I'm basically just going to say while. And over here I want to specify a condition. And this is what's called our loop condition or you can also refer to it as a loop guard. And basically we are going to keep looping through the code inside of the while loop as long as this condition is true. So whatever condition I put in here, as long as it's true, we're going to keep looping through the code inside the while loop. So I'm just going to say while I is less than or equal to 10. And now I'm going to put a colon and I'm going to make a new line. And so anything that's below this while loop declaration and that's indented like this is going to be considered code that's inside the while loop. And so that code is going to get repeatedly executed while this condition up here is true. So I'm just going to put a very simple line of code here. We're just going to print out the value of I. And then down here I'm going to actually increment I so I'm going to add one to I'm going to say I is equal to I plus one. So basically I'm taking this I value and I'm adding one to it. There's actually a shorthand that we can use in Python to do something like this though I could just say I plus equals one and that's automatically going to add one to I. So this is like a little shorthand and you'll see people in Python using that a lot. So over here we basically have our while loop. So I have the outline for a while loop. So we're defining this variable up here and we're going to keep looping through the code inside the while loop as long as this condition up here is true. So if this condition is false for example if I is equal to eleven then we're not going to loop through this code anymore and we're just going to move on. So down here I'm actually just going to print. Done with loop. So this will kind of illustrate this for us. Alright so let's go ahead and run this program. I'm just going to run it. And you'll see down here we get some output. So we're actually going to get numbers printed out one all the way down through ten and then we're printing out done with loop. So basically what's happening is we're printing out every time we go through this loop. So initially I is equal to one right. The first thing that Python is going to do when it gets to this while loop is it's going to check this condition. So before it does anything else it's going to check this condition and it's going to say okay is one less than or equal to ten and that's true. So as long as this guy is true we're going to go through and loop through all the code inside of here. So we're going to print out i which has the value of one and then we're going to add one to i. So now i is going to go from one to two. Now what we're going to do is we're going to go all the way back up here to this while loop declaration and we're going to check the condition again. So remember I checked the condition the first time and then I loop through all the code then I go back up to the top and I check it again. So I'm going to say okay is i less than or equal to ten. At this point i is equal to two. So i is less than or equal to ten. So now we're going to go through and we'll execute all this code again. So I'm going to print out i so it's going to be two and I'm going to add one to i so now we have three. Then Python is going to go all the way back up to the top and it's going to check the condition again. So on every iteration through the loop before Python does what's inside of this loop it's going to check that condition. And as long as the condition remains true we're going to keep executing the code inside the loop. Eventually though in this program i is going to end up being eleven. So on the last iteration it's going to end up being eleven. We're going to come back up here and we're going to say hmm is eleven less than or equal to ten? Nope. And so since it's nope we're going to come down here and we'll print out this done with loop line. So that's the basics of how these while loops work. We're specifying a loop condition as long as that condition is true we'll keep executing the code inside of the loop. And after every execution of the loop we're going to come back up and check the condition again. So that's how we end up with this printing out down here. So that's the basics of a while loop. And we can use these while loops to do all sorts of things. Like while loops are very very powerful. In this tutorial I'm going to show you guys how to build a basic guessing game in Python. And in this guessing game we're actually going to be using all sorts of cool programming structures that we've learned up to this point in the course. So we're going to be using things like if statements and while loops and variables and all these cool things in order to build this game. So the basic idea is we will specify like a secret word. So we'll have a secret word that we store inside of our program. And then the user can interact with the program and try to guess the secret word. And so what we want to be able to happen is we want the user to be able to keep guessing what the secret word is and keep typing in different responses until they get the secret word right. So that's the basics of what this game is going to be. And now let's go ahead and create it. So the first thing we want to do is create a variable to store our secret word. So I could say secret word and we're just going to set this equal to a secret word. So why don't we make it draft. That's a pretty good secret word. And now what we want to do is we want to create a variable that will store the user's response. So I want a variable that will store like all the guesses that the user makes. So I'm just going to call this guess. And I'm just going to set it equal to an empty string right now. So now we have the secret word and we have a variable to store the user's guess. And what we need to do is we need to be able to prompt the user to input the secret word. But here's the catch. What we want to happen is we want them to enter the secret word. And if they don't guess it correctly, we want to prompt them to enter it again. So we can't just use a single input statement. We actually have to use something called a while loop. And we can use a while loop in order to continually ask the person to guess the word until they guess it correctly. So let's go ahead and create our while loop. So I'm going to say while. And after I say while, I need to specify a looping condition or a looping guard. Basically, this is something that as long as it's true, we're going to keep looping through this loop. So basically, I want to say I want to keep looping as long as the user's guess is not equal to the secret word. So as long as they haven't guessed the secret word, I'm going to keep going through this loop. And inside of this loop, what we're going to do is we're going to ask them to input the secret word. So I can take this guess variable and I can set it equal to input. And I'm just going to say enter guess. And so over here, we're basically telling the user to enter in their guess. I'm storing whatever they enter inside of this guess variable. And then what's going to happen is we're going to come back up here. We're going to check to see if the guess is equal to the secret word. If the guess isn't equal to the secret word, then we're going to do it again. But if the guess is equal to the secret word, then we're just going to break out of this loop. And so we can come down here. And we can just print out a success message. So I could say you win because they got the secret word. So this is a very, very simple program. But this is essentially all of the code that we need to be able to build a game like this. So let's go ahead and play our game. We can run it and see how we did. So I'm going to click play. And down here, you can see it's prompting us to enter a guess. So I'm just going to type in some, you know, random text, we can type in whatever we want. And as long as we're not entering that secret word, it's going to keep prompting us to enter different information. But if I enter in the secret word, so if I enter in draft, now all of a sudden the program is going to terminate and it's going to say, Hey, you win, because we were able to guess the secret word. So that's like a really cool way for us to be able to do this. And we actually have a fully functional guessing game. But I think this guessing game could actually be improved quite a bit. A lot of times when we're making a guessing game, we want to set a limit. So in other words, I want to set a limit for the number of times that the user can try to guess the word. So let's say that the user has three tries, right, they have three guesses in order to guess the word. And if they can't guess the word after three tries, then they're going to lose the game. But if they can guess the word inside of three tries, then they'll win the game, right? I think that would be a little bit more of a fun game. So why don't we try to program that game? Basically, we're going to set a limit on the number of guesses that the user can have. In order to do this, we're going to have to create a couple more variables down here. In other words, we're going to have to store a couple more pieces of information. The first piece of information I want to keep track of is how many times the user has guessed, right? So we can just make a variable called guess count. And we'll just set this equal to zero because initially, the user won't have guessed down in this while loop. Every time we go through the loop, I want to increment that guess count, right? So every time we've gone through this while loop, I want to increment that count because that means the user will have guessed. So down here, I'm going to say guess count plus equals one. And this is just going to add one to the guess count, actually whoops. Alright, so after each iteration of this loop, we're going to go ahead and add one to the guess count. Alright, so that's the first variable that we're going to need. We're also going to want to store another variable. And this is going to be called guess limit. And basically, this is going to tell us how many times the user can guess the word. So I'm going to it's going to be guess limit. And we'll basically just say three. So let's say that the user has three tries to guess the word three strikes and you're out. So the user, if they can't get it in three tries, then we're going to basically say that they lose the game. And I'm also going to need one more variable here, which we're going to call out of guesses. And I'm just going to set this equal to false initially. So this out of guesses variable is going to be a Boolean. And it's going to tell us whether or not the user is out of guesses. So if out of guesses is true, that means they have no more guesses, right? They basically lost the game. And if out of guesses is false, that means that they still have some guesses left so they can keep playing. All right, so let's use these different variables in order to make our program more functional. So the first thing I want to do is when I go through this loop, I want to check to make sure that the user has more guesses, right? In other words, before I let the user enter a guess, I want to check to see that they haven't already used up all their guesses. So down here, I can make an if statement. I can say if and inside of the condition, I want to check to see that guess count is less than guess limit. If guess count is less than guess limit, that means that they haven't guessed the total number of guesses that they have. So they have some guesses left. And if that's the case and if that's true, then I'm going to go ahead and give them a guess and then we'll increment the guess count. If this isn't true, in other words, if they have reached their guess limit, then I'm going to want to set out of guesses equal to true, because they're out of guesses, right? They have no more guesses because the guess count wasn't less than the guess limit. And so that means that they're out of guesses. So they have no more guesses. So there's actually one more thing we need to do inside of this while loop, we need to add another condition on to this loop guard. So right now, we're going to keep looping as long as the guess is not equal to the secret word. But remember, if the user's out of guesses, in other words, if they've reached their guess limit, we don't want them to guess anymore, right? So if they ran out of guesses, then we want to basically break out of this loop and not give them any more guesses. So I'm going to go ahead and add another condition onto here. And I'm going to say, while they haven't guessed the secret word, and they're not out of guesses. So it's going to be not out of guesses. Then we're going to keep looping. So as long as they haven't guess the word, and as long as they still have some guesses left, we're going to keep looping. But otherwise, we're going to break out of the loop. And so down here, we're printing out you win. But actually, when we break out of this loop, there's going to be two possible scenarios. So again, there's two possible ways that this loop could end, right? Either the guesses equal to the secret word. So either the user guessed the word correctly, or the user ran out of guesses. And so there's two situations down here that we need to account for. And so I'm going to use an if statement to figure out which is which. So I'm going to say if, and we're just going to type out of guesses. And if the user is out of guesses, then I want to print out of you lose. So we're basically going to be like, you lost the game. Otherwise, though, if they're not out of guesses, that means that they guess the word correctly. So we're just going to print out you win. Alright, so now we have all the logic for this little guessing game setup. And let's see if we can run it and play through it. So I'm just going to run this program. And now it's going to tell us to enter a guess. So why don't we enter more guesses than we have? So we're going to try to lose the game. So I'm just going to enter one guess, two guesses. And now I'm on my final guess. So if I don't get it here, we should actually lose the game. And you can see it says out of guesses, you lose. So we weren't able to guess it in the number of tries that we had. Let's run the program again, and we'll try to win the game. So we'll get a couple wrong. Let's say we're on our last guess. And I'm like, Okay, I can do this. So I type in the word and bam, we won the game. So that's how we can basically create a game where we have a guess limit. So this is a lot of code. Let me walk you guys through this one more time so you can just get a full understanding of what we're doing. Up here, I created a few different variables. We created this secret word variable, and we created this guess variable. And then we also created some more variables. So we created this guess count variable. And this just keeps track of how many times the user has guessed the word. And you can see down here, every time we give them a guess, we're incrementing the guess count. We also have guess limit. And guess limit is telling the program how many times the user can guess. So before I go through this while loop, the first thing I'm doing is I'm checking to see that the guess count is less than the guess limit. In other words, do they still have some guesses left? If they do, then we're going to get the input from the user. Otherwise, we have this other variable up here called out of guesses. And out of guesses is going to tell us whether or not they have some guesses left. So if this is equal to false, that means they have some guesses. If it's equal to true, however, it means no more dice, no more guesses, they are done. So they lost the game. The last thing we needed to do was specify an additional condition up here. So we are going to keep looping through the code inside of this loop, as long as the conditions up here are true. So as long as they haven't guessed the word, and as long as they're not out of guesses, we are going to keep looping through. And so when eventually the user does break out of this loop, there's going to be two possible situations. The first situation is that they ran out of guesses. And so we want to check to see if that's the situation. I want to check to see if they're out of guesses. If they are, we'll print out a lose message. If they're not, then they must have guessed it correctly. So they win. And so that is how we can use while loops and if statements and also variables in combination with each other to build a pretty awesome guessing game. In this tutorial, I want to talk to you guys about using for loops in Python. Now a for loop is a special type of loop in Python, which allows us to loop over different collections of items. So a lot of times we'll use for loops in Python to like loop through different arrays, or we can loop over like the letters inside of a string, or we could just loop through like a series of numbers. So for loops provide a very specific purpose. And the easiest way to kind of wrap your head around why for loops are useful is just for me to show you guys a bunch of different examples. So that's exactly what I'm going to do. We're going to look at why for loops are awesome. So down here in my text file and my Python file, I'm going to write out a couple of different for loops. So the way that we create a for loop is just by saying for. And now what I want to do is specify a variable. And this variable is going to essentially represent a different value every time we go through this for loop. And you guys will see how that works in a second. But just know that this variable is going to be used on every iteration of our for loop. And each time it will most likely have a different value. So in our case, I'm just going to call this letter. And I'm going to say for letter in. And now what I want to do is I want to specify a collection that I want to loop over. One example of this would be like a string. So I could put a string in here. I could just put like draft Academy. And now I can just put a colon. And so basically what this is going to say is it's going to say for every letter inside of draft Academy, I want to do something. And so down here inside of this for loop and again, we need to indent this. We can put what we want to do with each letter. So let me just show you guys like basically what this is going to do. So I can print out a letter so I can print out this letter variable. And it's actually going to print out a different letter inside of this draft Academy string on every single iteration of this loop. So I'm going to run this program. And down here inside of my console, you'll see that I'm basically printing out draft Academy. So on the first iteration of the loop, I printed out the first letter in draft Academy, which was G. On the second iteration of the loop, I printed out I said, third was R, fourth was A. So I'm essentially just looping through all of the letters inside of draft Academy. So I'm saying for each letter in draft Academy, I want to print out that letter. And so this is kind of like how four loops can be used. We can define a variable. And that variable will change on each iteration of the loop, right? So on the first iteration of the loop, this letter variable represented a G. On the second iteration of the loop, the letter variable stored at the value I, etc. Right. So we went through this entire string, and we were able to print out each letter. So in addition to using this with strings, we can also use this with other collections, for example, like an array. So if I created an array up here, let's just call it friends, I'm going to set this equal to a bunch of different values. So we can put like a list of our friends in here, we can say like Jim, Karen, and Kevin, instead of saying the letter, why don't we call this friend? And I can say for friend in friends. And now we'll print out the friend. So over here, I'm saying for each friend inside of this friends array, I want to print out the friend. So now we'll actually be able to print out each element inside of that array. So down here, you'll see we're printing out Jim, and then on the second iteration, we're printing out Karen, and on the third, we're printing out Kevin. So I'm able to loop through all of the values inside of the array. And just so you guys know, like, you can name this variable, whatever you want. So I could name, I could give this like any random name. And if I want to access it, though, I have to access it using that same name. So we can loop through something like an array, we could also just loop through a series of numbers. So I could say index over here. And again, this can be anything. I'm just going to call it index. So we could say for index in range, and then in here, I can pass in a number. So I could pass in like 10, for example. And down here, I'm just going to print out the index. When I run this program, you guys will see that it's basically going to print out every number in the range from zero to 10, not including 10. So starting with zero, it's going to print out zero, one, two, three, four, five, six, seven, eight, nine. But notice that it didn't print out 10. So it's essentially just printing out all the numbers between zero and 10, not including 10. You can also specify a range of numbers. So I could say, for example, like three and 10. And now this will print out all the numbers between three and 10, not including 10. So we're on this program. And you can see we print out three, four, five, six, seven, eight, nine, and not 10. So whatever value that you put here in this second position is not going to get included in the range. And ranges can be really useful. So for example, I could use a range to loop through an array, just like we did before. So if I wanted, I could say something like four index in range. And now inside of this range, I can pass in the length of the array. So just so you guys know, if I wanted to get the length of this array, in other words, if I wanted to figure out how many elements were inside of it, I could just type out LEN and then inside parentheses, the name of the array. And so this is going to spit out three, because there's three elements inside of here, right? Kind of makes sense. So what I can do is I can say down here inside of this range function, I can just type in LEN and then friends. And so what this is going to do is it's going to essentially give me a range between zero and the number of friends inside of this list. So down here, I could actually type out friends index. And this will allow me to access each individual friend inside of this list, just like we did before. But now I'm doing it with a range. So you can see I'm typing out Jim, Karen and Kevin. So actually, for each iteration through this loop, it's basically going to be printing out friends zero, friends one, and then friends two, because in here, we're passing in a three. And remember, whenever I pass in there, it's going to range from zero all the way up to that number, but not including that number. So that's another way that we could print out all the elements in the array. And looping through something like an array is actually a very, very common use case for for loops. But like I said, we can use for loops to loop through essentially any collection that we have. So we could loop through like a string, we could also loop through, you know, something like an array. So this can be really useful. And that's one of the basics of for loops in Python. And I also want to show you guys one more example, just while we're here. So why don't we go ahead and print out a range up to five, right? So this will just be a simple program. You can use all sorts of logic inside of these for loops. So let's say that I wanted to do something special on the first iteration of the loop. So I could say, if index is equal to zero. And if the index is zero, then we know it's the first iteration of the loop. So I could do something special, I could like print out first iteration. And then otherwise, we could just print like not first. So this would be an example of like, maybe you want to do something on the first iteration of the loop and do something else on subsequent iteration. So if I play this, you'll see only on the first iteration is it printing this out. And otherwise, it's printing out other stuff. So, you know, don't be afraid to put some complex logic inside of these for loops, because it can really make your program is more powerful. In this tutorial, I'm going to show you guys how to build an exponent function. Now an exponent function is basically going to allow us to take a certain number and raise it to a specific power. So in Python, there's actually a really easy way to do this. I can come down here and I can print, we can say like two, and we can just do two multiplication signs. And I can say three. And this is basically just going to be two raised to the third power. So you can see here, I can just print this out and we get eight, because that's too cute. So it's really easy to do exponents in Python. But I want to show you guys how we can use something like a for loop in order to create a function like this of our own. So we'll actually create an exponent function that will basically do this and we'll use for loops to do it. So let's create a function. So I'm just going to say def. And now we need to give this function a name. So why don't we call it raise to power. And inside of here, I'm going to accept two parameters. The first parameter is going to be the base number. And then the second parameter is going to be the power number. So we're going to take the base number and raise it to the power number. So over here, we can just make a colon. Now, inside of this function, we need to start writing some code. Here's the thing. Inside the function, we don't necessarily know the value of this pound. Right. For example, if we knew that we were just trying to like square this number or cube this number, I could just return like base num times base num, right? That would square the number or I could cube the number base num. So right. So this would be like the number cubed. The problem is though, we don't know like right off the bat what this value is going to be. Right. This could change like the user can decide that. So in order to write this function, we're actually going to need to use a for loop. And I'm going to show you guys how we can use a for loop to basically figure this out. So the first thing I want to do is create a variable. And I'm just going to call it result. And we're just going to set result equal to one. So we're going to start this off at one. Now I want to create a for loop. So I'm basically just going to say four. And over here, I basically want to specify like a index. So I'm going to say index in, and now I want to specify a range and a range will basically range us through a collection of numbers. So basically, I want to multiply the base num by itself as many times as the power num specifies. Right. So over here, I can just make this a range of power num. Right. And so we'll basically loop through this for loop as many times as pound them. So if pound them is two, we'll loop through it twice. If pound them is four, we'll loop through it four times. And every time through the loop will multiply base num by itself. Or actually, you'll see we're going to multiply it by this result. So down here inside of this for loop, I can basically say result is equal to result times base num. This should actually give us everything we need to take this number to the specific power. So the actual like result, you know, of doing the math is going to get stored inside of this result variable. So the first time through the loop, we're just multiplying base num by one. Right. And so now result is going to become the same value as base num. The second time through the loop. So this would be if we were squaring the number, we're basically multiplying result by base num again. So it's essentially just base num times base num. The third time through the loop, we're multiplying result times base num. So we're essentially just like cubing the number. So that's essentially what this for loop is doing for us. So the last thing I want to do is right here below this for loop, I'm just going to return the result. So we'll be able to return whatever the result of raising the number to the power was. All right. So let's come down after this function. And we're just going to call it. So I'm just going to say, actually, we'll print out the answer. So I'm going to say raise to power. And inside of these parentheses, remember, we can pass two numbers. So let's raise three to the second power. So we're just going to square three. And we'll see how this works. So throw on the program. And you can see down here in the console we're getting nine. Let's try something a little bit crazier. Let's try three to the fourth power. And we'll run this and get 81. So that's three to the fourth power. Let's try two to the third power. And we're getting eight. Yeah, so that makes sense. So our raise the power function is working just as expected. And I'll just walk you guys through it one more time. So inside of this function, we're taking in two pieces of input, we're taking in a base number, and we're taking in a power number. So that's like, the base number is going to be taken to the power number. I'm defining a variable here called result. And result is where we're going to store the actual result of doing the math. Now we specify this for loop. And I'm basically saying that I want to loop through this range of numbers. When I put pound on here, it's basically going to range from zero all the way up to but not including the power number. So we'll basically loop through power number of times, if that makes sense. And then every time through the loop, we're just multiplying result by base num. And then we're just returning results. So that's the basics of building a power function. And obviously, like if you're just trying to take a number to a power and Python, it's really easy. But this kind of shows you like the internal workings, right? For a function like that to work, we would have to actually type something out just like this. And this tutorial, I want to talk to you guys about two different concepts in Python. It's going to be a pretty cool lesson. First thing I want to show you guys though, are two dimensional lists. So down here in our Python file, I just want to create a basic list. So I'm just going to call this number grid. And I'm just going to set this equal to a normal list right just like this. Now normally if we were creating a list, I could just put in a bunch of attributes and bunch of elements, right? And now all of these elements are inside of this number grid list. Everybody's happy. But another thing I can do is I can make all of the elements inside of this number grid list lists. So the first item in the number grid list is going to be a list. The second item in the number grid list is going to be a list, etc. So I'm going to show you guys how to do that. I can basically just come down here and where I would normally put the first element in the list, I can just create another array. So I'm just going to make an open and closed square bracket. And now I'm just going to say 123. And I can create the next item in my list. I can say 456. And let's make another item in this list. I can say 789. And finally, we're going to put one more list inside of the number grid list. And it's just going to have zero in it. So inside of this number grid list, right, this high level overall list, we have four elements. And all of those elements are themselves lists. So essentially what we're doing is we're creating a grid, right? This grid has 1234 rows, and 123 columns, right, four rows, three columns. And that's kind of like why these can be useful is we can create a grid like structure inside of Python using two dimensional lists. So this is a pretty cool list structure. And I want to show you guys how we can access individual elements inside of this list structure. So, for example, let's say I wanted to print out one of these values. Let's say I wanted to print out this one right here. The way I can access it is by saying number grid. And the first thing I want to do is make an open and close square brackets. And in here, I want to put the index of the row that I want to access. So this would be like row zero, because that's the zero element in the array. This would be row one. It's at index position one. This would be row two, row three, etc. So I could put row zero. And now right next to this, I'm going to make another square bracket. And I want to put the index of the column. So this would be like column one, column two, column three. So I'm going to put another zero, because this is at the zero index of this first array. So I just put zero zero here. Now we can print this guy out to the screen. And you'll see down here that we get that one. So I could also do this for like for this eight, for example. So this is going to be zero one two. It's going to be row two and column one. And now we should be able to print out that eight. So that's basically how we can access elements inside of this 2D list. The next thing I want to show you guys is a nested for loop. And a nested for loop is a situation, like I said, where we have a for loop inside of a for loop. And I'll show you how we can use this nested for loop in order to print out all the elements inside of this array. So I basically show you guys how to parse through a two dimensional list or a two dimensional array. Alright, so basically we're just going to create a normal for loop. So I'm going to say four, and I'm just going to say row in number grid. And I'm using the word row here because I'm kind of seeing these guys as rows, right? These are sort of horizontal rows in our little grid. So for each of those rows, for each of the elements inside of number grid, I want to loop through. So I could actually just print out each row right now. And it's just going to print out all the rows inside of this list. You can see down here, we basically just get exactly what we have up there. But I want to be able to access each of these individual attributes inside of each of these array elements. So we can actually create another for loop. And I'm going to put that for loop inside of here. So now I'm going to say for column in row. And basically what this is going to give us is each individual column or each individual element inside of these arrays. So for example, inside of the arrays that are the elements of the number grid. Hopefully that makes sense. So down here, now I can just print out column, and this should actually print out every single value inside of this two dimensional array. So let's go ahead and run this program. And down here, you'll see that we're basically printing out one all the way down to zero. So we're printing out all of the elements inside of all of the arrays inside of the number grid. So that's how we can use two dimensional lists and nested four loops together. And both of those things are actually pretty handy in Python. In this tutorial, I'm going to show you how to build a basic translator in Python. So essentially, we can take in a string so we can take in like a phrase or a word, and we'll be able to translate it into a different language. So over here, I have this little file, and it basically specifies this language that I made up. So I'm calling it the draft language. And in the draft language, all vowels become G. So if I was going to translate an English word into a draft word, for example, the word dog, I would look through the word dog in any instances where there was a vowel. So in our case, let's just say A E I O U, I would convert that vowel into a G. So dog would map to D G G, cat would get mapped into C G T. So those are the basic translation rules. Obviously, this is a pretty simple language, but you get the point any vowel is going to become a G, and then we'll get the draft language. So we're going to build a draft translator. Over here in our Python file, let's start making this translator. The first thing I'm going to do is just define a translate function. So I'm going to make a function here, and I'm just going to call it translate. And inside of these parentheses, we want this to take one piece of information, which is going to be the phrase that we want to translate. So I'm just going to say phrase. And now inside of this function, we need to figure out like, okay, how can we translate English into our draft language? Well, remember, the rules is basically just any vowels become G's. So the first thing I want to do is create a variable. And this variable is going to be the translation. So this will be like the final result that we're going to return to the user. So I can say translation. For now, I'm just going to set it equal to the empty string. So this is just going to be like a completely empty string. It's not going to be doing anything. And now what we want to do is we basically want to loop through every letter inside of this phrase. And if it's a vowel, we want to change it to G. And if it's not a vowel, we want to leave it alone. And we're essentially going to be looping through phrase. And we're going to be adding the letters onto this translation one by one. So let me show you guys how we can do this. I'm going to make a for loop. So I'm going to say four. And I'm just going to say letter in phrase. And so now, when I loop through here, I can access each individual letter inside of the phrase that they passed in. So what I want to do is I want to check to see if the letter is a vowel or not, right? If it's a vowel, then we can add a G onto translation. If it's not a vowel, then we can just add on whatever letter it was onto translation anyway. So I'm going to use this if statement. I'm going to say if. And there's actually this special thing we can do in Python, we can check to see if something is in something else. So I can say if letter in, and over here, I'm just going to type out all the vowels. So we'll say A E I O U and A E I O U. So I'm basically checking to see if the letter is inside of this string. And if the letter is inside of here, then we know that it's a vowel. So down here, we can handle that case. So I can say, translation is equal to translation plus G. Because if this letter is a vowel, we just want to convert it into a G. Otherwise, though, I can basically just say, translation is equal to translation plus letter. So in the case where we have a vowel, I'm adding a G onto translation. In the case where we don't have a vowel, I'm just adding on whatever letter it was onto translation. So finally, down below this for loop, we just want to return the translation. So I'm just going to say return translation. And now we have a awesome translate function, and it should probably work. So let's come down here and we'll test it out. So why don't we allow a user to input some information. So I'm basically going to call this function. Actually, we're going to print it out. So we'll print this out. And I'm going to call this function translate. And inside of here, I'm actually just going to pass whatever the user inputs. So I can just say input. And inside of these parentheses, I can say the prompt. So enter a phrase. And so now I'm basically combining all these statements together. I'm saying I want to print out the translation of whatever the user enters in. So let's go ahead and run this program, and we'll see how we do. So I'm going to run the program. It says enter a phrase. Actually, let me format this a little bit better. Okay. All right. So it says enter a phrase. So let's go ahead and do that. So let's just type in the example we used before. I'm going to say dog. And so now out pops the answer, which is d g g. So that's kind of cool. And we can just keep running this as many times as we want. So I could type in like to be or not to be. So this is like a little bit longer of a string. And you can see it translates it into our draft language. So that's basically how we can create our little translator app. And that's pretty cool. And so you can see we're using a for loop in combination with an if loop. And that's a really powerful structure. And actually, there's one place over here where we can make this a little bit more efficient. So instead of saying if letter in this string, you'll notice here, I'm checking to see if it's in all the lower case and the uppercase. I could actually just say if letter dot lower in. And now I only have to type out the lower case letters. And it's still going to do the same exact thing. So that's a little like hack or whatever that we could use. And there's also one more problem with this program. So you'll notice down here, we're setting the translation equal to the translation plus g. But the problem is if I was to start my word inside of the phrase with a capital vowel. So in other words, if I said like on, you'll notice that when this gets printed out, it gets printed out as lowercase g and so it's not keeping our uppercase syntax. And that's kind of a problem. So we can actually use another if statement in here. And we can check to see if letter dot is upper. And if the letter is uppercase, then we can just set the translation equal to the translation plus a capital G. Otherwise, we can just set it equal to the lowercase g. And so now we're able to control both of those situations. So let's just test this and see if it works. Enter a phrase, say on. And now we're keeping that capital letter. So those are just a couple different ways that we could make this program a little bit better. But the basic concept is we have a for loop and then we have some if loops inside of it. And we're calling this awesome function that can translate a word for us. In this tutorial, I want to talk to you guys about comments in Python. This is going to be a pretty short tutorial. I just want to give you guys an overview of what comments are and how we can use them in our Python programs. So over here in my Python program, I just have this line here. It says print comments are fun. So if I run my program down here inside of the console, it's going to print out that comments are fun, right? So any code that I put over here is going to get executed by Python. But there's actually a special line of code that we can write and it's called a comment. And a comment is basically a line inside of our Python file that's just not going to get rendered by Python. So when Python sees it, it's just going to ignore it. It's not going to execute it. It's not going to print anything out. It's just going to kind of ignore it. And comments are going to be just used for us humans. So a comment is used for like me or another developer to write a little comment, a little like plain text, you know, comment inside of a file. In order to create a comment, I could use this hashtag symbol. So I can click hashtag and now I am writing a comment. So I can write whatever I wanted in here. I could say like this program is cool. And you'll notice when I put on the program, that doesn't show up anywhere, right? It doesn't matter what I put after this hashtag. This is just like ignored by Python. It's just for me or another developer to come in here and use. So a lot of times if you want to write like a little note inside of your Python files, or maybe you can write yourself a little reminder, or if you want to write a line to like explain a line of code. So for example, I could write a comment that would explain this print statement. So I could say like this prints out a string, right? Now anybody looking at my file would be able to read this and they'd be like, Oh, that's what this does. Okay, cool. So comments are useful for leaving little comments in a Python file. If you want to make comments on multiple lines, you can just create a new line and use another hashtag. And so then I could type out whatever my next comment was. And generally, if you're going to put comments on multiple lines, you want to just use multiple hashtags. But there's actually another way that you can write out comments. So you can use a triple quotation mark. So I'm typing out the single quote. And I'm typing it out three times. So you can see here up here, we have this three times, we have this three times. So in here, I can, you know, write any comment that I wanted. So I could put, you know, as much text up here as I would want. And same thing, when I run this program, it's just not going to get rendered. So this is another way to make multiple line comments. But the, like, official Python, like style guides or whatever, just recommends that if you're going to put comments on multiple lines, you use these hashtags. So, you know, you can really do whatever you want. But if you want to be like super Python official, then use these hashtags. Comments can also be useful for doing something called commenting out a line of code. A lot of times when you're writing a program, you might have a line of code in there that is maybe like potentially messing stuff up. And so what you can do is you can actually comment out that line of code. So I could put a comment in front of this line of code. And now when I run my program, the program is going to run, but it's not going to use this line. So sometimes if you're trying to see if like a line of code is causing you trouble or if you want to see what your program would be like without a line of code, or even like a block of code, you can just comment it out. And that way you're not actually deleting the code from your file. You're just commenting it out. So Python is going to ignore it. And those are really the two uses for comments is to write little notes, write little comments about different things or to comment out code. And as you go forward in Python, I'm sure you'll find uses for comments. In this tutorial, I want to talk to you guys about catching errors in Python. Now, a lot of times when we're running Python programs, you'll encounter different errors. So different situations could come up and your program might throw an error or it might throw an exception. And a lot of times when these situations happen, they'll completely stop your program from running. And what we can actually do is we can watch out for, you know, certain specific errors that are going to pop up in our program and we can actually handle them. So instead of our program just breaking and stop executing, we can actually handle those errors and do things when they occur. So I want to show you guys an example of using this down here. I'm saying number is equal to int input enter a number. Basically what's happening is I'm prompting the user to enter in a number using this input command. And then I'm converting whatever they entered into an integer. So as long as they enter in like a valid integer, I can convert it into an integer. So I can convert it into like a whole number and I can store it inside of this number variable that I'm just printing it out. So let's try to execute this program. I'm going to run the program and you'll see down here it says enter a number. So we can enter in like four, for example. And when I enter in four, everything's going to work and it's just going to print out four and everything is right in the world. And actually, I'm going to modify this up here. So it's a little easier to see. But let's say we run the program again. So it says, okay, enter your number. Let's say that I break the rules and I don't enter a number. So I just ignore what the prompt says and I put, you know, some random text in here. Now when I enter this, the program is going to throw an error. You can see down here, it says value error invalid literal for int base with base 10. Basically, hey, you didn't enter in an integer like you said you would, right? We told them to enter in a number. They entered in text. So it broke the program. And this is a situation that happens a lot. So there's a lot of different situations where something can just go wrong in our program. And I'm until now we've just kind of accepted it as a reality. But if you're writing a real live Python program, you don't want something like this to trip up your program. You don't want the entire program to break when somebody just forgets to enter in a number, right? You want to be able to handle all these different situations. And in order to handle them, we can use something called a try except block. And a try except block will basically allow your program to try out a piece of code. And if everything goes well, then we're great. Like we could try out entering in the number. And if the user enters in the correct number, great. But if they don't enter in the correct number, then we can basically like account for that. So they entered in something like a string when they're supposed to enter in a number, we could tell them like, Hey, you entered in the wrong thing. So I'm going to show you guys how we can use these try except blocks. I'm going to come up here, and I'm just going to say try. I'm going to make it colon. And I want to indent both of these things. So both of these things are going to be inside of this try block. Now I'm going to make a new line. I'm going to come down here and I'm just going to type out. Except, and I'm also going to put a colon here. And down here, I'm just going to print something out. So I'll just say like invalid input. So now, since I put this code inside of this try block, if the user enters in something wrong, it's going to be able to catch it. So it'll be able to catch what the user does wrong and print out invalid input onto the screen. So let's go ahead and run our program. And it's just going to say enter a number. So we're going to ignore that. We'll enter this in. And now instead of yelling at us and breaking the program, it just says, Hey, invalid input. So it was able to handle the error they got called. It was able to handle the invalid input error. Basically just told us, Hey, no more input. So this is a really powerful thing that we can do in our Python programs. Basically just to protect our programs, right? If I want to have my program running for long period of time, I can't have something as simple as an invalid input, trip it up. So I can catch that invalid input using these try accept blocks. But here's the thing. You'll notice that this little guy down here is getting highlighted. And let's just see what it has to say. So it's basically saying to broad exception clause. And this is a message that we're getting because when I just say accept, this will catch any error under the sun. So anything that can go wrong on my program for the most part, this is going to accept it. So let me give you guys an example. Let's say I had in my program, I was creating a variable, right? So I wanted to create a variable called value. And I set it equal to 10 divided by zero. Now, if you know anything about math, you'll know that you can't divide a number by zero. It's not possible. So the program isn't going to be able to handle this. And you'll see that this is going to throw an error for us. So when I run the program, it basically says zero division error division by zero. We're not allowed to do that, right? If I took this and I put this down inside of this dry block, and I just pasted it in here, it's going to get caught by this exception that we wrote down here. So it's going to get caught by that accept. So when I run the program, you'll see it says invalid input. But the problem is that we didn't input something that was invalid, right? We just divided by zero, but it wasn't able to handle that. Right. So it could not divide by zero it through an error. So even though we didn't get an invalid input, even though it was because we divided by zero, it's still printed this out. And this brings me up to another point is we can actually catch, or we can accept specific types of errors. So for example, in this case, we got a division by zero error. In this case, we got an invalid input error, right? We put something in that was wrong. You couldn't convert the value. So I can create two different accept blocks to catch two different types of errors. So down here, I can just make a space and I can specify the type of error that I want to catch. So when we divided by zero, it was zero division error. So if I just put zero division error in here, now it's going to catch that zero division error. So I can say divided by zero. I could also make another accept. So I could say accept. And we can catch the other exception that we got. So I think it was a value error, right? It was, we put in the type of value inside of that input. So now we can print out invalid input. So with these two accept blocks, we're basically able to handle both of these situations. So for example, if this ends up breaking the program, this division by zero, then it'll be able to catch that. So down here, it'll tell us, Hey, you divided by zero. But if I was to get rid of this line of code, and I just entered in the number wrong. So I came down here and I entered in a string instead of a number. Now it's going to tell us invalid input. So we're going to be able to specify what happens when certain things break. So when we get a valid, when we get a value error, we can say invalid input, when we get a zero division error, we can say divided by zero. So depending on what breaks, depending on what happens, we can actually do different things. And I want to show you guys one more thing we can do, which is we can actually store this error as a variable. So I can say accept, I can say as, and I can type in a name here. So a lot of times people will just say like, e r r. And down here, I can print out the actual error. So I can just print e r r. And so if we end up dividing by zero. So if I say answers equal to 10 divided by zero, we're going to throw this error, and it's going to print out what went wrong. So now I can run this program. And it just says division by zero. So it just printed out the error that we got. So that's another useful thing you can do is you can actually like print out the specific error that got thrown. Now, a best practice in Python is to use these specific errors. So you always want to accept and accept for a specific error. What you don't want to do is just say accept, and then just accept anything under the sun. It's just too broad. And it's not a good practice in Python. So you always want to be catching specific errors like this. In this tutorial, I want to talk to you guys about reading from external files in Python. Now a lot of times in Python, you're going to want to read from files that are outside of your Python file. So you might want to read information from like a text file or a CSV file or like an HTML file. And you can actually use something called the Python read command. And it will allow you to read a file that is stored outside of your Python file. So you can use these files to get information or you can parse through different files and do different things. So I'm going to show you guys the basics of reading files, opening files, closing files, doing all that stuff. Over here, I have this file called employees dot text. And it basically just lists out a bunch of different employees, like these could be employees in an office or whatever. So it's just listing out all of this information. So let's say that inside of my app dot Python file, I wanted to read the employees inside of that file. The first thing I have to do is actually open that file from inside of Python. So I can use a special command called open. So I can say open. And then in here, I can type in the name of the file that I want to open. So this is either going to be a relative path to the file, an absolute path to the file, or just the files name if both files are in the same directory. So in my case, app dot Python and employees dot text are in the same folder, like they're in the same directory. So I can just type out the name of the file. I can just say employees dot text. And then I want to put one more thing inside of this open function. And it's going to be the mode that I want to open the file in. So you can actually open files in a couple of different modes. And the first mode is called read. So I can just put an R here and that's going to stand for read. And this basically means that I only want to read the information inside the file. I don't want to modify it. I don't want to change it. I just want to read it. I just want to see what's in the file and do some stuff with that information. Another mode is called write. So I can type in this w and writing basically means that you can change the file, right? You can write new information. You can change existing information. There's another one called a and a stands for append. And this basically means that you can append information onto the end of the file. So you can't modify any of the information in the file. You can't change any of the information, but you can add new information. And there's one more, which is R plus. And this basically means read and write. So this will give you all the power of reading and writing. So in our case, we're just going to be working with regular R. So we're going to be reading from the file. Now this open function will essentially just open the file. So it's going to like go over to that file inside of our file system, open it up, and it'll allow us to read through it. But generally, we're going to want to store this opened file inside of a variable. So I can create a variable and we can just call it employee file. And I'm just going to set it equal to this open function. So now the open employees dot text file and all the content inside of it is stored inside of this employee file variable. Now, whenever you open a file, you always want to make sure that you close the file as well. So just like we have this open command, we also have an close function. So I can come down here and say employee file dot closed. And this is essentially just going to close the file. So we're no longer going to be able to access it. And generally, it's a good idea whenever you're opening up a file, you want to also make sure that you're closing the file at some point. So generally, once you're done reading it, you can just close it. So that's kind of like how we can open and close a file. Now, let's talk about how we can get information from the file, right? There's no point in having the file that we can't figure out what's in it. So there's actually a few different functions that we can use on this employee file to figure out what's inside of it. And I'm going to show you guys some of those. So I'm just going to make a print statement. And inside this print statement will basically just print out some information about the employee file. So the most basic thing we can print out is just the entire contents of the file. But before I do that, I want to show you guys how you can check to make sure that a file is readable. So before we do anything else, generally, it's a good idea to make sure that it's possible to read this file. And there's a function inside of Python, we can use called readable. So I'm just going to type out employee file dot readable. And this is going to return a Boolean value. And it's going to tell us whether or not we can read from this file. So I'm going to run my program. And you'll see down here, we get a value of true. And that's because we set the file with a read mode. So it's in read mode, we can read from it. If I was to put a double you here. So if I put like, right, now readable is going to be false, because we can no longer read the file, we can only write to the file. So I'm going to change this back to our so we can just read it. So once you figure out whether or not the file can be read from, let's actually read it. So there's another function called employee file dot read. And this is basically just going to spit out all the information in the files. So when I run the program, it's just going to spit out all of this information, right, all the information that was in that file. I can also come down here and we can read an individual line inside this file. So I can say employee file dot read line. And what this is going to do is it's going to read an individual line inside of this file. So now when I run this program, you'll see it's just reading that first line in the file. And this read line function is actually just reading the first line. And then it's basically like moving a little cursor onto the next line. So if I was to copy this code and then print it again down here, I'm saying employee file dot read line. So it's going to read the first line. And then when I say it again, it's going to read the line after that. So this is actually going to end up printing out the first two lines in the file. So when I run this program, you'll see we print out Jim salesman and Dwight salesman. So if I was to do this multiple times, like I could technically print out every line inside of this file. And you can see we can do that. And so that can be pretty useful for reading multiple lines in a file. But there's actually another function that is better at doing that. And we can say instead of employee file dot read line, we can say dot read lines. And what this is going to do is it's going to take all of the lines inside of our file and put them inside of an array. And so now when I print this out, you'll see we have this array down here. It says Jim salesman, that's the first item in the array, Dwight salesman, the second item in the array, it's basically taking each line and putting it inside of an array. So if I wanted to access a specific line, I can just refer to it by its index in the array. So if I said one, now this is going to give us that Dwight salesman line, because that is at index position one inside of the array. You can also use this read lines function with a for loop. So I can come up here and create a for loop. I'm just going to say for, and we'll say employee in employee file. And then for each employee, we just want to print them out. So and actually started, we have to put employee file dot read lines up here. And so now this will loop through all of the employees in this employee file that read lines array. So we can actually just print out the individual employee. And now this will print out all the employees inside of that file. So it's basically printing out each line in the file. And that can be pretty useful. So you can use all of these different functions like read, read line, read lines, readable, you know, there's a bunch of these different things that we can do to get information from a file. And so there's a lot of cases where you're going to want to be able to parse through information in a file. And this is a awesome way to do it. So just to recap, whenever you want to open a file and read from it, you can just use this open function, type in the name of the file and then the mode, which in our case is going to be our, then you can do all sorts of stuff with it. And you always want to make sure that you close it when you're done. That's just good practice. So that's the basics of reading from files. And hopefully you guys can use this in some way, shape or form in the future. In this tutorial, I want to talk to you about writing and appending to files in Python. So one of the cool things about Python is it allows you to work with external files. So I could have like an external text file and I could actually like completely read all of the information in it. I could parse through it, use that information to do certain things. But in addition to reading a file, I could also write a file. And that's what I want to talk to you guys about today is writing new files and appending onto existing files. Over here, I basically just have some written out and this essentially just reads information from this employees.text file. So you can see over here, I'm specifying the mode, which is R and that stands for read. And then down here, I'm just reading all of the contents of the file and spitting it out on the screen. So I'm going to click the play button over here and you'll see that this executes. So it's printing out all of the lines of code in our text file. So over here, I'm in this employees.text file and it just has all this information, like employees in an office. But let's say that I wanted to add another employee onto here, right? Let's say that a new employee joined our company. So we wanted to add them onto this list. Well, I can come over here to my app.python file. And instead of reading from the file, I want to append to the file. So I want to say a and appending to the file basically means that you're adding some text at the end of the file. So wherever the file ends, you're just going to add some text onto there. So what we can do is we can actually add another employee into the file. So instead of printing something out, I'm actually just going to say employee file dot right. And when I say employee file dot right, I'm going to be able to write something to the end of the file. So I can basically just write whatever I want. So why don't we add in another employee into our employees dot text file. So we can add in another employee. Why don't we say like Toby, and he's going to be in human resources. So now, when I run this program, it's going to add Toby human resources onto the end of the file. So I'm going to run my program. And you'll see that nothing shows up down here in the console. But if I go over to my employees dot text file, all of a sudden we have a new entry over here, it's Toby from human resources, right? So I was able to append a line onto the end of this file. But here's the thing, you need to be careful when you're writing to files, because you can actually mess up a file very easily. For example, I already added Toby here into my file. But if I was to run this program again, you'll see that over here in this employees dot text file, it went ahead and added Toby again, right? So it added this employee here again. And also, you'll notice that in this case, this employee didn't go on to the next line. I accidentally ran my file again, and all of a sudden it messed up this file over here. And so appending, you really need to be careful because if you actually run your file again, or if you, you know, append something on something wrong to the file, it's permanent, like it's getting saved inside of the file. So I want to talk to you guys a little bit more about, you know, appending. Another thing we could do, let's say we wanted to add another employee. And you'll notice over here in this employees dot text file. When I appended it on again, it got appended to the end of the existing line, right? So the first time I had a new line there, but if you don't have a new line at the end of your file, and you all and you want to add a new line, you're going to have to add some special characters. So let's add another employee, and we'll call her Kelly, and let's just say Kelly is in customer service. So Kelly is going to be in customer service. And if I want to add this employee onto the end of the file in a new line, I'm going to have to put a new line character in front of it. So I can say backslash n, and this will append this entry into the file with a new line. So on a new line. So now when I run this, you'll see we get Kelly from customer service on her own line. So you want to make sure that you're aware of like these special characters that you can use, they call them escape characters. And you know, anytime you're adding onto a file, you want to make sure that you're adding on exactly where you want to add on. So in addition to appending to a file, I could also just like overwrite a file or I could write an entirely new file. So since we already have this open, instead of appending to the file, why don't we just write a file? So I'm going to use this W. And now if I say employee file dot right, because I'm using W and I'm not using a, it's actually going to override the entire file. And it's only going to put this inside the file. So when I run this, and we go over to this employees dot text file, you'll see we only have one line inside of this file. Now it's just Kelly customer service. That's because I was using W not a when you use W, it's just overriding everything that's in that existing file. You can also use W to create a new file. So over here, I could say employee file is equal to employees one dot text. And now what's going to happen is when I run this, it's going to create another file for me. So I'm going to run this. And you'll see over here in my file browser, we have this new file employees one dot text. So if I open this up, it has exactly the same stuff as in this employees file. But it basically created a new file for us. And so a lot of times you're going to want to create a new file. And you can use different extensions too. So if I wanted to create like a web page, I could say index dot HTML. And I could also add in some HTML code in here. So if you don't understand HTML, don't worry about it. But if you do, I could put like a paragraph in here, another paragraph, like this is HTML, basically HTML is like a web page. And the point I'm trying to make is that you could write out a web page inside of Python by doing something like this. So now when I play this, we get this index dot HTML file. And it has some HTML inside of it. So that's one way that writing to files can be really useful. You can overwrite an existing file, you can write a new file and create it, or you can append onto the end of a file. And there's tons of applications for writing to files and Python's a great language for working with reading, writing, and doing all that stuff with files. In this tutorial, I want to talk to you guys about using modules in Python. Now, a module is essentially just a Python file that we can import into our current Python file. So for example, if I wrote a Python file that had a bunch of like useful functions or useful variables or, you know, other things like that, I could take that file, I could import it into the file I'm currently working on, and I could actually access all of those functions, all of those variables, all the stuff from that external file inside the file that I'm currently working on. So I'm going to show you guys how we can use modules, and then we'll talk about like, you know, where you can find awesome modules and really why modules make Python an awesome language. So over here in my text editor, I actually created this file and it's called useful tools dot Python. And basically this file just has a bunch of sort of like useful tools that I might want to use in one of my programs. So you'll see over here, I have some variables. This one is telling me how many feet are in a mile. This one's telling me how many meters are in a kilometer. And then we have this list here, which lists out all of the members of the Beatles. I also have a couple different functions down here. So I have this get file extension function. And this basically just will, you know, you give it a file name, it'll tell you what the extension is. And then we have this other function down here, which simulates rolling a dice. So you pass it a number. If I pass it like a six, it would roll a six sided dice. If I pass it a nine, it roll a nine sided dice, etc. So this is like a Python file that I wrote. And it has some useful stuff in it. And honestly, there's a lot of stuff in here that I might want to use in the other Python files that I work with. So let's say I'm over here at this app dot Python file. And I'm thinking to myself, huh, I think I could use one of those functions that was inside of that useful tools file. Actually, yeah, I need to simulate rolling a dice in my program. Well, instead of having to go over here, copy this function and then paste it over here into my program, I can actually just import this useful tools file. And I'll be able to import all of these functions and all of these variables and attributes. So the way I can do that is just by coming up here. And I'm just going to go right at the top of my file. And I'm just going to say import. And then I want to type in the name of the file that I want to import. So I'm just going to say useful underscore tools. And Python is going to be smart enough to know that it should go off and grab all the stuff from this useful tools dot pi file. So once I've used that import statement, I can actually use all of the functions inside of that useful tools file. So for example, I could simulate rolling a dice, I could say useful tools dot. And now I'm actually able to access all of the attributes from inside that file. So when I say useful tools dot, you'll see down here in my little suggestions menu, it's telling me like Beatles feet and miles, get file extension meters and kilometers roll dice. So it's giving the access to all of the stuff that was in that file. So over here, I could just say like roll dice and we can pass this like a 10 will roll a 10 sided dice. And now this should actually be able to run that function. So we'll simulate rolling a 10 sided dice. You can see we got four. And this is a really core concept in Python, which is importing functionality from external Python files. And this is like huge in Python. And this is seriously going to change the way that you create your Python files. So you'll notice like I didn't have to copy any functions or any variables or anything over into this file. And yet I was able to use all the stuff that was inside this useful tools file. So that is huge. And honestly, it's going to save you a lot of time because you can write something once and then you can import it into your other files. So that's really the basics of using modules. I mean, modules are very simple. A module is just any external Python file that you want to use some stuff inside of it. I want to show you guys a place where you can go to find a huge list of modules. So I'm going to go over here to my web browser. And I'm on this website. It's actually like the official Python docs. And basically all I did to get here was just type in list of Python modules and Google. And depending on the version of Python you're using, you're going to want to make sure that you click the right one. I clicked on the version 31. And over here on this page, you can see there's just a huge list of Python modules. And these are basically modules inside of Python that you can just access. So essentially, there's like all of this awesome code that's already been written for you. And so there's some sort of functionality that you want to have inside of your Python program. Chances are there's a module in here that has that functionality. So there's all sorts of stuff you can do. I mean, if you just look through this list, like, you'll see a huge collection of basically just, you know, a bunch of either Python variables or Python functions, just, you know, things that you can use to make your programs better. So here's what I would recommend, like, head over to this page and just sort of look through a lot of these different modules, you know, see what you can see. And honestly, like, if you click on one of them, it'll bring you to a page that talks about like how to use it. It'll tell you like how to import it and just, you know, some basics about it. And this is sort of like the list that's on the official Python docs. But here's the other thing. The Python community is huge. There's tons of developers who use Python. And you can actually find a lot of third party modules. So if you just go online and, you know, look up, like, Python module for doing X or Python module for doing Y, chances are somebody out there has already written a Python module to do what you're trying to do. So if you get good at using modules and you get good at, you know, looking for them and finding them, you can actually save yourself a bunch of time because chances are that somebody's already written a module to do, you know, what you're trying to do or like part of what you're trying to do. So now that we've taken a look at all these different Python modules, I want to just kind of dive in a little bit deeper into how we can actually use these things. So you'll notice here, there's a lot of files, right? There's a lot of different modules that we apparently have access to Python. But the question is, where are all these files stored, right? When I was over here in my program, for example, I was using this useful tools.py file. Like, I knew where that was. I created that file. I was directly involved in making it. And I just imported over here. It was pretty easy, right? But what about all of these files, right? What about all these modules over here? Like, where are all of these stored? And there's basically two types of modules here. There's built-in modules, which means they're just built into the Python language. So we kind of just automatically have access to them. And there's external modules. And a lot of these external modules are just stored in basically the same folder that we installed Python on our computer. So for example, let's look at a couple of these, right? We have, like, base 64, BDB, bin ASCII, like, if I come over here and you'll see, I'm over here in my little file explorer. I have my Python project, which is draft. There's also this other folder over here called external libraries. If I was to click down on this and I come down here, you can see it's just the version of Python that I'm using. There's a folder here called lib. And this is a very important folder. This is basically storing all of those external modules. So you can see if I scroll down here, we have all of these different, like, modules, right? So here's that base 64. Here's BDB, right? A lot of these external modules are stored inside of this lib folder. And like I said, there's external modules. There's also a few modules that are just like built in modules. They're not going to be stored inside of here. And you can actually tell. So for example, if I was to come over here and click on base 64, it tells me where the source code is. So the source codes in lib forward slash base 64. We were able to see that, right? I was, I saw that inside of my lib folder. This bin ASCII, though, for example, if I click on this, you'll notice that this isn't giving me a folder because this is basically just like built into Python. So we don't have to worry about, you know, locating that file. It's just kind of like, it just kind of works. So some of these are external. Some of them are built in. And I want to show you guys, in addition to using these modules, right? So there's a lot of good stuff here. And honestly, you could spend, you know, years and years just learning about all these different modules. But a lot of times you're going to want to use modules that other people have written. And you know, there's a lot of developers who work on Python and who write different modules. So there's a lot of useful modules out there that aren't included in this list, right? They're not going to be inside of this lib folder by default. And what we can actually do is we can install those external modules, those third party modules, that don't just come pre installed with Python. And I'm going to show you guys how to do that really quick. So the first thing you need to do, obviously, is find a Python module that you want to install that you want to download. And I have actually used one of the past Python docs. It's an external module that you can use to basically use Python to create Word documents, which is pretty cool. So you can like format Word documents inside of it. So I'm just going to look that up here in Google. I'm just going to type in Python docs. And look, here's the thing, there's tons of these external modules. You don't have to use Python docs. I'm just giving you guys an example. But really, if you just look up like useful third party Python modules, there's going to be lists of these things online. In my case, though, Python docs has a website, and it basically just has like some installation instructions. I'm going to come over here. And it tells me that I can install Python docs using the command pip install Python docs. So this brings us to something I want to talk to you guys about, which is pip. And pip is essentially a program. And actually, if you have a newer version of Python three, it comes pre installed with Python three. And you can use pip to install Python modules. It's referred to as a package manager. And a package manager basically just allows you to like install, manage, update, and uninstall like different Python modules. So pip is extremely useful. And in order for us to install Python docs, we're going to have to use pip. So I'm going to show you guys how we can do that. What I want to do is open up the command prompt or the terminal on my computer. If you're on a Mac, you want to open up your terminal. If you're on a Windows computer, you want to open up your command prompts. I'm using a Windows right now. So I'm just going to come down to the search bar and type in CMD. And this command prompt should come up. So I'm going to click this inside of the command prompt, we can actually use pip. The first thing we want to do is just check to make sure that pip's installed. And like I said, if you have a version of Python three, pip should come just pre installed. And it should just work in here. If you don't have a new version of Python three, though, you might have to install pip separately. And there's tons of instructions online on how to install pip. So I'm just going to check to make sure that I have it, I'm going to type in pip hyphen hyphen version. And this should spit out the version of pip that I currently have. So as long as we have pip, then we're ready to install an external or third party Python module. All I have to do is just say pick install. And now I just want to type in the name of the Python module. So in the case of Python docs, it was just Python docs like that. Now again, you don't have to install Python docs. I'm just doing this for this tutorial. Just kind of show you guys how this is going to work. But you know, what you want to do is go online and look up some third party external Python modules. And generally, like I'd say 90 to 95% of the time, you're going to be able to just install them using pip. In the off case that you can't install them using pip, chances are there'll be like some detailed installation instructions. But I would say for the most part, any like legitimate Python module is going to be able to install using pip. So over here, I'm just going to say pip install and then the module name. So Python hyphen docs. And when I click enter, this is going to go off and install Python docs for us. So I'm just going to enter. And it's going to go off and install everything we need for Python docs. So you can see we successfully installed Python docs 0.8.6. So I'm going to show you guys where exactly this got placed. So normally, when we install a external third party module, it's going to get put inside of this lib folder. But it's going to get put inside of a special folder in here called site packages. So site packages is a special folder. And if I open this folder, you'll see now we have this docs folder and we also have this Python docs 0.8.6 pi 3.6.ag info folder. So these two folders are basically included in that module installation. So you can see this docs folder has a bunch of different Python files and has a bunch of stuff in here that we can use. So if I wanted to use this inside of one of my programs, I'm just going to refer to the name of the module. So in our case, it's just going to be docs. So I used Python docs in order to install it. But we're going to use docs if we want to import it. So I could come up here and I could say import DOCX. And now I can actually use it. So I can just say like docs, doc, whatever. And you can see there's a bunch of different stuff down here. There's like a document document part image part. There's a bunch of stuff that we can use with this. And obviously, depending on the Python module you install, there's going to be different instructions. But you can see it got stored down here in this site packages folder. If I wanted to remove this, I could use PIP to do it. So I could just say PIP uninstall. And we could just again say the module name. So Python docs. And PIP will now uninstall this on our computer. So how is to go back over to this folder? You'll see that those two, that docs folder and then that other folder disappeared. So they're no longer here. And I'm actually not going to be able to use this anymore. So that's sort of the ins and outs of using modules. Now again, there's tons of these modules and I can make dozens and dozens of Python courses covering each one of these modules. The built-in modules, the modules that are included by default and external modules, there's tons of these things out there. And really, as a Python programmer now, what you can do is you can go out and play around with these different modules. I showed you the ins and outs of installing them and you can use PIP to install all these different modules. And you can make sure that you have them by checking the site packages folder or the libs folder. But really now it's on you to just kind of go out and use these modules and don't shy away from this because modules are a huge part of Python and you're definitely going to want to include them in your Python stack. In this tutorial, I want to talk to you guys about classes and objects in Python. Now classes and objects are extremely useful in Python programming and they can help you to make your programs more organized and more powerful. So when we're in Python, we're dealing with all types of data, right? And a lot of times when we're writing programs, we're going to have to work with different types of data. And there's essentially like a few basic types of data we can do with usually things like strings, so like plain text, numbers, and Boolean values. Those three are kind of like the main types of data that you're going to be working with in Python. And we have all sorts of structures we can use to store that data, you know, things like lists or dictionaries. But here's the problem is that not all information, not all data and not all things can be represented using strings, numbers, or Booleans, right? There's a lot of things in the real world that we can't represent in something like a string or just a number, right? In other words, something like think of like something like a phone or a computer or a person, right? You can't really represent those things in like a string or a number. You know, in other words, like the data types that we have available to us in Python can't cover that. And so what we can do with classes and objects is we can essentially create our own data types. So I can create my own data type for anything I want in Python. So I could create like a phone data type and it could represent a phone. So I could store all the information I would ever want to know about my phone inside of that data type. And in Python, we could create a class for it. And essentially what a class is is it's just saying, hey, here's another data type that we want to use in Python. So with a class, you can essentially define your own data type. And it's super awesome. And classes are extremely useful. Classes are used in almost every single major programming language out there. So in this tutorial, I just want to give you guys a basic introduction of classes and using them inside of Python. So let's say that I'm writing a program and I want to represent a student inside of this program. So maybe I'm writing a program for like a college or a university. Let's say that in this program, I want to model a student. Like I want to model a real world object and I want it to be a student. Right, we don't have a student data type and I can't really represent a student in just a single string or a number. So what I can actually do is I can create a class for a student. And I'm basically creating like a student data type. So I'm going to show you guys how we can do that and create our student class. So over here, I'm just going to make a new file. We'll just make it a new Python file. So I'm just going to call it student.py. And inside of this student.py file, I want to create a student class. So the way that I can do that is just by typing class. And now I want to type the name of the class that I want to create. So in our case, we're going to create a class called student. So I'm just going to say student and now we're going to make a colon. Now everything that goes inside of here is going to be inside of our student class. So everything that's indented like this will be considered a part of our student class. And basically what we can do inside of this student class is we can define a bunch of attributes about a student. So essentially what I'm doing is I'm like modeling a student. I'm creating our student data type. And I can use things like strings, integers, and booleans in order to map out what a student should be and what a student should have. So I want to create something called an initialize function. And the way I do that is just by typing out def. And I'm just going to type two underscores. And then the word I N I T and then two more underscores. And you also want to type out open and close parentheses. And inside of those parentheses, we want to type out self. And then we want to colon after that. What I can do inside of this initialize function is I can basically map out what attributes a student should have. So we can essentially define like, hey, here's the student data type in Python. So what I want to do is add in certain attributes after this self. So I'm just going to say self a comma. And now we can start thinking about, you know, what values will represent a student inside of our Python program. So if I'm thinking like, I'm thinking something like name, right? So every student in our program should have a name. They also might want to have a major because they're in college. They probably also will have a GPA. So they're a grade point average, like how they're doing in school. And let's define one more thing. Let me think. Why don't we make a Boolean? And it's going to be called is on probation. And this will basically tell whether or not the student is on probation. So essentially what I'm doing inside of this initialize method inside of this init function is I'm defining what a student is in our program. And so in this program, a student has a name, it has a major, it has a GPA, and it has a value that determines whether or not it's on probation. This right here is the student data type. So if I'm representing a student inside of my program now, it has all of these attributes associated to it. And that's basically what I'm doing up here. Now inside of this initialize function, we actually have to do something. And basically what I want to do is assign some values. So I'm going to be writing out some stuff and this might not make total sense right now. But this is going to make sense in a second after we create our first student object. So just stick with me right now and just basically know that we have to do what I'm doing over here. So I'm just going to say self dot name is equal to name. And then I'm going to say self dot major is equal to major. Self dot GPA is equal to GPA. And I'm going to say self dot is on probation is equal to is on probation. So again, this might not make a whole lot of sense right now, but in a little bit, this is going to make total sense. So now that I have this student class defined, I can actually use this class inside of my other file. So I'm going to come over here into this app dot Python file. And this is just my main file. So I actually want to create a student right so in that student class, we defined the student data type. And we basically said like hey, a student has a name, a major GPA and it says whether or not they're on probation. That's like the template for what a student is. But we can actually create a student. So we can create an actual student and give it some information. And that's called an object. So this student class over here is basically defining what a student is. So a class is just like an overview of what the student data type is. An object is an actual student. So it's an actual student with a name, a major and a GPA. It's not just this template anymore. It's actually like a student that we're representing inside of our program. So in order to use that student class and create a student object, I actually need to import that. So all I have to do over here is just say from student, and this is referring to this student file. I can say import student. And basically what this is saying is from the student file, I want to import the student class. So even though these are both student, they're referring to different things. So this is referring to the file and this is referring to the actual student class. So now that we did this, we can create a student. So you can create an object of a class a lot like you would a normal variable. So I can just give it a name. I'm going to call this student one. And I'm just going to set it equal to student. And I'm going to make an open and close parentheses. And now inside of this parentheses, I want to give this student a name, a major, a GPA, and an is on probation value. So I'm going to say, we'll just create a fake student. So I'll just say his name's Jim. And he's studying business. And we want to give him a GPA. So maybe he has like a 3.1. And finally, we want to say whether or not this student is on probation. So why don't we say false? So basically what I'm doing is I'm saying that I want to create a student. So I want to actually create a student object. And remember, an object is just an instance of a class. So the class is like an overall template. It defines what a student is. But an object is an actual student with actual information. So we could call student one now. This is a student object. So I just want to show you guys what this student object actually is and what we can do with it. And then I'm going to talk some more about that in it function from before. So over here, I'm just going to make a print statement. And inside of here, I just want to print out student. And what's cool about this student one object is I can actually access each of the attributes from inside of this object. So if I wanted to get the name of the student, I could say student one dot name. And now this is actually going to print out the student's name. So over here, you'll see it prints out Jim. If I wanted, I could print out the student's GPA. And it's going to print out the student's GPA 3.1. So now that I created this student object, I can actually access the information about the student. So essentially, I've just created a student data type. So I could create as many of these students as I wanted. If I wanted, I could create another student we could call it student two. And essentially, we do the same thing. We just give it different information. So we could say like Pam and her major is art. And she has like a 2.5. And let's say that she is on probation. So now I have another student, student two. So if I wanted, I could access information about that student. We could say like student two dot GPA. And now this is giving me the GPA of student two. So basically, what I did was I created a student data type and I created student objects. And now I'm able to represent a student inside of my program. So let's talk real quick about all this stuff over here because I didn't really explain it. Basically, what's happening is when I come over here and I say student and I'm passing in all of these different values, those are getting passed into this init function. Remember, I passed in a name, I passed in a major, I passed in a GPA. When we create that student, we're actually calling this function. And when I pass in the name, the major and the GPA, those values are actually getting stored over here in this name, this major, this GPA, et cetera. So I'm giving this student object all of that information. And down here, what I'm doing is I'm saying self dot name is equal to name. And basically what this means is the actual object's name is going to be equal to the name that they passed in. So self dot name is an attribute of student. So the student is storing a name, the student is storing a major, the student is storing a GPA. But that's different from this name, this major, and this GPA. Remember, these are all just values that I passed in, they're just parameters. And so I need to take the values that I passed in and I need to assign them to the actual attributes of the object. So I need to say, okay, the name of the student is going to be equal to the name that we passed in. One more time, the name of the student object is going to be equal to the name that we passed in. The name of the student's major is going to be equal to the major that we passed in. The student's GPA is going to be equal to the GPA that we passed in. That's basically what's happening here. So when I say self, it's referring to the actual object. So over here, when I'm creating this student object, I'm giving it all of this information. It's taking that information and storing it as attributes for the object. So hopefully that makes sense. I think that's about as clear as I can make it. But the point is that now we have a student data type. So now I can represent a student inside of my Python program. And that's like super powerful. And what's cool about classes and objects is you can do this with anything. So in this example, we created a student class and then we created student objects off of that. But I can model any real world entity into this program. I can model something like a phone or I can model like a water bottle or I can model, you know, a keyboard, right? I can model anything that I wanted inside of my program. I could just give it certain attributes, right? And so that's what's cool about classes is we can model real world objects and we can create our own data types. In this tutorial, I'm going to show you guys how to build a multiple choice quiz in Python. So basically, we're going to set up a little multiple choice quiz and we'll have the user take the quiz. And as they take the quiz, we'll keep track of their score and then at the end we'll tell them how they did. So this is going to be a pretty cool video. I'm excited to show you guys how to do this. And we'll get to use things like classes and if statements and loops in order to build this program. So we're going to use a lot of cool stuff in Python. The first thing I want to show you guys, I actually did this before I started the video. It's this little array. It's called question prompts. And I basically just wrote out all the questions that are going to be or I shouldn't say the questions. I wrote out all the question prompts that are going to be inside of my multiple choice quiz. So the first one just says what color are apples and the answers are red, purple or orange. The next one is what color bananas the options are teal, magenta and yellow. And the third question is what color are strawberries and the options are yellow, red and blue. So this is obviously a very, very easy multiple choice quiz. But I just kind of wrote out the questions beforehand so I didn't have to spend time doing that. So let's talk about how we can build a multiple choice test. Well, the first thing I want to think about is how can I represent the questions in the test. Over here, we have the question prompts, but there's actually two parts to a question when you think about it. There's the prompts. In other words, the actual question itself. And then there's the answer to the question and both of those attributes need to be kept track of. I need to keep track of what we want to ask and I need to keep track of what the answer is. So what I'm actually going to do is create a question class. So I'm going to create a little data type for questions and inside of that question class, we'll be able to store the question prompts and we'll also be able to store the questions answer. So I'm just going to come over here to my folder and I'm going to make a new Python file and we're just going to call this question.py. So we'll call it question.py and inside of this question.py file, I'm going to make a class. So I'm just going to say class question and I'm going to put a colon here. So inside of this question class, we want to define it in initialize function. So I'm going to say def two underscores in it, two underscores, and then we're going to type out an open and close parentheses self and then a colon. So after this self, we want to define the different attributes that will describe or that will be included in a question. So we're going to include a prompt and we're going to include an answer. So every question will have a question prompt and a question answer. Now down here, I want to take those values and assign them to the actual class object. So I'm going to say self dot prompt is equal to prompt and I'm going to say self dot answer is equal to answer. Now we have a question class set up and we can store all the information we need about a question. So what I want to do now is go back over to my app dot Python file. And we're actually going to create an array of questions. So I have over here these three prompts and I'm actually just going to create another array. So we'll just call it questions and I'm just going to set it equal to to open and close square brackets and we're going to start creating question objects. Let's say the first element in this questions array will be a question and we want to pass question prompts zero and the answer to the first question was a red green. That's the color of Apple. So I'm going to pass that first question and I'm also going to pass the answer, which is a and you'll see down here, I'm getting an error. So saying unresolved reference question. So actually what we need to do before we can create these questions is we need to import this question class. So I'm going to come up in here, come up here and say from question import question. So now down here in this questions array, we're not getting that error anymore. So we created one question object and I'm just going to create a couple more for these other ones. So I'm just going to copy this one and we will paste this down here. Alright, so now we're creating two other questions and these ones are going to be one and two and the answer to the second question is C and the answer to the third question. I think it's B. Let me look. Yeah, so it's C and B. Alright, so essentially what we're doing is we're creating three questions. Each one is getting a different question prompt and they're each getting different answers. So now we have an array of questions that we want to ask on our test. So the next step is to actually write a function that will run the test, right? It has to ask the user the questions and it has to check to see if they got the answer right. Down here, lower in the file, let's create a function. So I'm just going to say death and we'll call this run test. And inside of this parentheses, we're going to take one parameter into this function. We're going to take a list of questions. So I'm just going to say questions. So this is basically going to be a list of question objects that we want to ask the user. So once I'm in here, all I want to do is loop through all the questions. So I want to loop through each question. I want to ask it to the user. I want to get the user's answer and I want to check to see if it's right. And we need to be able to keep track of how the user does through the test. So I want to create a variable called score and I'm just going to set it equal to zero. So every time the user answers a question right, we'll increment this score variable. Alright, so what I want to do is, like I said, loop through all the questions in that questions array. So I'm going to create a for loop. I'm going to say for question in questions. So in other words, for each question object inside of this questions array, I want to do something. And basically, the first thing I want to do is ask the user the question. And I want to store their response inside of a variable. So I'm going to say, I'm going to make a variable down here called answer. And this is going to represent the user's answer to the question. And I'm going to set it equal to input and I need to give this a prompt. So I'm actually going to give this the prompt for the question. So I can just say question dot prompt. So now I have the answer that the user entered in, which is stored inside this variable. So we want to check to see if they got the question right. And I can do that using an if statement. Let's say if answer, and this refers to the student's answer, is equal to question dot answer. So I'm checking to see if the answer that the student gave is equal to the answer of the current question that we're asking. And if this is true, then I just want to increment score. So I'm going to say score plus equals one. And this basically just means we're adding one to the score. So the last thing I want to do inside of this function is just print out the result. So I want to print out how the user did. So down here, I'm just going to say print and I'm basically just going to print out like, Hey, you got like two out of three questions or you got five out of six questions, right? Or you got zero out of 10 questions, right? We'll just print out how they did. So I'll just say you got. And now I want to print out how many questions they got right. So this is just going to be the score. And in order to print a number alongside of a string like this, I'm going to have to say STR and then type in the number. So we'll say STR score. So we'll basically say you got however many they got right out of. So we'll use this little forward slash. And now we'll just say how many questions there were. So we can say, and again, we're going to have to convert this to a string because it's going to be a number. So we can say, string, and then we want to figure out how many questions were in that questions array. So I can say LEN. And inside of here, we can just say questions. So this is kind of like this long statement just to print out how many questions there were. So then over here, I'll just say, correct. All right. So now we have this print statement. And it's just going to be printing out how many questions they got right. So let's see if this works. The last thing I need to do is just call this run test function. So I'll say run test, and I'm just going to pass it that questions array that we created before. So we created this questions array with all of these question objects inside of it. I'm basically just going to pass that into this run test function. So now let's run our program and see how we did. Hopefully we don't get any errors. There's a lot of code there, so it's possible that we might. Okay, so it says what color are apples? Huh, this is a tough one. All right, let's put A. So we'll get the first question right. What color are bananas? Let's get the second question wrong. So I'm going to say B, bananas are magenta. And we'll get the third question right. So it says what color are strawberries? I'll just put B because that's the right answer. So now you'll see that our program prints out. You got two out of three correct. So not only did it ask us all the questions and get our input for each question, but it also kept track of our score and it printed it out. So why don't we run through the test one more time and we'll just like get too wrong this time. So we'll get this one wrong. I'll get this one wrong and I'll get this one right. So now it says you got one out of three correct. So it's able to actually grade our test. And what's cool about the program we just wrote is if I wanted, I could add another question into here and it would automatically be able to ask it. So it doesn't matter how many questions we put in here. It's just able to ask it. So really the point I was trying to make with this whole video was just how we can use something like a class in order to model a real world entity. So for example, we created this question class and we were able to store all the information about a question that we could ever need. So we were able to sort of like the prompts and the answer. So we created our own question data type and then we were able to create a bunch of different questions, pass it into this run test method and it was able to grade the test and just run the test really easily. So that's kind of the point. So hopefully this makes sense. You know, this was a lot of code. So if you don't fully understand what I did, go back, watch the video, you know, try it a couple of times on your own and see if you can create your own multiple choice test. In this tutorial, I want to talk to you guys about class functions in Python. So a class function is essentially a function that we can use inside of a class and it can either modify the objects of that class or it can give us specific information about those objects. Over here, I have this student.py file and inside of here, I created a student class. So I just had a class student and I gave this student a couple of different attributes. I gave it a name, a major and a GPA. So I can give this student all of this information. So when I create a student object, it'll have all of that information in it. Now over here on this app.py file, it actually created two students. So student one is Oscar who is studying accounting and he has a GPA of 3.1. Student two is Phyllis who's studying business and she has a 3.8. So what we can actually do is we can use functions inside of these class files. So I could actually define a function inside of this student class and then all of my student objects could access it. So for example, I can come down here and create a function and let's say we wanted to create a function that told us whether or not this particular student had honors. So whether or not they were on the honor roll, right? Basically like, are they like a really good student? So I could define a function called on honor roll. And basically what it's going to do, it's going to tell me whether or not this particular student is on the honor roll. And let's basically just say the rules for being on honor roll is you have to have a GPA of 3.5 or above. So here GPA is 3.5 or above, that means you're on the honor roll. Well, over here I could actually write the code for that. So I could say if self.gpa, and when I say self over here, this is referring to like the actual student's GPA. And you'll notice over here I have to pass that in as a parameter and that always has to be the first parameter. So I could say if self.gpa is greater than or equal to 3.5, then we can return true because this student is on the honor roll. Otherwise else we can just return false because if their GPA isn't above a 3.5 then they're not on the honor roll. So that's essentially our little on honor roll function. And you can see it's a very small function, but it provides a service to the objects of this class. It allows the objects of this class to figure out whether or not that current student is on the honor roll. So over in this app.pa file I could just print out that value. So I could say print and I'm going to see if student one is on the honor roll. So now when I run this you'll see it should print out false. And it's putting out false down here because student one only has a GPA of 3.1. If I was to do the same thing on student two, student two has a GPA of 3.8 so we should return true. And that's exactly what happened. So essentially a class function is just a little function that can be used by the objects of the class. And I would say this is a pretty good example of what a class function should be doing. It should be like giving us information about the class or it can also be like modifying information about the class. So that's the basics of using functions in classes. I mean this is a pretty simple tutorial, but I really just wanted to introduce you guys to the concept of putting functions inside of classes. This is going to be really useful. And if you're making a class you always want to think about what functions can I put inside of here that will essentially help the user to either figure out information about the object or modify different values in the object. In this tutorial I want to talk to you guys about inheritance in Python. Now inheritance is basically where we can define a bunch of attributes and functions and things inside of a class. And then we can create another class and we can inherit all of those attributes. So I can basically have one class that has all the functionality of another class without having to physically write out any of the same methods or attributes. So if that's confusing don't worry I'm going to show you guys exactly what this is in this video. So let me show you about some stuff I have set up over here. I created this class called chef. And over here we just have this class chef. And inside of this chef class we have three functions. So this chef can do three things. The chef can make chicken. The chef can make salad and the chef can make a special dish. And whenever the chef makes a dish he basically just says the chef makes a chicken or the chef makes a salad or the chef makes barbecue ribs for this special dish. It's basically just saying whatever the chef is doing. So if I was to come over here to my app.python file you'll notice that I'm importing the chef. So I'm basically allowed to use this chef class now. And I can say my chef is equal to chef. So I'm creating a new chef. So now if I came down here and I said my chef dot make chicken. When I run my program now it's going to say the chef makes a chicken. If I said make special dish and I run the program now it's going to say the chef makes barbecue ribs because that's the chef's special dish. So I have this really awesome chef class and it works really well. But let's say that I wanted to create another class to model another type of chef. So this chef class is just modeling like some generic chef. We're representing some generic chef in our program. But let's say that I wanted to create a class that modeled a different type of chef. For example let's say we wanted to create a class that modeled a Chinese chef. So instead of just a normal chef this is a Chinese chef. Well I actually created a file over here called Chinese chef dot python. So we could actually use this Chinese chef dot python file to create our Chinese chef class. So I'm just going to say class and over here I'm just going to say Chinese chef. And basically I just can define everything that the Chinese chef can do. But let's say that our Chinese chef can do everything that our generic chef can do. So the Chinese chef is like a special chef right it's a very specific type of chef. But let's say that this Chinese chef can do everything that the normal chef can do. So the Chinese chef can make chicken, can make salad and can also make a special dish. Well if I wanted to give this Chinese chef all of that functionality I could just come over here and I could copy all of these functions and I could paste them in here. So now the Chinese chef can do everything that the other chef can do. But let's say that in addition to all of these things the Chinese chef can also make a special dish called fried rice. So I could say deaf and we could say make fried rice. So the Chinese chef has this extra function which allows it to make fried rice and over here we can just say the chef makes fried rice. And let's also say that the Chinese chef has a different special dish. So instead of making barbecue ribs the Chinese chef makes orange chicken. Alright so now we have our Chinese chef class set up and you'll notice that it can do everything that the normal chef can do. So let's go back over to our app.python file and I want to create a Chinese chef object. So instead of importing from chef we're going to just import it from Chinese chef so I'll say Chinese chef and we're going to import Chinese chef. So let's go ahead and make a Chinese chef object. So down here I'm going to make one and I'll just say my and then my Chinese chef we can print out this special dish. So remember the Chinese chef can do everything that the normal chef could do. So if I say my Chinese chef make special dish when I run this program you'll see the regular chef is making barbecue ribs and the Chinese chef is making orange chicken. So everything works out and this Chinese chef also has an extra method called make fried rice and you can also make fried rice. But here's the problem right when I go over here to this Chinese chef dot pie when I wanted to use all of the functionality that was inside this chef class. I actually had to copy and physically paste all of these functions down into this file right and that's kind of a drag. I mean especially like imagine if this chef had like 20 or 30 of these different functions in it. Well I have to copy and I have to paste all of those inside of this Chinese chef and this is where we can use something called inheritance. So instead of having to copy and paste all of these functions I could just inherit these functions from that chef class. And in order to do that I can actually just get rid of all of these and I can come over here and right next to where I'm saying class Chinese chef. Inside of parentheses I can say the name of the class that I want to inherit from so I can just say chef. And I'm also going to have to import this so I'm going to come over here and we'll say from chef import chef. So basically what this is saying is inside of this Chinese chef I want to be able to use all of the functions that are contained inside of the chef class. So I'll say that one more time. Inside of this Chinese chef class I want to be able to use all of the functions that are inside of this chef class. So by using inheritance here I'm actually able to come over here to this app.py file and now I'm still able to execute for example like the make chicken function. Even though I didn't specify the make chicken function in here I didn't write it out. I can still run this program and the Chinese chef will still be able to make chicken. So when I run this program you'll see down here it says the chef makes chicken. And that's because I inherited the make chicken method from the chef class. But here's one thing that got messed up. If I come over here and I say make special dish. Remember the Chinese chef special dish was supposed to be orange chicken. But now the Chinese chef is going to be making barbecue ribs because I inherited this make special dish function from this chef class. And so what I can actually do is I could come in here and I could override that make special dish class. So I could say death make special dish. And down here I can just override it. So I could say the chef makes orange chicken. And now when I go over here and I run this make special dish function. Now the chef's going to be back to making orange chicken. So the Chinese chef will make his special dish. So that's basically what inheritance does. It allows me to inherit functionality from an existing class into the new class. And I can actually just inherit all of it without having to write it out. So I didn't have to write out make chicken and make salad inside the Chinese class. But the Chinese chef can still make chicken and salad because it inherited that functionality from the chef class. In this tutorial I want to talk to you guys about the Python interpreter. The Python interpreter is basically a little environment that we can use to execute Python commands. So it's kind of like this little sandbox environment where we can test out and try out different Python commands or different Python functions in a very safe and neutral environment. So it's kind of like a quick and dirty way to write Python and try different things out. And the way we use the Python interpreter is by opening up our command prompt. Now if you're on Windows there's a program called command prompt. If you're on Mac there's a program called terminal. And basically you need to open that program in order to use the Python interpreter. So I'm here on a Mac but if you're on a Windows you can essentially do exactly what I'm doing just inside of the command prompt. So on Mac here I'm just going to search for my terminal. If you're on Windows you can just search for like CMD or command prompt and it should pop up. So the terminal is basically an environment on our computer where we can interact with the computer and do different things without a graphical user interface. So normally when we interact with the computer we're using things like buttons or windows or we can move stuff around. We can basically just like interact with the computer with graphics but the terminal or the command prompt is a place where we can interact with the computer using text commands. So you know I'm not going to get too much into what the terminal and the command prompt are but that's essentially what it is. So inside of here we can use the Python interpreter. And the Python interpreter is basically just a little program that like I said we can write you know sort of Python in. So generally all you have to do is go over to your terminal or your command prompt and type in Python 3. And since we're using Python 3 I'm going to type Python 3 but you can also just type normal Python and I'm pretty sure that gives you Python 2. Now here's a quick disclaimer on Windows you may run into a problem where you can't use this Python 3 command and it's possible that if you're running into that problem Python. Like Python 3 hasn't been added to your windows path variable. And basically what that means is your computer doesn't recognize the command Python 3. If that's the case all you have to do is just go and Google how to add Python 3 to your windows path variable. It's really easy I'm not going to get into it in this video just because it's kind of outside the scope but if you're running into that problem that's probably it's not on your windows path variable. So just Google around for that and you should be able to find an answer. But I'm going to type Python 3 and click enter and it's going to open up this cool little thing down here. So you can see it basically just has like here's the version of Python. Now I'm just going to enter so we can have some like new lines here. But down here this is the Python interpreter so we can write Python code in here and it's going to work. So I can for example I could write like print and inside of here I could print like hello world. And when I click enter you'll see that it prints out hello world. I could create a variable so for example I could say like num one is equal to ten. I could say num two is equal to ninety and then I could print out num one plus num two and it's going to be able to do that for me. I could also use some like a function so I could define a function in here. We could make a function that's called say hi and it'll take a name parameter. And you'll see here when it saw I wanted to create a function it put these three little dots and I can indent and we can write the code for our function. So I can say like print hello plus name. And now I have a function called say hi so I can break out of this by just entering again and I can call the function so I could say say hi and we'll say hi to me. Hi Mike so now it's going to say hello Mike so I can use a function I could use something like an if statement you know I could say I could use something like a for loop we could use while loops. I mean we can basically use all of the basic like Python commands and you know inside of this Python interpreter and like I said before it's essentially just an environment where you can test out Python code. Now this is not a place where you want to write like any serious Python scripts. So if you're like designing and writing a Python program I would not recommend doing it inside of this interpreter. It is it's not a very intuitive environment it's pretty much just set up for some quick and dirty tests like we need to test something out great this is a perfect place for it because you don't have to set up a file. You don't have to use like some ID you don't have to execute a file you just go in here it's quick it's dirty you get it done. But if you're writing like an actual program you definitely definitely definitely want to use a text editor. The text editor it's just going to be way more organized everything is going to be a lot cleaner and you're not going to get confused with like where stuff is and what you have so that's the basics of the Python interpreter. You know in the course I haven't really been using it at all just because I think it's a lot easier to teach when we're inside of a file than inside of here but you know don't count this guy out the Python interpreter is awesome a lot of people use it and it's great if you just need to test you know little bits of code out without having to set up some huge environment so Python interpreter definitely awesome I would play around with it you know have some fun and take advantage of it. Hey thanks for watching if you enjoyed the video please leave a like and subscribe to draft Academy to be the first to know when we release new content. Also we're always looking to improve so if you have any constructive criticism or questions or anything leave a comment below. Finally if you're enjoying draft Academy and you want to help us grow head over to draft Academy.com forward slash contribute and invest in our future.

hey what's going on everybody it's bro hope you're doing well and in this video i'm going to help you get started with python so sit back relax and enjoy the show if you wouldn't mind please like comment and subscribe one like equals one prayer for the youtube algorithm i'm gonna tell you why you need to learn python it's the easiest programming language to learn as well as being the most popular in the world right now and according to glassdoor the salary for new python developers in the united states is 64 000 if any of this sounds good to you well then let's get started if you need to download python go to python.org downloads and click this yellow download python button open when done check add python 3.9 or another version to path install now and then give it a little bit it states here that setup was successful so let's close out of this our next step is to download an ide that's an acronym for integrated development environment think of it as software that helps us write other software one ide that i recommend is pycharm you can find it at jetbrains.com pycharm go to download if you would like to pay for a professional version you can click this download button but since i don't like to pay for things i'm going to use the free community version at this point we just have to follow the standard installation procedure click next you can pick a destination folder but i'll keep the default next if you would like a desktop shortcut then check this i would also recommend updating the path variable next install and then give it a minute or two then after finishing i have a desktop shortcut so i can just click on this to run pycharm let's create a new project name this project whatever you like i'm going to name this project hello world and i recommend not creating a main dot pi welcome script right now i'll show you how to do that manually and let's create if you need a python file to work with this is how to create one go to file new python file and i'm going to name this main and then click python file all right ladies and gentlemen we now have an empty python script that we can use to begin coding now if you checked this box create a main.pi welcome script and then created a new project then your main python file will probably look a little something like this but that's completely fine we can just delete this i don't know about you guys but the font is very small for me so let's change that we can change that by going to file settings editor font and you can increase the font size let's say 25 you can also change the font too what's a good one uh how about that then click apply and okay much better we can actually see something to run a python script just click the screen play button in the corner alternatively you can go to the run tab and then go to run okay so this box that appeared at the bottom this is referred to as a terminal window this will display any output that your program has and this line at the end process finished with exit code zero that just means that there were no errors in this program so currently this program doesn't do anything but let's change that let's print something let's print a message so to print a message to the terminal window type print and then add a set of parentheses and then you can type a message but it has to be within quotes either double quotes or single quotes it doesn't matter so let's think of a message i don't know i love pizza then let me run this and in my terminal window it says i love pizza to print another line just add another print statement print and then your message within quotes it's really good and well what do you know it printed i love pizza it's really good so ladies and gentlemen you just wrote your first python program by the way you can change the font as well as the font color of your terminal window by going to file settings then go to editor color scheme console font and console colors let's change the font let's say i would like whatever this font is then click apply let's change the font color too by going to console colors for any output you can click number two and select a color let's say i would like bright green that should be decent and for anything else let's say this will be a dark color so i can barely see it so then let's click apply and okay oh yeah that's much better well everybody that was your very first python program i'll post any useful links and timestamps for this video in the comments section down below but yeah welcome to coding with python hey you yeah i'm talking to you if you learned something new then help me help you in three easy steps by smashing that like button drop a comment down below and subscribe if you'd like to become a fellow bro [Music] hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain how variables work in python so sit back relax and enjoy the show if you find this video helpful please remember to like comment and subscribe your support will help keep this channel running all right let's do this a variable is a container for a value it behaves as the value that it contains it's much like in algebra lessons back in the day where we had to solve for whatever value x was and then we can reuse x and it behaved exactly as that value well with programming we can do that plus we can assign variables of different data types so they are not limited to just numbers we can assign whole words numbers and even these things called booleans which are either true or false but i'll get more in depth into data types a little bit later on in this video so let's create a variable and this is how to do so we need a unique name for this variable let's say name name equals some value now the first data type that we'll cover is strings a string is a series of characters so to create a string we can either use single quotes or double quotes in python and we can assign this a value of whatever your own name is so i will assign this variable name a value of bro now this variable will behave exactly as if it was this value this name and then we can reuse this variable for something so let's print whatever our name is print name and this will print whatever your name is to the console window now when you print your variable make sure you don't put it within quotes because what we're doing then is literally printing the word name as you can see here so if you need to use your variable for something make sure it's not within quotes now we can combine our string variable with another string so within our print statement let's print a string literal such as hello space plus name so we are combining strings and then we're printing the results to the console window so this will print hello bro now you can actually check the data type of a variable so i'm going to turn this line into a comment so what you'll do is take the name of the variable surround this with a set of parentheses and then precede the set of parentheses with the type function and this will print the data type of this variable to the console window and you can see that it says class str short for string a string is a series of characters a name is a good example of a string a series of characters so that is how to check the data type of a variable just use the type function now you can actually combine variables together as long as they're of the same data type so let's change our name to maybe first name and we'll create a second variable called lastname now a common naming convention with variables if it has two words separate each word with an underscore it's not necessary but it's common practice for python and honestly i sometimes forget about that but don't tell anybody so let's create another variable called last name last name equals whatever your last name is and then let's create a third variable called full name full underscore name and let's combine first name plus last name and let us display full name along with hello plus full name now these two names were combined together to create a whole new variable actually what i think i'll do is add a space within my variable so i'm doing a bunch of string concatenation i'm combining the variable first name plus a space character plus last name so the result is hello whatever your first name and last name is so that is a variable of the string data type it is a series of characters now with strings we cannot normally use these for any sort of math that's where the next data type comes in for the time being i just turned all of these lines into comments and we are going to move on to the int data type short for integer this time let's create a variable called age and we will assign this a value of whatever your age is let's just say that i'm 21 now when you assign a value of the int data type make sure that it is not within quotes because then technically it would be a string then and you can see that the color scheme for this number actually changed so if this was a string we would treat it different than an int data type because with strings we cannot normally use them for any sort of math so we now have a variable called edge and we can actually increase or decrease or do whatever we want with the edge let's increase our age by one let's say it's our birthday to do so we would say age equals age plus one and then let's print our edge to the console window print edge and you can see that it says i am 22. now there's a shorthand way of writing this what you'll do is type age plus equals one so that's kind of like a shortcut and this would work the same too now let's print the data type of our inch variable because we can within a print statement i will print the edge and add my edge variable to this type function and this will print the data type of my edge variable to the console window and i will turn this line into a comment just so that it doesn't get in the way now if i were to print the data type of my age variable as you can see it is of the int data type short for integer it only stores a whole integer number now what if this was a string so what i'm going to do is surround my value within a set of quotes and i will turn this line into a comment so that it does not get in the way you can see that the data type of my age variable is now a string and with strings we cannot normally use them for any sort of math so let's attempt to increase our age variable by one and we ran into an error a type air can only concatenate string to string not end now the point being is that it's important to use the appropriate data type because with strings we cannot normally use them for any sort of math you'll want to use a data type of a numeric value an int or a float which we'll discuss a little bit later now here's a situation to consider what if we would like to display our edge variable along with a string literal much like what we did with this line involving a string literal such as hello plus the user's full name so let's attempt to do so and this is not going to work and i'll explain why so within our print statement let's say something such as your age is plus edge now we're going to run into a type error that's because we attempted to use string concatenation with a string literal and a variable of a different data type a variable of the int data type in order to display our edge along with the string we would need to convert our edge variable to the string data type and one way in which we can do that is by type casting and we'll cover this more in the next video so we're going to surround our age variable that is of the in data type with a set of parentheses and precede this with str short for string and this will convert our variable to a string that will allow us to display it with another string now if we were to run this program this way this will now display your age is and in this case 22 so if you need to display a variable of a different data type along with the string you would just need to use a stringcast to convert that data type to a string but we'll cover this more in the next video on typecasting so that is the int data type it stores a whole integer number and the next data type is the float data type and i'm going to turn these lines into comments and we can move on now the float data type is a numeric value that can store a number that includes a decimal portion an int data type cannot store a decimal portion that's why it's in short for integer it only stores a whole number this time let's say we have a height and i will assign this a perfectly normal height of maybe 250.5 centimeters so this decimal portion is important that's indicating that this is a floating point number a float for short so let's print our height to the console window print height and this will print whatever my height is and now let's check the type of our height using the type function so within a print statement i'm going to add my height surround this with another set of parentheses and precede this with the type function and the data type of my variable height is a float short for a floating point number a numeric value that contains a decimal portion and now for practice let's print our height along with a string literal so let's create a string literal such as your height is plus height but guess what we're going to do some type casting so surround height with a set of parentheses and precede this with str so that we convert height to a string so that we can use string concatenation within this print statement and this will print the message your height is 250.5 actually let's add centimeters to the end so plus cm and there we go and that is what a floating point number is float for short it is a numeric value that contains a decimal portion now the last data type that we're going to cover is the boolean data type it is a variable that can only store true or false let's say we have a variable called human if we were to assign this a boolean value this would be either true or false and we can print whatever this value is let's print whatever human is and this will display false now the reason that you may want to use booleans instead of strings even though you can still store a string representation of the word false or true is that these are very useful when we get to if statements we can check to see if some statement is true so that is a good use of boolean values now let's check the data type of my human variable so let's print type human and this will print to the console window bool short for boolean now make sure you're not putting this within quotes because then it's technically a string and they behave differently now the data type is a string and you may have noticed as well that the font color has changed between strings and boolean values so that's another good indicator now what if you need to display your value along with a string using string concatenation well guess what we're going to typecast again so let's print something r u a human so we need to use string concatenation so i will convert my boolean variable of human to a string and i have been programmed to inform you that yes i am in fact a human that is true well everyone that is the basics of variables it is a container for a value and they behave as the value that they contain there are four basic data types strings which store a series of characters inc which store a whole integer floats which are floating point numbers a numeric value with a decimal and booleans which only store true or false and they're very useful with if statements so that is it for variables if you would like a copy of all this code i will copy and paste all of this to the comments section down below but yeah that is how variables work in python hey people what's going on it's bro hope you're doing well and in this video i'm going to explain multiple assignment in python so sit back relax and enjoy the show well then since you clicked on this video i should probably explain what multiple assignment is now multiple assignment allows us to assign multiple variables at the same time using one line of code here's an example of us using standard assignment let's say we have a variable name and i will set this to a value of my name but you can use your name for this example let's say edge equals 21 and how about a variable called attractive i think i'm going to set this to true okay so we have a bunch of variables and then we can print the value of these variables with some print statements so let's print name age and attractive so we have name age attractive and as you would expect this prints bro 21 and true now another way in which we could write the same code is to use multiple assignment and this allows us to assign multiple variables at the same time using one line of code so i'm going to turn all of these lines into comments and this time we will only use one line of code but to do this we're going to list all of our variables separated with a comma so that would be name comma edge comma attractive and we will set them equal to those values but in the same order separated by commas so that would be bro comma 21 comma true and this would do the same thing only using one line of code here's another example let's say we have four variables spongebob patrick sandy and squidward and let's pretend that they're all around maybe 30 years old at least it seems like they're around 30 years old but i could be wrong i'm not too familiar with spongebob lore so let's set them all equal to 30. now we could write this using four lines of code or we could use multiple assignment to write the same thing using one line of code so if all of these variables are all equal to the same value there's a little bit of different syntax here so let's begin with the first variable of spongebob equals patrick equals sandy equals squidward then we're going to set them all equal to 30 and this should work just fine using only one line of code well everybody that's pretty much it for multiple assignment it allows us to assign multiple variables at the same time using one line of code i will post all of this code in the comments section down below and well yeah that's how multiple assignment works in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to demonstrate some useful string methods in python so sit back relax and enjoy the show all right let's do this in this video i'm going to be explaining and demonstrating a few useful methods available to us for strings now let's create a variable called name for this example and you can use your own name if you want so we now have a variable called name and for my first example let's print the length of our name variable so to do that we can surround our name variable with the length method and this will print and return how long the length of our string is and for me the length of my name variable is three for three characters if i were to increase the size of my name well then that's going to change to a so that is the length method and i'm just going to turn this line into a comment and let's move on so next we have the find method i just copy and pasted print name so i can reuse it name dot and actually if you have intellisense setup if you add dot after your variable you'll get a suggestion or a few suggestions of different methods and other features that you have access to so let's find find which is uh screw this i'll just type find find then we can find the first index of where this character is let's say i would like to find where capital b is well that is at index zero because computers always start with zero so this first character would be zero then r would be one and then o would be two for this example all right so that is how to find a character within a string moving on so let's capitalize our name and i should probably make this lowercase so name dot capitalize and this will make my name capitalized but if there's any spaces and then additional words it's not going to capitalize that only the first letter and your string next we have upper this will make your string all uppercase name upper and now it is uppercase guess what's next lower name dot lower and i should probably make this capital again and everything is lowercase we're making some good progress today next we have is digit this will return true or false depending on if our string is a digit which it's not so this will print false if i changed my string to a bunch of numbers like 1 2 3 then this will return true let's change that back and move on next we have is alpha are these alphabetical characters oh make sure you add the parentheses afterwards my bad false because we added a space within here now it's true so you can use is alpha to check to see if your string contains only letters alphabetical letters next we have count we can count how many characters are within our string i would like to count how many o's are in here and this should return two that's right okay we're almost at the end we can replace characters within our string so we use the replace method and we pass in two arguments the character we would like to replace and the character we would like to replace our character with i would like to change all o's to a's and now my name is brock hod oh you guys are gonna like this next one this isn't technically a method but it's a really neat feature so one thing that we can do that's available to us with python is that we can display a string multiple times by multiplying that string by a given number so let's say i would like to display my name three times i can just take my string variable then add times three and this will print my name three times bro bro bro like i said not technically a method but it's a useful feature that you might be interested in that's related all right everybody so that is a few useful methods available to us for strings if you would like a copy of all this code i will post this in the comments section down below but yeah those are a few useful methods available to us for strings hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to teach you guys all about typecasting in python so sit back relax and enjoy the show all right welcome back everybody i have a super quick video for you guys today on the subject of typecasting now typecasting is the ability to convert the data type of a value to another data type here's an example that i've written already i'm just going to paste it i have three variables for this example x y and z x contains one this is a whole integer into for short y contains two point zero this is a floating point number float four short you can tell it's a float because it ends with a decimal portion and z contains a string of three a string is a series of characters and you can tell it's a string because it's surrounded with a set of quotes and remember with strings we cannot normally perform math on strings so i have three print statements for x y and z and as you would expect they contain the values of one two point zero and three now let's begin by converting both y and z to the integer data type via typecasting in order to perform typecasting on a value or variable type that value or variable and surround this with a set of parentheses whoops i missed and then pre-save this with the data type you'd like to convert this value or variable to i would like to convert y to an integer and then you can use this for whatever you need so i'm going to replace y within my print statement with y after we typecast it as an integer and this will display 1 2 not 2.0 it's the whole integer of 2 and then 3. so this is not a permanent change if you need to make this as a permanent change to y you'd have to reassign it so let's say y equals y and then we're going to typecast y so let's round this with a set of parentheses and precede this with the data type we'd like to convert y2 so now y is a whole integer and then we will print y without typecast this time and our result is one two three now z z is storing a string and with strings we cannot normally perform any math on strings for example within my print statement i will state z times three you would think that the result would be nine right well you're wrong it's going to print three three times if you need to convert a string to a int or a float you would just have to typecast it so this time let's type cast z as an integer z int and we will type cast z as an integer so then if we have z times three the result is now 9 instead of 333 so that's the basic formula for type casting now let's convert these to floating point numbers but let's include x as well because x is feeling left out so let's convert x to a floating point number so float parenthesis and we will surround this with x and display x and actually let's convert y and z to floats as well because why not the results are now 1.0 2.0 and 9.0 remember that we multiplied z times three and then if we need to convert these values to a string we would use the string cast so the results now are 1 2.0 and 333 now you might be thinking to yourself when would you need to convert an integer or a float to a string here's a situation let's say within our print statements we need to print these variables along with another string so within our print statement let's say x is plus x we would like to display these together and let me copy this and do the same thing for y we'll say y is plus y you cannot normally display a string along with an integer or a float because we're using some string concatenation so this will result in a compilation error can only concatenate string not int to string so that's a situation in which you might need to use typecasting to convert an integer or float to a string so let's display x and y as strings via typecasting so we'll surround x and y with a set of parentheses and precede this with the data type we'd like to convert these values to we would like to convert x and y to both strings and now this will compile and run just fine well everybody that's the basics of typecasting if you would like a copy of all my code i will post everything in the comments down below if you found this video helpful don't be afraid to help me out by smashing that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's bro hope you're doing well and in this video i'm going to teach you guys how we can accept some user input in python so sit back relax and enjoy the show ladies and gentlemen this is where the fun begins in this video i'm going to explain how we can accept some user input in python and we do so by using the input function and then we type in our input to the console window but it would probably be good practice to let the user know what we want them to type in exactly so let's ask for somebody's name within quotes inside the input function i'm going to type what is your name and now our program will wait for us to enter in some user input so you can use your own name for this example i'm going to type bro now to submit some user input you just type or press enter now you can see that my process finished with exit code zero that means the program is done running so we should probably do something with this value we can actually assign it to a variable so we can use it elsewhere in our program so to do so we precede input with a variable like name works name equals input and when we accept some user input we will assign it to this variable that we called them and now we can do something with it so let's print a message involving our name variable that we have so how about hello plus name now when i run this program we can accept some user input and then do something with that input such as display message that says hello bro and then you can type in whatever you want for your name let's say i'm dude what is your name dude hello dude now this next part is very important when we accept user input it is always of the string data type a series of characters what if we need to accept a number well you can but you can't normally perform any math on it because it's of the string data type we would need to cast it as either of the integer data type or of the float data type so here's an example of why we can't perform any math on a string let's say we have a variable called edge age equals input and let's ask how old somebody is how old are you now i will add one to somebody's age let's pretend it's their birthday age equals age plus one this will add one to their age now let's try and run this what is your name bro how old are you let's say that i'm 21. okay we ran into an error a type error can only concatenate string to string with what i mentioned previously we cannot normally use strings for any sort of mathematical equation or operation we'll want to cast it to the integer or the float data type so let's cast our user input to the integer data type and we will surround our user input with a cast surround your input with a set of parenthesis and precede this with int and now we can use this user input in a mathematical operation so let's try it even though this won't display age yet so what is your name bro 21 and our program finished with an x a code of zero there were no problems now let's attempt to display this edge so i will print u r plus age plus years old we're doing some string concatenation here what is your name bro how old are you 21 all right we ran into a type error again can only concatenate string to string you cannot normally display a variable of the integer data type along with strings because we're doing string concatenation we're adding strings together we would need to convert this variable back to the string data type so we can cast it we'll surround our edge variable with a cast now this is what's going to happen we will accept some user input it will be of the string data type and then we will immediately cast it to be of the integer data type so that we can treat it as a number instead of a character and then if we need to display this edge we will need to convert it back to a string so that we can use some string concatenation and display all of these strings together and now let's try this theory so what is your name bro how old are you let's say i'm 21 hello bro you are 22 years old here's a situation what if we enter a number that contains a decimal portion so let's try this again let's say i'm 21.5 years old well now we ran into a different issue a value error invalid literal for int with base 10 that means if we cast a string as an integer it can only be a whole number a portion that does not contain a decimal and that is where the float data type would come in it is a data type that can contain a decimal portion for this example let's create a third variable called height and we will ask for somebody's height input we'll create a prompt that says how tall are you and we will cast this to be of the float data type so that our string our user input can contain a decimal portion and then we can treat it as a number instead of a series of characters and i think i will delete this line we won't really need it anymore and then let's print their height along with a message u r plus then height but we need to cast this back to being a string so we'll surround our height with a cast plus let's say cm tall all right let's test this what is your name bro how old are you let's say i'm 21 how tall are you let's pretend that i'm 250.5 centimeters tall i'm adding the 0.5 just to test to see if this will accept a floating point number hello bro you are 21 years old you are 250.5 centimeters tall not really all right everybody so that is the basics of user input in python normally with user input it will give you a value of the string data type if you need to use that value for any sort of math you'll probably need to cast it to be of the integer or the float data type so if you would like a copy of this code i will post this in the comment section down below but yeah that's how to accept user input in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to demonstrate a few useful functions related to numbers in python so sit back relax and enjoy the show okay let's begin in this video i'm going to be demonstrating a bunch of useful functions related to numbers and a bunch of these functions are located within the math module now let's create a variable for this example let's say pi equals 3.14 just the first few digits of pi is fine for this example and now here's a bunch of useful functions that you guys would probably be interested in the first is round round is a built-in function and all we do is type round then add a set of parenthesis and then we can pass in a value or a variable as an argument and the round function will round that number for us so pi rounded to the nearest whole integer is you guessed it three now we can round a number up by using the seal function of the math class seal short for ceiling so let's print our result and in order to access this function within the math module we would type the name of the module dot and here's a bunch of functions that we have access to so we are looking for seal and it's actually at the top here for me and at seal we'll round a number up to the nearest whole integer so pi rounded up is four then on the flip side we can round a number down by using floor and that is also located within the math module so let's type math dot floor and pi rounded down would be three up next i have the absolute value function but it's abs for short abs will give you the absolute value of a number so the absolute value of pi actually let's make this negative 3.14 the absolute value will tell you how far a number is away from zero so if you pass in a negative number it will give you a positive number so that is abs short for absolute value next we have the pow function pow will raise a base number to a power let's raise pi to the power of two so we pass in two arguments a base and an exponent pi to the power of two is nine point eight and some change so that is the pow function next we have square root so this is located within the math module we'll type math dot s q r t short for square root and the square root of pi is let's find out oh i guess we can't pass in pi uh let's round a different number like 420 oh i guess that's because i made pi negative okay so the square root of 420 is 20.4 and some change so that is the square root function all right we have two left we have the max function the max function will find the largest of a varying amount of values so let's create three variables for this example let's say x equals one y equals two and z equals three we can use the max function to find the largest of these values so within a print statement let's use the max function and pass in all of the different values or variables that you would like to compare so i would like to find the largest value between x y and z and the result in this example is three now the min function will find the lowest so min and then pass in your values or variables so i would like to find the minimum value between x y and z and in this case it is one well everybody those are a few useful functions that you guys might be interested in if you guys would like a copy of this code i will post this in the comments section down below but yeah those are a few useful functions related to numbers in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain string slicing in python so sit back relax and enjoy the show all right then let's talk about slicing slicing can be used to create a substring by extracting elements from another string the same principle can also be applied to different collections as well but in this video we're going to be focusing on slicing strings now to slice a string we can either use the indexing operator which is a set of square brackets or by use of the slice function to create a slice object this is a little more complex we'll discuss the slice function near the end of this video so with slicing there are three optional arguments three fields that we can fill in depending on where and how we want to slice our string a starting index a stopping index and a step let's begin with the starting index now for this example let's say we have a string variable called name and this will store a value of whatever your own full name is yes i legally change my name to bro code you can use your own name for this if you want so what i would like to do is to create a substring based off a sliced portion of my full name so what i would like to do is create a substring based off of just the first part of my name just bro so let's begin by creating a substring maybe i'll call this first name equals now to slice a string type in a string or the name of a variable that contains your string and follow this with the indexing operator and like i said we'll discuss the slice function a little bit later so we need a starting index and a stopping index but we'll begin with the starting index where do we want to begin our slice so computers they always start with zero so the first character in your string will have an index of zero i would like my slice to begin at index 0 so i'll list that for the starting position the starting index so let's test this just to be sure it works i'll just print first name and let's see if this prints capital b which it does so following that same pattern the next character within my string would have an index of one that would be r then the next index two would be o and three should be an empty space all right so that is the starting index within string slicing if we would like to slice an entire portion of our string not just one letter we need a stopping index as well and both of these fields are separated with a colon so let's say i would like to slice the first three characters of my string so this would have an index of zero one two and this isn't going to work as you would imagine and i'll explain why so you would think that indexes 0 through 2 would give us three letters right but it only gives us two so this first index is inclusive the stopping index is exclusive so if i want the first three characters the first three letters in the string i would need the starting index to be zero and the stopping index to be three and now this should print my first name and not anything else there is a shorthand way of writing this too so if you were to leave this first index blank for start well python is going to assume that this is zero the beginning of your string so this would be no different than what we had previously just having colon three now let's try and create a separate substring for a last name so last name name now we need a starting index and a stopping index so we need the starting index at least so this would be zero one two three four four colon and where do we want this to stop zero one two three four five six seven and remember that this is exclusive so we're going to place eight here and now i would like to display last name and this should just display code and a shortcut is that if you were to leave stop blank but you still have that colon this is a shorthand way of writing i would like every character starting at index four and everything after until the end so there would be no change to this as well you can write it either way okay so we still have to discuss step step is an optional field that we can set a value to so step is how much we're increasing our index by between starting and stopping so it is entirely possible to create a substring that will count only every second character after the first normally step is one by default but if we were to set that to two we're going to count only every second character so let's try this maybe i'll create a new variable called funky name because i really don't know what else to call this for this example let's say funky name equals name and i'm going to count only every second character including the first so the indexes would be zero colon eight for my example but if you're using your own name that's probably going to be something different so the default first step is one and if i were to display funky name as it is currently this will just display my full name but if we set step to two this will only display every second character including the first so funky name is now for me at least b o c d now if step was three this will print only every third character including the first where it's b space d a shorthand way of writing this is that you could leave start and stop empty but the important thing is to have these two colons python is going to assume that if you leave your starting index empty you're referring to index 0 the beginning if your second index your stopping index is empty python will assume this will be the very end of your string so just having two colons and then step three would be no different than what we had previously or this next part i'm going to explain how we can reverse a string in python so let's create a new substring variable called reversed name equals name i would like to use the entire string so i can just use two colons python will fill in the rest so for the step this is going to be negative one it's kind of like we're counting backwards and we're going to create a new sub string based off my name but in reverse so if i were to print my reversed name this is now edok orb i think that's how you pronounce it so that's how to reverse a string in python using slicing now let's move on to part two of this video i'm going to be explaining the slice function and we can use the slice function to create a slice object which is actually reusable so that's somewhat convenient let's take a different scenario this time let's say we have a website url website equals http colon2forwardslashes google.com but use whatever website you want what i would like to do for this program is remove and create a substring based off the website name and not anything else i would like to exclude the http portion as well as the dot-com portion of this website url so let's break it down step by step our first step is to create a slice object so i will name the slice object as slice slice equals and i will invoke the slice function so within the parentheses of the slice function we can add up to three values a start a stop and a step exactly the same as what we did with indexing however with the slice function we separate each of these values with a comma instead of a colon but it works the same way so we would like our substring to begin where the name of the website begins so we would like our start to be zero one two three four five six seven so i will pass in seven for where my substring will begin and now each value within the slice function will be separated with a comma instead of a colon like what we did with the indexing operator now for the stop index that's going to be a little bit tricky and let me explain why one issue that we're going to run into is that not all website names are consistent with their length they can really vary so it is not possible for us to use the same stopping index for each of these website urls so one way in which we can account for that is to use what is called a negative index each character within a string has a positive index as well as a negative index and a negative index works almost exactly the same way except the character most on the right begins with a negative index of minus one and the character on the left of that would be negative two negative three and negative four it's as if you're counting backwards so with indexing we can use some combination of positive and negative indexing so i would like my substring to end where this dot is so this would have a index of minus one minus two minus three minus four and remember that this is exclusive so i would like my slice to begin at index seven and a negative index of four for the stopping position so that will give me just the website name and remove the http portion as well as the dot com portion of my website url and now we have a slice object and we can reuse this so to apply your slice object type in the name your string index operator and place your slice right within here and let's print this so print our website and apply the slice to it and now this should give us just the website name and now let's test this with maybe another website i'll rename this as website one and let's create website2 and let's try a different website name for goodmeasure so let's try wikipedia so we can reuse our slice object and we will apply our slice to website two this time and this should remove the url portions http as well as com all right everybody so that is slicing strings in python you can either use the indexing operator or the slice function to create a slice object if you would like a copy of all this code i will post all of this in the comments section down below but yeah that is how string slicing works in python hey what's going on people it's you bro hope you're doing well and in this video i'm going to explain if statements else if statements and else statements and python so sit back relax and enjoy the show all right people let's talk about if statements an if statement is a block of code that will execute only if its condition is true it's a very basic form of decision making with programming for this example let's create a prompt where we will ask a user for their age and depending on what their age is we will print a response so let's say age equals input and then we will add a prompt how old are you now this will return a string so we should probably cast this as an integer data type so we now have a variable called age where we will accept some user input let's check somebody's age with a variety of if statements so let's check to see if somebody's age is greater than or equal to 18 so to create an if statement type if and then some sort of condition if age is greater than or equal to 18 to finish this if statement add a colon at the end now pay attention to this if i move down to the next line you'll notice that my cursor is now indented any indented code underneath an if statement is the block of code for that if statement so if this condition is true we will execute some block of code if it's false we'll skip over it so if somebody's age is greater than or equal to 18 let's print you are an adult and let's try this program how old are you let's say i'm 21 so my condition when we get to the if statement is going to check to see if this condition is true if it is true we're going to execute this block of code if it's not we skip over it so how old are you let's say i'm 21 i'm going to hit enter and my if statement is true so we execute this block of code which prints you are an adult so what if this condition is false let's say i'm 12. well then we're just going to skip over this block of code and continue on with the rest of the program if you would like your program to take some other course of action if this condition is false we can add an else statement so after the if statement add else make sure you get the indentation right you don't want this within the block of code for the if statement so if this condition is false we can take some other course of action so if somebody's age is less than 18 let's print you are a child so let's try this again i'm going to enter that i am 12 years old not really but let's just pretend i am so this will now print you are a child if this condition is false perform this block of code for the else statement so with if statements we can check more than one condition before reaching the else statement by using an else if statement and we add that after an if statement so it's shortened to e l i f for else if so let's check to see if somebody's age is less than zero for some reason so let's print you haven't been born yet so with if statements we start at the top we first check the if statement if this is false we move down to the next statement to check then we check our else if statement if this is also false then we resort to the else statement the else statement is sort of like a last resort if all conditions evaluate to be false then we execute the else statement so let's try this how old are you let's say i'm negative 1 years old you haven't been born yet so with if statements we always begin with an if statement and we check that condition if that condition evaluates to be false then we will skip this block of code and move down to the else if statement if there is one it's optional if this condition is also false then we will use our else statement as a last resort if there is one if there is no else statement then we just skip over all of this then and continue on with the rest of the program so you can add more than one else if statement so let's check something else let's check to see else if age is equal to 100 so if you need to check to see if a value is equal to a particular value make sure you use double equal signs this is the comparison operator for equality if you use just one equal sign that's the assignment operator and python thinks you're attempting to set age equal to 100 so if you want to check to see if age is equal to 100 then use double equals so let's check to see if somebody's age is equal to 100 so let's print you are a century old now pay attention to this if i were to run this program how old are you let's say i'm 100. so this is printing you are an adult that's because we first check our if statement and well we're 100 years old and 100 is greater than or equal to 18. so we print this block of code we execute this block of code and then we skip everything else even though age is equal to 100 within our else if statement so the order of your if statements does matter so let's change this around let's add this to the very beginning and this will be our if statement and we will set age is greater than or equal to 18 to be an else if statement so we're first going to check to see if age is equal to 100 if not we will check to see if age is greater than or equal to 18 and we just follow that order so let's try this again how old are you i am 100 years old you are a century old so we first check our if statement if this condition is true we will execute this block of code if it's false we just go down the order till we reach our else statement well everybody that is the basics of if statements we have if statements else if statements and else statements so if you would like a copy of this code i will post this in the comments down below but yeah that is how if statements work in python hey what's going on everybody it's bro hope you're doing well in this video i'm going to explain logical operators in python so sit back relax and enjoy the show all right everybody let's talk about logical operators these are used to check if two or more conditional statements are true so we'll be discussing the and as well as the or logical operators there's also a third one called not but that works a little bit different and i'll explain why so let's create a program to demonstrate this let's create a program where we will ask somebody for the temperature outside and then depending on the temperature if it falls within a certain range we will print a message so we'll need to use and as well as or logical operators to do this so here i have a prompt temp for temperature equals input what is the temperature outside so i'm going to cast this as an integer data type so what if we want to check to see if our temperature is within a certain range we can use the and logical operator to check two or more conditional statements this is how we might do that let's check if temp is greater than or equal to zero zero degrees celsius and we can check another condition too if temp is less than or equal to 30 degrees celsius so we need to add a colon at the end to finish this if statement and let me just fix some of the spacing okay so with the and logical operator in order for this entire condition to be true both conditions must be true this needs to be true and this needs to be true so if our temperature is equal to or above 0 as well as being less than or equal to 30 that means our temperature falls within a certain range so let's print a message such as the temperature is good today print go outside all right let's try it so what is the temperature outside let's say it's 20 degrees celsius well the temperature is good today go outside this condition is true 20 is greater than or equal to zero and temperature is less than or equal to 30. let's try a different temperature like negative 20 degrees celsius so it's really freaking cold outside right now as you can see nothing happened because our first condition was false our temperature is not greater than or equal to zero but our temperature is less than or equal to 30 so our second condition is true but our first condition was false and in order for this entire statement to be true since we're using the and logical operator both conditions must be true in order for this statement to be true now let's discuss the or logical operator we can check to see if our temperature is below or above a certain range so let's write else if temp is less than zero or temp is greater than 30. so that means it's going to be either very cold outside or very hot outside so let's print a message the temperature is bad today print stay inside all right let's try this again what is the temperature outside it is negative 20 degrees outside the temperature is bad today stay inside so with the orological operator as long as one of these conditions is true then the entire statement is true it doesn't matter if one of them is false as long as one of them is true then the entire statement is true last but not least we have the not logical operator this works a little bit different from the and as well as the or logical operator because we can check one or more conditional statements instead of two or more conditional statements so what the not logical operator will do is that it'll take a conditional statement if it's true it's going to flip it to false if it's normally false it's going to flip it to true so for this example we have another way in which we could write this although it's a little more complex so if our statement is true what we can do is that we can flip it to false using the not logical operator if it's normally false we can change it to true so what we'll do is surround one or more conditional statements with a set of parentheses and precede everything within the parentheses with the not logical operator so if the statement is normally true it's going to become false using the not logical operator if it's normally false it's going to be true then let's do the same with the else if statement so surround one or more conditional statements with the not logical operator so now these roles are going to be kind of reversed so let's try this again what is the temperature outside it is negative 20 degrees outside the temperature is good today go outside so what we should probably do is kind of reverse these rolls so i'm just going to swap everything within these if statements with each other and now this should work the same as it did before but we just wrote it a little bit different what is the temperature outside it is 15 degrees outside 15 degrees celsius the temperature is good today go outside so with the not logical operator you can surround one or more conditional statements with the not logical operator and what this will do is flip it from being false to true or from true to false well everybody that's the basics of logical operators in python if you would like a copy of all this code i will post this in the comments down below but yeah that's the basics of logical operators in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain while loops in python so sit back relax and enjoy the show so while loops a while loop is a statement that will execute its block of code as long as its condition remains true later on in this video for this example we're going to create a program where we will prompt a user to enter their name if they attempt to skip that prompt then we will continually ask the user to enter their name and they can't continue on with the rest of the program until they do so the key thing to keep in mind with while loops is that you'll want some way to eventually escape the while loop if you don't have any way to escape the while loop that's referred to as an infinite loop so let's create an example of an infinite loop because it's fun so to create a while loop type while and then some sort of condition so for our condition let's say while one is equal to one so this will always be true now what do we want to do when we execute this block of code let's print something print help i'm stuck in a loop all right so let's try this while one is equal to one print this statement and we will just continue on and on within this while loop because we have no way to escape this while loop so now let's use this concept and write a program where we will prompt a user to type in their name if they don't type in anything then we will continue to prompt them to type in at least something so let's say name is equal to and then to just keep this blank we'll just set this to a set of quotes and then let's write a while loop here while name and let's check the length of name if the length of our name is equal to zero then we will ask the user to type in their name name equals input enter your name so then once we escape the while loop let's print something print hello plus name whoops hello plus name alright so when i run this we are giving the user a way to escape the while loop they have to type in something for their name as long as the length of my name is equal to zero keep on printing this prompt enter your name so i'm just going to hit enter a bunch of times enter your name no enter your name no enter your name no so we are stuck within this loop until we enter something for our name so this time let me type in a name then hit enter so therefore our condition is now false the length of my name is now one two three so three is not equal to zero therefore our while statement our while loop is false and we continue on with the rest of the program there are a few variations in which you could write the same program so let's write this a different way what we could do is say name is equal to none while not name and this will pretty much do the same thing it's just another way of writing this well everybody that's the basics of while loops a while loop is a statement that will execute its block of code as long as its condition remains true for our example we asked the user to type in their name if they were to leave it empty or blank we would keep on asking the user to type in their name so if you would like a copy of this code i will post this in the comments section down below but yeah that's the basics of while loops in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain for loops in python and at the end of this video we're going to create a countdown timer so sit back relax and enjoy the show all right guys and gals let's talk about for loops a for loop is a statement that will execute its block of code a limited amount of times it's similar but different from a while loop because a while loop could iterate an unlimited or infinite amount of times depending on the condition a for loop will only iterate a limited amount of times and before we start executing its block of code we already know how many times we're going to repeat this block of code so for this example let's create a for loop that will simply count it to 10 and then we'll create a few more sophisticated examples so to create a for loop that will count up to 10 this is what we'll type four and then we need some sort of counter people usually either write index or they shorten it to just i i for index four i in and we can set a range range ten so we will execute this for loop ten times and to finish this for loop just add a colon at the end so the next line or lines will be indented so that's the block of code for the for loop what do we want to do during each iteration let's just print what i is and let's take a look to see what would happen so we executed this for loop ten times except with computers computers always start with zero so when we said four i in range ten we're counting numbers zero through nine so it's as if this number is exclusive so there's two ways we can change this we could say range ten plus one or what i would do is say print i plus one so this will give us numbers one through ten so that's a for loop it will execute a limited amount of times this time let's count a range between two numbers not necessarily 0 to 10 but something else so let's say 4i in range maybe the numbers 50 through 100 so within my range function i will pass in two numbers the first number will be the starting point and the second number is the ending point this first number is inclusive and the second number is exclusive so let's print this print whatever i is so this will count 50 through 99 actually if you wanted to include this last number since it's exclusive what we could do is just add one to the end so this would give us 50 through 100 except that this will iterate 51 times since we're counting 50. so you just have to pay attention to your range and the numbers that it's counting now one thing that you can do with the range function is that you can add a third argument and this will function as the step how much you want to count up or down by so this time let's count up by two so i'll add comma two we're passing in a third argument this time so this program will now count up by two starting at fifty and go all the way to one hundred a benefit of for loops is that we can iterate through anything that is considered iterable this could include a string the letters in a string or any sort of collection so this time let's create a for loop that will iterate once through each letter in maybe a name so for i in and let's type a name here type in whatever your first name and last name is and then we will print whatever i is for i in whatever your name is print each letter in the string so when i run this each letter within my name will be printed to a new line all right people for my last trick we're going to create a program where we will simulate a countdown starting at 10 and count down to zero and then maybe once we reach zero we can print something such as happy new year so to create this program we'll need an import so at the top we're going to import the time module because we'll be waiting one second after each iteration of this for loop so to create this program let's say four you could say i but you can really write anything here and to demonstrate that let's say four seconds four seconds in range so the starting point is going to be ten the ending point will be zero and we'll add a step what do we want to count up or down by let's set this to negative one so this will be a countdown starting at ten and ending at zero so after each iteration let's print whatever i is or in this case seconds and then we can sleep have our thread sleep for a number of seconds too so after we print seconds type time dot sleep and pass in how long you want to sleep for i would like to sleep for one second and then at the end let's print happy new year make sure this isn't within the for loop print happy new year and well that's it let's test this so we'll begin at 10 and count down to zero and you can see that my thread that is running this program is sleeping for one second after each iteration of this for loop then once we reach zero it will display happy new year well everybody that's the basics of for loops a for loop is a statement that will execute its block of code a limited amount of times it's different from a while loop because a while loop could execute an infinite or unlimited amount of times with for loops they execute limited amounts of times and before we enter the for loop we already know how many times we're going to iterate this for loop if you'd like a copy of all this code i will post this in the comments down below but yeah that's how for loops work in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain nested loops in python so sit back relax and enjoy the show hey all you people let's talk about nested loops a nested loop is a general concept of having one loop inside of another loop and that's really it it doesn't matter if it's a for loop or a while loop so the inner loop will finish all of its iterations before we finish one iteration of the outer loop and to best demonstrate this we're going to create a program where we will draw a rectangle made out of a certain symbol that we choose we need to set a width and a height and to best do this we'll need to use a nested loop we'll create a few prompts one for rows columns and a symbol that we want to make a rectangle of so let's begin with rows rows equals input how many rows and we'll need to cast this as an integer data type because we're working with numbers okay let's do the same thing for columns so replace rows with columns for this next line input how many columns and we'll create a symbol variable symbol equals input and this we don't have to cast enter a symbol to use now it's time for the nested loops we're going to create an outer for loop as well as an inner for loop the outer for loop will be in charge of the rows the inner for loop will be in charge of the columns so let's begin by creating our outer loop so we'll write 4 i in range rows we would like our outer for loop to iterate as many times as we have rows and we're going to create an inner for loop that will iterate as many times as we have columns so within the block of code for the outer for loop we're going to create another for loop this time it'll be four and a common convention for inner loops is to write j as an index because j comes after i i guess so for j in range columns so our inner for loop will iterate for as many times as we have columns all we'll do within the inner for loop is print our symbol that we have except we'll have one issue using a print statement after we use the print statement we will enter a new line character and move down to the next line we can actually prevent that by adding comma and equals quotes so after using a print statement this will prevent our cursor from moving down to the next line so pay attention to the indentation too so there's kind of two levels of indentation we're currently within the inner for loop so that's pretty much it for the inner for loop now we're going to print a new line once we exit the inner for loop and you can see that the indentation is on this line right here we're within the outer for loop now and that's pretty much it so let's try this program how many rows let's say five rows how many columns perhaps six what symbol do we want to use let's say the dollar sign and let's try it there we go there's our rectangle so we have let's see six columns one two three four five six and five rows one two three four five in summary a nested loop is really just this concept of having one loop inside of another loop it doesn't matter if it's a while loop or a for a loop it's really situational the inner loop will finish all of its iterations before finishing one iteration of the outer loop so what we did to demonstrate that is that we had the outer loop in charge the rows and an inner loop in charge of the columns for our rectangle program so if you would like a copy of this program i will post this in the comment section down below but yeah that's the basics of nested loops in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain loop control statements in python so sit back relax and enjoy the show all right ladies and gentlemen let's talk about loop control statements these are used to change a loop's execution from its normal sequence and there are three we're going to discuss break continue and pass let's begin with break break is used to terminate the loop entirely now here's a good example of where a break would be useful let's say while true we're going to continually ask for somebody's name if they don't type in anything then we'll continue the while loop over and over again so let's say name equals input enter your name now if name does not equal a set of quotes that means they don't type in anything then we will break and break out of this while loop and let's test it enter your name nah i don't think so i'm too lazy to enter my name all right i can see that i'm not going to escape this while loop so i'm going to type in my name because i give up and hit enter therefore i will break and exit out of this while loop so a break is used to terminate the loop entirely when it's encountered next we have continue continue skips to the next iteration of the loop now let's say we have a phone number phone underscore number and i will set the sequel to let's say a random phone number including dashes 123-456-7890 what i would like to do is to display this number within the console window without these dashes this is how to do that using a continue control statement for i in phone number so for each character within our string of phone number what we'll do is check to see if we encounter a dash character if i i is our index is equal to a dash then we want to continue and skip over this iteration of the loop so continue then i would like to print whatever our indexes whatever character we're working on so if i were to run this as it is it's going to print each digit on a new line so with print statements they will add a new line character to the end of your string and you can actually change that by adding to the end comma end equals and then a set of quotes so this will print my phone number without any dashes one two three four five six seven eight nine zero so that's a use of the continue control statement it skips to the next iteration of the loop last but not least we have pass pass does nothing it acts as a placeholder let's say that i would like to print the numbers 1 through 20 using a for loop for i in range 1 through 21 and remember that the second digit is exclusive so this will iterate once through the digits of 1 through 20. let's pretend that i'm highly superstitious and i don't want to print the number 13 because 13 is considered an unlucky number if i is equal to 13 what we'll do is pass and pass acts as a placeholder and it won't do anything else print i that's one i there we go this will print the numbers 1 through 20 and skip 13 because we used the past control statement which does nothing it acts as a placeholder so everybody those are loop control statements they change a loop's execution from its normal sequence we have break continue and pass so if you would like a copy of all this code i will post all of this in the comments section down below but yeah those are a few loop control statements in python what's going on everybody it's bro hope you're doing well and in this video i'm going to explain lists in python so sit back relax and enjoy the show all right ladies and gentlemen let's get down to business i got to explain lists to you all now a list is used to store multiple items within a single variable for example let's say we have a variable called food and i will store a string value of pizza because i like pizza what we could do is that we can store multiple items within this variable by turning this variable into a list and in order to do so we're going to surround all of the values that we would like to add to our list with a set of square brackets and boom there you have it we now have a list called food it is no longer a variable so what we could do is add multiple items to this list of food so let's add some other food items that we might like let's see i also like maybe some hamburgers and a hot dog and maybe some spaghetti i think i smelled spaghetti right okay so we now have a list called food now what happens if we attempt to print this list of food so print food so this will print all of the elements found in this list each item in a list is referred to as an element if we need to access a certain element of this list we have to list the index so next to our list we'll add a set of square brackets again and we need to list the numbered index of the element that we're trying to access now computers they always start with zero so the first element in our list would be element number zero the next one would be one two and three so if we need to access element zero which is in the first position we would say food square brackets and then within here list the index so the first position is zero and this will now print the first element of our list which is pizza let's attempt to access some of these other elements so the element at index one would be you guessed it hamburger two would be hot dog and three would be spaghetti now what happens if we attempt to access the element at index four well currently that's out of range because we did not assign a value so we're experiencing an error an index out of range error but if i were to add another element let's say pudding alright well then the element at index 4 would be putting then one important concept with lists is that you can always update and change the elements found within a list later on in the program after you declare one so let's say we would like to immediately change one of these elements let's say food at index zero i want to replace with maybe sushi because sushi is great so if i were to print the element at index 0 this would no longer be pizza because we updated element 0 to be sushi then and this prints sushi now if you need to display all of the elements found within a list you can easily do so with a standard for loop what we'll do is say for x in the name of our list which is food print x and let me turn this line into a comment all right so this for loop will print all of the elements found within our list of food and the results are sushi hamburger hot dog spaghetti and pudding all right people for this next portion i'm going to demonstrate a few useful functions of lists and to access some of these functions type the name of your list dot and there's a bunch to choose from here let's begin with event we can add an element to this list let's say at the end i would like to add ice cream so then if i were to display my list we now have ice cream at the end because we appended this value to my list of food so let's go over a few others so we can also remove a value food dot remove let's say i would like to remove hotdog so i'm going to type that within my function and this will remove hotdog and that is no longer here next we can pop food.pop pop will remove the last element so this will remove pudding we can insert a value at a given index food dot insert we need to list an index let's say zero that would be the first position technically that's where pizza is currently and i would like to add cake and at index 0 we now have cake so next up we have sort food dot sort this will sort a list alphabetically so in the first position we have hamburger hot dog pudding spaghetti then sushi we can also clear a list food dot clear and this will remove all of the elements of a list so this will not print anything because we cleared the list well everyone in conclusion a list is really just a variable that can store multiple values think of it that way so if you would like a copy of all the code that we have written here today i will post all of this in the comments down below but yeah that's how lists work in python how's it going everybody it's bro hope you're doing well and in this video i'm going to explain 2d lists in python so sit back relax and enjoy the show i have a super quick video for you all today on 2d lists also referred to as multi-dimensional lists all it is is a list of separate lists so let's begin by creating a few separate lists let's say we have a list called drinks and let's assign a few values let's say we have coffee as well as soda and maybe some tea all right so we currently have one list let's make maybe two more let's make a list called dinner and maybe in here we'll place pizza then hamburger and hot dog okay then let's create one more for this example let's say dessert and maybe we'll add two items they all don't need the same amount of items or elements so we have cake and ice cream all right so we have three lists one called drinks dinner and dessert so what we can do is add all of these lists to one list and let's create a list called food food equals and for each of these elements we're going to place our lists so we have drinks dinner and dessert check this out what if i were to print my 2d list of food so what ends up happening is that this will print all of the elements found within each individual list and they're all grouped together so this first portion is my drinks list which contains coffee soda tea this next element is my dinner list which contains pizza hamburger hot dog and the last element dessert contains cake and ice cream if i need to access just one of these lists i will add an index after my food 2d list and set an index number so index zero is referring to my first list of drinks and this will display all of the elements found within my first list and if i need just one of these elements i will add a second set of square brackets and list the index of the item that i'm trying to access so this very first item coffee would be index zero and then index zero again so we need two sets of square brackets and if i were to print this this will display coffee so if i go down the list the next element would be soda and then t if i were to change the index within this first set of square brackets well now we're working with a different list this time we're working with our dinner list so the element at index 1 index 2 that would be our dinner list and this will display the element of hot dog if i change this to the next list which would be dessert well we're going to receive an index out of range error because we only have two values within this list cake and ice cream there is no element at index 2 because we only added two elements to this list of dessert all right everybody so that is 2d lists also referred to as multi-dimensional lists it's a list of separate lists if you need to access one of the elements within your 2d list you need two sets of square brackets so if you would like a copy of this code i will post this in the comments down below but yeah that's how 2d lists work in python hey what's going on people it's you bro hope you're doing well and in this video i'm going to explain tuples in python so sit back relax and enjoy the show so tuples they are collections which are ordered and unchangeable they're very similar to lists but they're ordered and we can't change them they're useful for grouping together related data let's say we would like to create some sort of student record so we can create a tuple to take care of that for us so let's say we would like to create a tuple called student the process of creating a tuple is very similar to lists but instead of using a set of square brackets to place all of the values within we're going to use a set of parentheses and now we can add a bunch of values related to this collection of student so let's add some student information let's say that this student's name is bro let's give him an age as well as a gender all right so there you have it we now have a tuple called student and let's take a look at some of the functions related to tuples and you can access them by typing student dot and then there are a few here not as many as lists we have count and we have index so we can find the count of how many times a value appears let's count how many times the value of bro appears so we'll need to put this within a print statement so we can actually see it so bro appears one time within this tuple there is also an index method as well so type the name of your tuple dot and we will use the index method we can find the index of a certain value let's say we would like to find the index of mail and then i will just print this to the console window so the index of the value mail would be at two zero one two that's it for the methods available to tuples a few tricks that you can do with tuples is that you can display all of the contents within a tuple using a for loop let's say 4x in student we will print x so this will iterate once through all the values found within our tuple of student and we can also check to see if a certain value exists within our tuple using an if statement let's say if bro in student if this is true then what do we want to do let's say print bro is here all right so since bro is within here this will be true and this will print our statement of bro is here all right everybody like i said this is a super quick video on tuples they're very similar to lists except they are ordered and unchangeable if you'd like a copy of all this code i will post all of this in the comments down below and don't forget to smash that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain what a set is in python so sit back relax and enjoy the show a set is a collection which is unordered as well as being unindexed they do not allow any duplicate values for example let's create a set of silverware so in order to create a set we need a name for this set let's call it utensils equals and in order to create a set we need to surround all values with a set of curly braces now let's add a few utensils to the set called utensils let's add a fork a spoon and maybe a knife and that should be good and let's display all of the values for x in utensils print x now with sets they're different from lists because they're unordered as well as being unindexed if i were to print all of the elements in utensils they might not necessarily be in the same order in which we placed them for example when we printed all of the elements found within utensils first we had a knife a fork and then a spoon if i were to run this again they might be in a different order kind of like that so a set is actually faster than a list if you need to check to see if something is within a set compared to a list and they do not allow any duplicate values let me add a bunch of knives and let's see what happens so i'll have a total of three knives but when we print all of the elements of the set only one knife appears so here's a few useful methods of sets the first method is that we can add an item to our set so type in the name of the set in this case it's utensils dot and here's a bunch of methods that you can use i am looking for add and we can add an element to the set i would like to add a napkin and then if we were to print the set we do have a napkin within the set we can also remove an element utensils dot remove and i would like to remove the fork and now our fork is gone we can also clear utensils dot clear and all the elements within our set should be gone so let me turn these lines into a comment all right for this next example we'll need a second set let's create a second set called dishes and then we need a set of curly braces and let's add a bowl a plate and a cup our next method is that we're going to add one set to another by using the update method let's say we would like to add our dishes set to our utensil set so let's type utensils dot and use the update method and within this method we will pass in the set that we would like to add so utensils update dishes this will add all of the elements found within dishes to our utensil set and you can see that when we print our utensils we have a bowl a plate and a cup in here as well and then if i were to switch these around let's say dishes update utensils and then i will print everything found within dishes now there's a fork a spoon and a knife in here as well we can also join two sets together and create a new set entirely so let's create a set called dinner table like we're setting up a dinner table and we need a fork a spoon a knife a bowl a plate and a cup so we have a dinner table set we're going to set the sequel to either utensils dot union dishes or we could do dishes union utensils either way would work and let's display all the elements found within dinner table and we should now have elements from both sets utensils and dishes as well there are also some methods in which we can compare the similarities as well as the differences between the elements found within two sets let's say i would like to check to see what utensils has that dishes doesn't and for this example i think i'll add a knife to my dishes set just so that they have at least one thing in common so i would like to see what utensils has that dishes doesn't so we can do so using the difference method and i will print the results with a print statement so i'm going to compare utensils against dishes utensils dishes and this will print what utensils has that dishes doesn't which is a fork as well as a spoon and we can reverse the rolls too we could say dishes difference utensils what do dishes have that utensils doesn't and dishes has a cup a bowl and a plate they both have knives so that's why knife isn't appearing we can also check to see if there's anything that they have in common using the intersection method so i'll turn this line into a comment we'll print utensils dot intersection dishes and this will return whatever element that they have in common which is a knife all right everybody in conclusion a set is a collection which is unordered as well as being unindexed they do not allow any duplicate values and you can do things like compare two sets see if there's anything that they have in common any differences and we can add or remove elements to a set if you'd like a copy of all this code i will post all of this in the comments down below don't be afraid to smash that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain how dictionaries work in python so sit back relax and enjoy the show all right let's get down to business a dictionary is a changeable unordered collection of unique key value pairs they're fast because they use hashing and they allow us to access a value quickly now to create a dictionary it's very similar to creating a set based on the last video except we're going to store unique key value pairs let's create a dictionary of countries and their capitals we can store those as key value pairs so let's call this dictionary capitals capitals equals then we need a set of curly braces much like what we use with sets now we need a key and a value let's say we have the usa as a key and the capital of the usa would be washington dc so in order to associate a value with the key we'll follow the key with a colon and then add some value and the data type really doesn't matter but in this case we're just using strings so the capital of the usa would be washington dc and to add another key value pair we'll separate each with a comma and let's add a few others for good measure so let's say we have india next as a key and the value would be new delhi and we'll add two more let's say we have china and the capital of china is beijing and lastly let's add russia and the capital of russia is moscow and there you have it ladies and gentlemen we now have a dictionary called capitals that has unique key value pairs so remember with dictionaries they are unordered in order to access one of these values instead of using a numbered index we're going to use the associated key with that value here's an example let's say i would like to print the capital of russia so i need to use this key of russia so in order to do this type in the name of the dictionary followed by a set of straight brackets and then instead of an index number like 0 or 1 2 3 i'm going to use the key so i would like to print the value that's stored or associated with the key of russia so when i run this this will print that value which is moscow so this isn't always safe let's say we have a key that doesn't exist like germany germany is not currently within my dictionary so if i were to run this well then my program is going to encounter an error and this will interrupt the normal flow of my program a much safer way to access a key to check to see if it's there or not is to use the get method of dictionaries so i'm going to turn this line into a comment and let's try this again but this time we'll use the get method so type in the name of the dictionary dot get and list the key that you want to use so i would like to see if germany is within my dictionary currently there isn't so this will return none and we will not encounter an error so this is a much safer way of checking to see if there is a key within your dictionary here's a few other useful methods there is a method to print only the keys so we type in the name of the dictionary capitals and here's a listing of all of the methods that we have access to i'm looking for the keys method and this will print only the keys and not the values we can also print just the values and not the keys so type in the name of the dictionary again capitals dot values and this will print only the values or you could print everything both the keys and the values and you do so by using the items method capitals dot items and this will print your entire dictionary one other way in which we can display all of the key value pairs in a dictionary is to use a for loop so at the end let's create a for loop for key comma value in capitals dot items this is going to iterate once for each key value pair in my dictionary for each key value in capitals dot items print key comma value and this will print my entire dictionary a feature of dictionaries is that they are mutable that means we can change them or alter them after the program is already running so one way in which we can do that is to use the update method of dictionaries so let's add germany as a key and give it a value of berlin so type in the name of the dictionary capitals and we'll use the update method and within the parentheses of this method we'll add a set of curly braces and now we can add a new key value pair so let's add germany and a value of berlin so if i were to run this and display all of the key value pairs found within my dictionary we now have germany as a key and berlin as its value not only can you use the update method to add a new key value pair but you can update an existing one let's say we would like to change the capital of usa so capitals dot update parentheses curly braces list the key usa colon and then we can give the usa a new value let's pretend that the united states government has decided to relocate their capital to las vegas so this will now update our key of usa with a new value and if i were to print all of the key value pairs found within my dictionary of capitals the usa has a new value of las vegas so the last two methods i'm going to cover are both pop and clear you can use the pop method to remove a key value pair so capitals dot pop parentheses and list the key of the key value pair that you would like to remove so let's say we would like to remove china so we'll list that key and then when we use the pop method that will remove this key value pair from my dictionary and then of course we have clear as well which will just remove everything capitals dot clear and this will clear my dictionary all right everybody so in conclusion a dictionary is a changeable unordered collection of unique key value pairs they're fast because they use hashing and they allow us to access a value quickly well that's the basics of dictionaries in python if you would like a copy of all this code i will post all of this in the comments down below but yeah that's how dictionaries work in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to teach you guys all about the index operator in python so sit back relax and enjoy the show all right people let's begin i'm going to be explaining the index operator which is represented by a set of square brackets now they give access to a sequences elements they include but are not limited to strings lists and tuples for this example we're going to be working with strings because strings are easy to work with let's say we have a name and name equals whatever your first and last name is we can use the index operator to access an element of the sequence our string so let's check to see if the first letter in our name is lowercase and i should probably change that to lowercase for this example so within an if statement if name and we can add a set of square brackets after our sequence which is a string and we can check a given element of our sequence let's check to see if the first letter is lowercase now with computers they always start at zero if you need to access the first element in a sequence that would be index zero and then the next sequence well the next element in the sequence would be one then two then you followed that pattern so i would like to check to see if name at index zero that would be the first character is lowercase so there is a method to check that dot is lower this will return true or false if the first letter is lowercase then our if statement is going to be resolved to true and what i could do is that i can perhaps change it to uppercase then so let's reassign name to equal name dot and there is a capitalize function here and then let's print our name print name so when we run this the first letter in my name is now capitalized so if you need to access an element within a sequence a string or list or a tuple you would add a set of square brackets afterwards and then you list an integer of the element that you're trying to access so here's a few other examples i'm going to turn this as well as this into a comment and let's say we would like to create some substrings and we can do so using our index operator so i would like to create a substring from the first part of my name so what i'll do is create a new variable first name equals name index operator so you can specify a range for an index operator so you would set the starting position on the left hand side followed by a colon and then your ending position so i would like the substring to begin at index 0 and end at 3 so that would be 0 colon then three all right and then i would like to make this all uppercase for some reason and then let's print my first name so with the index operator we specified a range we would like to access elements 0 through 3. turn them up your case and assign them to a new variable of first name here's a shortcut that you might find useful if the index for your range begins with zero you can actually delete that you don't even necessarily need that zero now we just have a colon three and this would work the same as it did before so that's a useful shortcut and we're going to bring it up later if we need to access the last element in a sequence this time let's create a substring of last name so last name equals name index operator this time i would like to access the element at index let's see 0 1 2 3 4. all right so i'm going to say for colon and we're not really sure where our name our last name is going to end so what you could do is just say colon and then leave the next index blank so that will be the index beginning at four and everything afterwards and let's say two lower to make this all lowercase for some reason so let's print our last name print last name so this should take everything starting at index 4 and after that and turn it into its own substring of last name now you can access the last element in a sequence by using what's called negative indexing so let's add a exclamation point to the end of our name so let's say we have a new variable called last character and i would like to store the last character in my name to this new variable this new substring so to access the last element in a sequence within the index operator we can use negative indexing so the last element would be negative one all right and then let's print whatever our last character is so this should print an exclamation point yep which did so then if this was negative 2 that would be the second to last element in a sequence so now that would be e because e is in the second to last element in my sequence all right everybody so that's the basics of the index operator you can add a set of square brackets after a string a list or a tuple and then list an integer or a range of the elements that you're trying to access so if you would like a copy of all this code i will post everything in the comments down below don't be afraid to help me out and smash that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain how functions work in python so sit back relax and enjoy the show if you find this video helpful please remember to like comment and subscribe your support will help keep this channel running okay let's do this thing a function is a block of code which is executed only when it is called this process is also known as invoking a function with programming we try not to repeat code if we don't have to that's why functions are useful because our function can perform some specific task for us some block of code for us whenever it is called so we only need to write that block of code once and if we need to repeat it we just call this function one more time so let's define and create a function we'll create a function called hello and in order to define a function we'll type def and then a unique function name so let's call this function hello and with functions they always end with a set of parentheses and lastly to finish defining this function we'll add a colon at the end so if you go down to the next line take notice that my cursor is now indented any code underneath a function that is indented belongs to that specific function and will only execute whenever that function is called so for now we need to type in something if you don't know what you want your function to do you can always type pass for now but let's print something print the word hello and in order to call this function all we need to do within our program is type the name of the function which is hello and then add a set of parentheses because functions always end with a set of parentheses so what this will do is execute my function once and perform this block of code whenever it is called if i were to remove this well our program currently isn't going to do anything because functions only execute their block of code only when it is called so this time let's print the word hello three times so i will call this function three separate times hello hello hello so when i run this our hello function will be called three separate times now with functions they are not limited to just one line this is an entire block of code so maybe we can do something else too let's print have a nice day now if i were to run this my hello function is going to execute this entire block of code three separate times hello have a nice day now an important feature of functions is that we can send our function some information and our function can do something with that information that it receives let's say this time i would like to print hello plus somebody's name currently name is an unresolved reference what we can do when we call this function is send our function some information this can be a value a variable a collection all sorts of different things so if you need to send your function some information within the parentheses when you call that function just list the data that you want to send your function so let's say i would like to send my function a string value of bro whatever your first name is when you send information to a function these are called arguments they are the information that you're sending to a function and when you define that function you need a matching set of what is known as parameters so our hello function is going to receive one argument a string value we need a matching number of parameters currently this isn't going to work you can see here that hello takes zero positional arguments but one was given our function needs a matching number of parameters so think of it this way when we receive this value we're going to give a nickname to this value so when we receive the string value what do we want to call it well let's call it name so in order to add parameters to your function just list the parameters within the parentheses of that function and well this should work now we have a matching set of arguments and parameters when we call the hello function this time we are sending one argument over and when our hello function receives this argument we're going to give it a temporary nickname of name or you can call this whatever you want to and then we can use this value for whatever we want within our function now if we were to run this this will print hello bro have a nice day now i can send maybe a different value let's say hello and then i will send a string value of dude hello dude have a nice day so this isn't limited to just values we can send variables to let's say we have a variable called name equals bro and this time i'm going to send this variable over hello and then send name so these don't need to be the exact same let's say this is my name and i'm going to send my name over and i will temporarily give this value a nickname of just name and then i can use this variable for something hello bro have a nice day now with arguments you can send more than one value over let's say this time i would like to send two values over so let's send pro maybe for a first name and code for a second name but you can use your first name and last name so this isn't going to work because we do not have a matching set of arguments and parameters we're sending two arguments over but our function is only designed to accept one argument because we have one parameter so let's rename name as first name and we need two parameters this time so what are we going to call this value when we receive it let's call this last name so this time we are going to receive two values they will be nicknamed first name and last name so this time let's print hello first name maybe i'll add a space plus last name and this is now valid hello bro code have a nice day with arguments you can mix and match the data types that you're sending as arguments so currently we're sending two string values as arguments this time let's send an integer value let's say we would like to send an edge over to our hello function so i'll just send maybe the value of 21. so currently this isn't going to work because the hello function takes two positional arguments but three were given when we call this hello function we're sending this argument over but our function doesn't know what to do with this argument so we need a matching parameter for this value that it receives so let's call this value maybe edge as a temporary nickname and then we can do something with this value when we receive it so let's print an additional message perhaps u r plus age plus years old so if you need to display an integer or number along with the string you do need to convert it to a string so let's just cast our edge as a string when we display this so this should work now we now have a matching number of arguments and parameters so this will display hello bro code you are 21 years old have a nice day so ladies and gentlemen in conclusion a function is a block of code which is executed only when it is called if i were to remove this function call well then our program is just going to completely ignore this function and this block of code would not be executed when we call this function we can pass information known as arguments but we need a matching number of parameters set up to receive these arguments there are a few advanced features of parameters but i'll hopefully get to that in future videos we'll just stick with the basics for now of functions so that's the basics of functions if you would like a copy of this code i will post this in the comments down below but yeah that is how functions work in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain the return statement in python so sit back relax and enjoy the show all right people let's begin the return statement is used within functions to send python values or objects back to the caller these values or objects are known as the function's return value so do you know how with functions we can pass arguments to a function and then our function can do something with those arguments well not only that but our function can pass some value or object back to the caller so what we'll do for this example is create a function that will simply multiply two numbers together and return the result back to the caller so let's define a function called multiply and we'll set up two parameters for this function let's say number one and number two and what we'll do is say result equals number one times number two and then at the end we can return something what do we want to return let's return whatever the result is now when we call this function we will pass in two values as arguments let's say we would like to multiply six times eight so when we run this well we can't actually see anything when we return the result after multiplying numbers one and two it's going to return the result back to the caller in order to see the value that is returned back to the caller one way in which we can do this is to print the value that is returned within a print statement so what we'll do is print the value that is returned after calling the multiply function so 6 times 8 is really great 6 times 8 is 48 now one other thing that we can do is store the returned value within a variable so let's say x equals multiply 6 times 8 and then we will print whatever x is so the result is still the same of 48 now with the return value there is another way in which we could write this that uses less lines of code so we'll delete this first line and instead of returning a variable called result what we'll do is just return number one times number two and this would work the same as it does before but it's written in less lines of code so that's another way in which you could write this all right everybody so that is the return statement functions can send python values or objects back to the caller these values or objects are known as the functions return value you can either print this value directly to the console window or you can store it within a variable or some other location and well ladies and gentlemen that is how the return statement works in python what's going on everybody it's bro hope you're doing well and in this video i'm going to explain keyword arguments in python so sit back relax and enjoy the show all right everybody let's discuss keyword arguments these are arguments that are preceded by an identifier when we pass them to a function the order of the arguments doesn't matter unlike positional arguments which do matter and we've been working with positional arguments already and python knows the names of the arguments that our function receives when we use keyword arguments here's an example of us using positional arguments and then i'll demonstrate the benefits of keyword arguments let's say we have a function called hello that accepts three arguments a first name a middle name and a last name and the output will be hello first name middle name last name so if i were to run this this will display hello bro dude code so we're using positional arguments the order of the arguments does matter what do you think's gonna happen if i were to replace some of these values let's say i will swap the first argument with the third argument so let's try it again hello code dude bro so obviously the order of the arguments matters and now if we were to use keyword arguments then the order of the arguments doesn't matter but with each argument we need to precede each argument with a unique identifier and that identifier is the name of the parameter we want to associate each argument with so for my intended last name i will use an identifier of last to match this parameter so dude will be middle middle equals dude and bro will be first even though they're not in the correct order so let's try this again and my output is hello bro dude code so that's all about keyword arguments they are arguments preceded with an identifier when we pass them to a function the order of the arguments doesn't matter unlike positional arguments which do matter and then python knows the names of the arguments that our function receives when we use keyword arguments so that's it for keyword arguments if you would like a copy of this code i will post this in the comment section down below but yeah that's how keyword arguments work in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain nested function calls in python so sit back relax and enjoy the show all right people nested function calls these are function calls inside of other function calls and this is possible because certain functions will return a value and we can immediately use that value as an argument for the next function so here's an example let's say that we have the small program where we will ask a user to type in a whole positive number and let's say i don't let's say i type in negative 3.14 and then i'm storing that value within a variable named num what i'm going to do is convert that number to a floating point number because currently it's a string when you accept user input i will find the absolute value of num and then round it to the nearest whole number and then print the value so we can actually do this using less lines of code with nested function calls so let's start with the first function which will be accepting some user input the input function so this will be in the very center of our nested function calls and then the next function we would like to apply to the variable that is returned the value that is returned we will pass in as an argument to our next function of casting this data type to a float so we'll surround our function with another function and use the float function and then we'll just keep on adding layers to this so we have the absolute value function next so we'll add another layer and we have the round function so we'll add a layer to that and lastly we're going to print and that'll be the outermost layer so this program will do the exact same thing let's say negative 3.14 except we've written this with one line of code so basically we start with the innermost function and resolve that first whatever value is returned we use as an argument to the next outermost function and in this case it would be float then we resolve that then move on to absolute value then round and then print so it's just another way of writing code that takes up less lines but this is more of an extreme example you probably won't see like four or five nested functions well everybody those are nested function calls if you would like a copy of this code i will post all of this to the comment section down below but yeah those are nested function calls in python hey what's going on people it's your bro hope you're doing well and in this video i'm going to show you how variable scope works in python so sit back relax and enjoy the show all right let's do a thing people let's discuss the scope of a variable now the scope of a variable is the region that a variable is recognized a variable is only available from inside the region that it is created let's say that we have a function and i just gave this function a name of display name i created a variable inside of this function named name and you can assign this a value of whatever your name is preferably a last name for this example and what i'll do is just print whatever my name is so this variable is known to have a local scope because it's declared inside of a function and a variable is only recognized inside of the region that it is created this variable of name since it's created inside of this function it is known as a local variable that has a local scope it's only available inside of this function that it's created now let's attempt to access this variable from outside of our function so i'm going to print my name variable but we'll have an issue though so name name is not defined so local variables are declared inside of a function and they have a local scope they are only available inside of this function in which they're created on the other hand a global variable is a variable that is declared outside of any function but within your module that you're working with a global variable is known to have a global scope they are available inside and outside of any functions now if i was to print my name variable this is going to print bro or whatever your first name is and it is entirely possible to have both a global and local version of the same named variable so we have both a global version of name as well as a local version of name if i was to print my name variable from outside of this function it's going to print my global version however if i print my version of name inside of that function in which it's created we're going to first use the local version before the global version of name and let's try that so i'm going to call my display name function and this will print my last name code and then my first name of bro so it is possible to have a global and local version of the same named variable now if i was to remove this line where we declare a local version of name well then the next best available name to us would be the global version of name so if you use a variable inside of a function you'll first use a local version of that variable if it's available if not you'll use a global version instead and python will follow this rule known as the legb rule you use any local variables first then enclosed variables then global and then any built-in variables in that order so that's the main difference between local scope and global scope the scope of a variable is the region in which it's available and it's limited to the region in which it's created a local scope is available only inside of the function in which that variable is created a global scoped variable is a variable that is available inside and outside of any functions but within your module that you're working with so that's variable scope in python if you would like a copy of this code i will post this code to the comment section down below and well yeah that's how variable scope works in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain the arcs parameter in python so sit back relax and enjoy the show all right guys and gals let's talk about args now args is a parameter that will pack all arguments into a tuple it's useful so that a function can accept a varying amount of arguments here's an example of why it would be useful let's say we have a function called add that will accept two numbers as arguments and add them together and return the sum so this works as intended right as long as we pass in only two numbers but what if we need to pass in three numbers as arguments well we can no longer use this add function because we have two parameters set up but we're passing in three arguments you can see here within my console window that we have a type error add takes two positional arguments but three were given and one way in which we can solve this issue is to use this args parameter so what we're going to do is replace all of our parameters with asterisk args and actually the args portion isn't as important as the asterisk args is short for arguments and you can really name this whatever you want just be sure that you have this asterisk because with this asterisk we're doing a form of packing what we're doing is passing all of these arguments and packing them into a tuple so let's rewrite this program so let's say maybe sum equals zero and then we will need to iterate through all of the items within our tuple because tuples are iterable so let's say for i in args what we'll do is say sum plus equals whatever i is and at the end when we escape the for loop we will return our sum so let's try it again and see if it works well would you look at that it works let's pass in a few other arguments for good measure let's pass in six arguments this time all right look at that this does in fact work so you can actually name this whatever you want the important thing is to have this asterisk so let's rename this as i don't know stuff and let's try this again yep it still works with tuples they are ordered and unchangeable let's attempt to edit one of these values so let's say stuff at index zero is equal to zero and let's try and change it so you can see that tuple object does not support item assignment if you need to change one of the values within your tuple after you pack all of these arguments you might need to convert this to a different collection one way in which we can do that is to cast it let's say stuff equals and we'll cast our tuple as a list because a list can be changeable it's mutable so let's attempt this again we'll cast our tuple as a list and then edit one of the values and then add all the values together so to change one of the values say the name your collection stuff in this case let's say at index zero this now equals zero so now if we were to add all these items together they should equal 20. there we go so yeah that's basically the args parameter the name isn't as important as the asterisk because you can really name it whatever you want a common convention is to just name this args it's a parameter that will pack all arguments into a tuple it's useful so that a function can accept a varying amount of arguments well that is all about args if you would like a copy of this code i will post this in the comments section down below but yeah that is how the args parameter works in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to be explaining quarks in python so sit back relax and enjoy the show all right everybody let's talk about quarkx now this is a parameter that will pack all arguments into a dictionary it's useful so that a function can accept a varying amount of keyword arguments it's identical to args except with args args will accept a varying amount of positional arguments and pack them into a tuple with quarks this will accept a varying amount of keyword arguments and pack them into a dictionary so here's an example of why this would be useful let's say we have a function called hello that accepts two keyword arguments a first name and a last name all this will do is output hello your first name and last name but what if somebody has more than two names let's say somebody has a middle name and for this example i'll just say my middle name is dude so if i were to run this well this hello function is no longer going to work as you can see in the console window we have a type error the hello function got an unexpected keyword argument middle one way in which we can solve this we can use this quark's parameter so we can accept a varying amount of keyword arguments so what we'll do is replace our parameters with two asterisks then quarks now if i would like the same output as i had before i'm going to need to change a few things around in order to access a value within a dictionary you type the name of the dictionary square brackets and then within quotes list your key so i would like to access the value at this key of first and let's repeat the process for last name so the key is going to be last we'll access this value at this key and this should work the same as it did before now let's take this a step further let's say we would like to display somebody's full name based on the amount of keyword arguments that they pass into this function well there's a few different ways in which we could do this one easy way is that we could write our program like this let's print the word hello and we will need to iterate once through each key value pair within this dictionary and we can use a for loop to do that so to iterate once through each key value pair in your dictionary we'll type for key value in the name of our dictionary quarks in this case dot items and then we will print each value so there's one more thing that we need to do this kind of works as intended but it's going to print each value including our word hello on a new line so with a standard print statement this will print a new line character after each print statement as if we're hitting enter we can actually change that so after your string add and equals and we can replace that new line character with something else maybe a space and let's do the same thing for our for loop so value comma end and then just add space now this will print all of your names on the same line hello bro dude code and now we can pass in a varying amount of keyword arguments based on how long our name is perhaps we have like a title title equals mr and we can print that as well hello mr bro dude code here's a fun fact of the day you don't necessarily need to name this parameter as quarks the important thing is to have these double asterisks that precede it quarks is just a common naming convention it's short for keyword arguments you could name this as something else perhaps something more descriptive like names since we're passing in a bunch of names so the name of our dictionary is now names and this would work the same as it did before the important thing is to have these double asterisks that precede the name of your dictionary but quarks is the common naming convention well everybody that's all about quarkx it's a parameter that will pack a varying amount of keyword arguments into a dictionary if you would like a copy of all this code i will post this in the comments section down below but yeah that is how quarkx works in python hey what's going on everybody it's your bro hope you're doing well and in this video i'm going to teach you guys all about the format method in python so sit back relax and enjoy the show okay ladies and gentlemen let's begin the format method is a method available to strings it's optional and it gives users more control when displaying output to best demonstrate this i'm going to use a line from a popular nursery rhyme titled hey diddle diddle because well you know i'm a mature adult like that i'll be printing this line to my console window the cow jumped over the moon let's do so using a standard print statement and then i'll show you the benefits of using the format method later for this example i have two variables a variable called animal and i'm going to store a string of cow and item and i'll be storing an item name which is moon when we compile and run this as you would expect the output is the cow jumped over the moon there's a more elegant way of writing this line of code and that is by using the format method available to strings i'm going to turn this line into a comment and we're instead going to produce the same output but use the format method instead so we need a standard print statement like usual and then a string that we would like to format so we're going to write the same thing but in place of the variables we're going to add a placeholder the instead of the variable name or value name i'm going to add a set of curly braces so that functions as a placeholder for a value or a variable the this should be cow jumped over the and i'm going to insert another placeholder now this is a string we can format the string by following this string with dot format parenthesis and within the parentheses of the format method we can insert some values or variables let's begin with some values i would like to insert cow as well as moon so this will produce the same output but it's written a little more elegantly we can also replace these with variables because they store these values so i'm going to replace cow with animal and moon with item and this will create the same output as it did before these curly braces are what's known as format fields they function as a placeholder for a value or a variable and they work in order the first format field will insert the first value at this location if you have another set or more sets of this format field you'll insert the next value that's listed within the format method so if we were to switch these around we'll switch the position of animal with item well then the first format field is going to insert our item and the second format field will insert our animal this time the moon jumped over the cow an additional way of inserting values at a given place holder would be to use what's referred to as a positional argument within these format fields we will list the index of the value that we would like to insert at this location if you need to insert the first value well that has an index of zero because computers always start with zero and following that pattern the next index would be one if you had let's say three values that you need to insert if you had another placeholder that would be two then so you would just follow that pattern so there's going to be no visible change but what we could do is reverse the positional arguments of these placeholders so what do you think would happen if i switched one with zero at these locations well this format field is going to insert the value found at index one this first value is index zero and the second one is index one so now the roles are reversed this time the moon jumped over the cow our last way of inserting some values at a given format field would be to use what's referred to as a keyword argument within the format method we're going to list some keyword argument pairs we need a keyword name followed by a value so let's say animal is going to be the keyword we're going to say equals some value animal equals cow and item equals moon and you may have noticed that the color of your text might have changed so we no longer need these variables actually um but i'm going to comment out these two print statements because we will get an error then so these are in keyword argument pairs and within our format field instead of keeping these empty or using an index we can use the keyword name at my first format field i'm going to insert my keyword of animal and at my second format field i would like to insert the item keyword so the result is going to be the cow jumped over the moon so let's reverse these now we'll place our item keyword here and then at the second format field we will insert our animal and this time the moon jumped over the cow here's an important concept that i'd like to bring to your attention with these values found within the format method you can actually reuse some of these more than once so let's say we would like to state the animal jumped over the animal we're going to use this animal keyword twice and our output is going to be the cow jumped over the cow if we're doing the same thing with positional arguments we can reuse the same index this time let's say that the moon jumped over the moon so our item has an index of one so within our first format field we'll state the index will be one and our second format field will also be one so our output's going to be the moon jumped over the moon all right let's take things up a level there's an even more elegant way in which we could write all of this what we'll do is store our string that we would like to format within a variable let's turn this line into a comment and let's create a variable called text text equals the string that we would like to format which is the format field jumped over the format field and if we need to format this variable we can just call the format method on it so within a print statement let's say text dot and then use the format method and pass in the values that we would like to insert at these placeholders so we're going to insert animal as well as item so our result as you would imagine is the cow jumped over the moon this next section i'm going to explain how we can add some padding to a string when we display it using the format method let's say we have a name variable and assign this a value of whatever your name is so i would like to display my name along with the custom message let's say hello my name is and then i'll use a format field here so let's follow this string by using the format method and i would like to insert my name at this location so currently this will display hello my name is bro or whatever else your name is so we can add some padding either before our name after or we can add some padding to the left and the right hand side of our value that we have so what we'll do to begin is let's add some padding to the right hand side of our name that we have so within our format field if we need to add some padding within the format field add a colon and then the amount of space you would like to allocate to displaying your value so let's say 10 so i'm going to allocate 10 spaces worth of room to display my name you can't really see it right now but let's take a look so i can't move my cursor past this line at the end of my name but with my second line i have all of this room to work with so if i were to change my string that i have let's say nice to meet you well then all of this padding that i have is going to be more evident so we can add a number preceding with a colon to add some padding to a value and then you can left align this right align it or center align it so what i'll do is copy this line that i have if you need to left align it you use the less than sign but there's going to be no visible change because that's already the default if you need to write a line precede your number with a greater than sign so your value is going to be right aligned if you need to center this value then use the carrot so this will center align your value within the padding that you have allotted one question that you might have for me and i'll try and answer that now because it's relevant what if we need to add a positional argument or a keyword argument to our format field if there's already some text within here so what you would do before the colon you would just precede the colon with either your positional argument or your keyword argument followed by colon and then whatever you want to add afterwards to format your value that you have alright ladies and gentlemen we are near the end and i promise that this is the last section how can we format some numbers let's say we have a number variable and this will equal the first few digits of pi 3.14159 let's pretend that we would like to display only the first two digits after the decimal so we can do so using the format method let's print the number pi is and then i'll use a format field here and we will call the format method and insert our number that we have so if i need to display only the first two digits after the decimal within the format field i will add colon dot to f f is for floating point numbers that's anything with a decimal portion so the result is that this will display only the first two digits after my decimal because we placed two within the format field so if this was three point three f this would display three digits after the decimal portion oh and apparently this will round your number so that's something that you should keep in mind so this time let's change our number to something larger like 1000 and i will copy this line and make a few changes let's say the number is and i would like to add a comma at the thousands place so after the colon within the format field i will add a comma so this will automatically add a comma to all 1000s places another cool thing that you can do is that you can display your number as binary so within the format field add colon b this will display a binary representation of your number you can do the same thing with octal by adding colon o so our number is now being displayed as an octal number and you can do the same thing with hexadecimal lowercase x for lowercase or uppercase x for all uppercase so my number 1000 is now in hexadecimal and lastly we can display this number in scientific notation using either lowercase e for lowercase or capital e for uppercase and mynumber 1000 is now in scientific notation all right everybody so that's a few things that you can do with the format method it's an optional method that gives users more control when displaying output if you would like a copy of all the code that we've written here today i will post everything in the comments down below don't be afraid to smash that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain a few useful methods of the random module so sit back relax and enjoy the show okay people in this video i'm going to explain how we can generate some random numbers as well as a few other useful methods of the random module now we're not going to be creating true random numbers but something called pseudorandom numbers which are fairly darn close so the first step is to import the random module at the top import random we now have access to everything that the random module has to offer let's begin by generating a random number between one and six like we're rolling a dice so what i'm going to do is say x equals random dot rand and we can generate a random integer between a certain range if i want one through six i will state one comma six and then we can generate a random number between one and six like we're rolling a dice so if i were to print the value of x then we will get a random number between one and six for example i just got a one a two a three and a six all right we can also generate a random floating point number two let's say y equals random dot random so this will give us a random number between 0 and 1. this time i'm going to print y so we have 0.49 and some change 0.145 and 0.858 we can also generate a random choice from a list or other collection let's say we're playing a game of rock paper scissors so let's create a list i'll just call this my list equals square brackets and we will have three choices rock paper and scissors so let's say z will be the random string that we generate z equals random dot choice and we will pass in my list and let's print z so this will generate a random choice from my list called my list so we got scissors paper and rock we can also use the shuffle method of the random module to shuffle a list or other collection let's say we're working with a deck of cards cards equals let's say one through nine and we have a jack a queen a king and an ace this won't be a full deck of cards it'll just be one suit so we can actually shuffle this list by using the shuffle method random dot shuffle what do we want to shuffle we want to shuffle our cards and i will display my cards with a print statement so the shuffle method will shuffle a list or other collection for you well everybody that's a few useful methods of the random module if you would like a copy of all this code i will post this in the comments down below don't be afraid to smash that like button drop a comment down below and subscribe if you'd like to become a fellow bro hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain exception handling in python so sit back relax and enjoy the show well everyone let's talk about exceptions an exception is an event detected during execution that interrupts the normal flow of a program here's a program that i've written and we're intentionally going to cause an exception so this program that i've written we will accept a numerator and a denominator from the user we'll divide the numerator by the denominator we'll get a result and print the result so what if i were to divide a number such as 5 divided by 0 which we cannot mathematically do well this will cause an exception an event detected during execution that interrupts the flow of a program so our program was interrupted and within our console window we have this traceback message which states what went wrong and a name for this exception that occurred this specific exception that occurred is a zero division error so this video is all about handling these exceptions so they do not interrupt the normal flow of a program now a very basic form of exception handling is to surround any code that is considered dangerous as in it might cause an exception within a try block anytime you accept user input would be a good indicator too so this code is considered dangerous because we don't know what the user is going to type in so we will try all of this code if an exception occurs we can catch it and handle it so to do that we'll add an accept block accept and then we will catch exception normally having this block by itself isn't considered good practice but i'll explain why later so this accept exception block will catch all sorts of different exceptions and it will prevent our program from being interrupted and we can do something else entirely such as print a message something went wrong so let's try this again we will divide five by zero which we cannot do we no longer have that traceback message within our console window we caught the exception and we did something else we printed something went wrong like i said before it's not considered good practice to have a single accept block that will handle all exceptions it's much better to first handle specific exceptions when they occur and we can do so by writing additional accept blocks so let's create an additional accept block that will catch any zero division error exceptions that occurs when somebody attempts to divide by zero so if this exception occurs how do we want to handle it let's just print the message let's print you can't divide by zero idiot and let's try this again so five divided by zero you can't divide by zero idiot here's another one i'm going to turn this accept block into a comment so we can take a look at something what if i divide by something that's not a number like we take 5 and divide it by the word pizza well pizza is not a number and we ran into a value error exception so we should probably handle this too so let's create another accept block that will handle that accept value error and how do we want to handle this let's print something enter only numbers please okay let's try this again and see if this exception is caught five divided by the word pizza enter only numbers please not only that but you can also add the accept exception block at the very end just in case there's something you won't anticipate but it's always considered good practice to first catch any specific exceptions and let the user know exactly what went wrong an additional way in which we can handle these exceptions is that we could display the exception that occurs although it is completely optional so to do that what we'll do is that after each of these accept block definitions let's add as e so we're calling the exception as e that's just standard practice although it's not necessary so let's do that for each of these except blocks and then we can print whatever e is so let's add that to each of these blocks so it should now look something like this so when we encounter an exception we can display what exception occurred too as well so let's divide five by pizza invalid literal for int with base 10 pizza enter only numbers please so like i said this is an additional way in which you could handle an exception although it's entirely optional another thing that you can do is that you can add an else statement to the end of your accept blocks so what's happening here is that we're going to try all of this code if an exception happens then catch it and handle it if not then do something else so why don't we print our result only if there are no exceptions that occur so if there are no exceptions we will execute this else statement if not then we won't so let's divide five by an actual number this time like two so there are no exceptions that occurred so we executed this else statement whatever code is within our else block and this printed the result of 2.5 but if an exception were to occur like we divide 5 by 0 then we will catch our exception and handle it and we do not execute whatever block of code is within our else statement there is one other clause that you should be aware of that is the final clause this is always at the end how this works is that whether or not we catch an exception we will always execute any code that is within the block of code for our final clause so this is a good opportunity if you open files to close them within the finally block but we haven't dealt with opening files yet so we won't do that all we'll do is just print something print this will always execute so whether or not we encounter an exception this finally block will always execute at the end so let's try this again so this time let's cause an exception let's divide five by zero you can't divide by zero this will always execute and this time let's take this seriously and divide five by another number such as three so this will give us a result and like i said the finally clause the code within the finally clause will always execute but we won't really be working with this until we get to the section on file handling well everybody those are exceptions in python they are events detected during execution that interrupt the flow of a program and we can handle these exceptions by using try and accept blocks so if you would like a copy of all this code i will post all of this in the comments down below but yeah that is how exceptions work in python hey what's going on everybody it's bro hope you're doing well and in this video we're going to be covering some basic file detection using python so sit back relax and enjoy the show welcome ladies and gentlemen to the beginning of a mini series involving doing stuff with files using python and in this video we're going to be doing some basic file detection and in order to do so i recommend importing the os module it's already included with the standard python library all you need to do is import it all we'll be doing is checking to see if a file exists someplace on our computer so we'll probably need a file to work with what i'm going to do is go to my desktop for convenience and just create a new text document i will call this test.txt now i probably need the file location so i'm going to copy that and then we can use this so let's create a variable called path that will include the path to the file that i would like to detect so that was test.txt now if you have backslashes in your file path you'll probably need double backslashes because that's the escape sequence for a backslash within a string so we now have this variable path that we can work with now i would like to check to see if this location exists on my computer so if os dot path dot exists and you can see that we can pass in our path as an argument so i will pass in my path and if this returns true if that location exists i will print that location exists so this will not tell me if this is a file or not we'll be covering that later else let's print that location doesn't exist all right so if this location exists this will return true if not this will execute our else statement that location exists so what if i were to delete this file and we run this program again that location doesn't exist now this won't tell you if the location you're dealing with is a file or not there is a separate function for that it is if os dot path dot is file what we'll do is pass in our path and print that is a file all right so let's create another file because i deleted the previous one test.txt it's in the same location let's run this again that location exists that is a file now what if this was a folder so i'm going to create a new folder i will call this folder i will delete my test document and let's change the location to folder that location exists but it is not a file you can check to see if a location is a directory so let's write an else if statement os dot path dot is directory and we will pass in our path and let's print that is a directory all right so we have our folder we're going to check to see if this location exists and if it's a file or a directory that location exists that is a directory well everyone that is the basics of file detection we'll be building upon this concept in future videos so if you would like a copy of this code i will post this in the comment section down below but yeah that is the basics of simple file detection using python hey what's going on everybody it's bro hope you're doing well and in this video we're going to be reading a file in python so sit back relax and enjoy the show welcome back guys and gals in this video i'm going to explain how we can read the contents of a file using python so we'll probably need some sort of file to work with i created a plain text file called test.txt it's a plain text file and all this says is omg you can read this have a nice day like comment and subscribe so what i would like to do is to read the contents of that file line by line and print it to the console window and here's how and honestly we only need two lines of code to do this so what we'll do is type with open then within the open function list the name of your file or the file path this file of mine is within my project folder so i only need to list the file name if this was someplace else you'll probably need the file path so let's say this was on my desktop well i'll probably need to list the file path of where that file is located and i'll need to use double backslashes because that's the escape sequence for a backslash but since this file is within my project folder i only need to list the file name so with open then the name your file or the file path as file then what we're going to do is print file dot read and that is it so let's test it and it works omg you can read this have a nice day like comment and subscribe so this will actually close files automatically after opening them so that's kind of convenient and let's just test that theory so i'm going to print file dot closed if my file is in fact closed this will print true if it's still open this will print false so normally when you read a file it's normally open and you need to close it manually but if you write your program this way with open this will close the file automatically for you so using with open will close any files automatically for you after they've been opened however this does not catch and handle any exceptions that might occur like if we cannot locate this file so let's say that i mistyped the extension for this file let's say that i type in test.tx that's kind of funny because tx is the abbreviation for texas it's a texas file so this will cause a file not found error and this will interrupt the flow of our program and we would probably like to prevent that so what we could do is write a try and an accept block so we will try all of this code if we cannot find this file we can handle this exception file not found error so we'll place all of this code within the try block then if an exception happens we will catch that exception except we would like to catch any file not found air exceptions and let's handle this by printing that file was not found so if i were to run this again we will catch and handle this exception and this will not interrupt the normal flow of our program well everybody that's how to open and read a file in python if you'd like a copy of all this code i will post this in the comment section down below but yeah that's how to open and read a file using python hey what's going on everybody it's bro hope you're doing well and in this video we're going to be writing files in python so sit back relax and enjoy the show so to begin it's kind of similar to the last video on reading files with open within the open function list the file name or the file path so what do you want to call this file i will call this file test dot txt now normally with the open function there is a mode and you can actually change that there's a second argument that you can pass in by default this is r for read but if you want to write a file this would be w so now we're going to write a file called test.txt so to finish with open as file what are we going to do file dot write and within the write function we can write some text so let's create a text variable and we will add a string so let's say text equals yo and if you need to go down to a new line be sure to use the new line character so after this new line character the text that comes after is going to be on the next line as if we're hitting enter so yo this is some text have a good one all right so after i run this program we should have a file a text file within our project folder that appears and it is right here and it says yo this is some text have a good one now this is in write mode if this text was something else it will actually overwrite your current file so if i were to change this to uh oh this text has been over written well then this will overwrite the text that we have uh oh this text has been overwritten so you can actually append a file by changing the mode to a for append so let me change this back we will rewrite this this will save over our current file now we can append some text so let's add maybe a new line uh have a nice day see ya so i would like to append some text to this file i'm going to change the mode to a for append and we can now append some text onto the end of this file well everybody that's how to write to a file and or append a file if you would like a copy of this code i will post this in the comment section down below but yeah that's how to write to and or append a file in python hey what's going on everybody it's bro hope you're doing well and in this video we're going to be copying files in python so sit back relax and enjoy the show welcome back to another video regarding doing stuff with files using python and in this video we're going to be copying some files and in order to do so i recommend importing the shuttle module there's other ways of doing this too but i tend to like using the shuttle module now with this module there are three basic functions to copy a file starting at the top they are copy file copy and copy to so copy file is what we'll be working with this will copy the contents of a file copy will do everything that copy file does plus copy the permissions mode and the destination can be a directory and lastly copy 2 this will do everything that copy does plus it copies the metadata of that file including the files creation and modification times so depending on the project or the program you're working with you may need to use copy or copy too but in this video we're going to be using copy file just to copy the contents of a file now after you import the shuttle module this is all you need to do to copy a file shuttle dot then use the appropriate function that you need to copy your file we're going to be using copy file copy file and within this function there are two arguments a source and a destination so within my project folder i have a plain text file called test test.txt all this says is yo this is some text see ya what i would like to do is copy this file because it's cool now since this file is within my project folder i only have to list the file name otherwise if this is someplace else i would list the file path here so this file is test.txt this is the source file and now i need a destination so the second argument will be separated with the comma i'm going to list a destination so you can actually rename this to i would like to name this as copy.txt so the destination is my project folder so when i create a copy of this file test.txt this copy will appear in my project folder and say the same thing so after running this we now have a file named copy.txt that says the same thing as my test file and remember what i said you can copy this file to a different location on your computer so you could list the file path so this file path would go to my desktop and then when i run this this will copy my original file my source and then copy it to wherever my destination is oh and i almost forgot so if you need to use copy or copy 2 the arguments are exactly the same so if you needed to use copy this would be a shuttle dot copy instead of copy file then copy 2 is shuttle dot copy 2. the arguments are exactly the same but each of these functions will copy different things depending on what you need for your own program or project all right everybody so that's the basics of copying files and python i will post this in the comment section down below but yeah that is how to copy files using python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain how we can move files using python so sit back relax and enjoy the show welcome back everybody to another video regarding that thing that we do called programming and in this video we're going to be moving files using python and in order to do so i recommend importing the os module this is included with the standard python library all you need to do is import it and now let's create two variables a variable called source that will hold the location of where our source file is located as well as a variable called destination to function as well the destination now for this video i'm going to move a file within my project folder to my desktop so to do so i'm going to create a new file i will name this test.txt but take the liberty to name this whatever you want so i'm going to list the location of where my test file is located since this is within my project folder i only need the file name if this was someplace else on your computer you would probably need the file path and now where would i like to move this file to i would like to move this file to my desktop so i just need the file path so i'm going to go to my desktop right click go to properties i'm going to copy this location and paste it within my destination and i will add slash desktop slash test.txt you can also rename this too if you want i will just keep it the same now if you have single backslashes you'll likely need to change these to double backslashes because that is the escape sequence to print a backslash within a string so we have a source location as well as a destination location now we can begin i would recommend writing our code within a try and accept block to handle any exceptions so i would like to handle any file not found error exceptions just in case our program cannot locate our source file so let's print a message if that is the case perhaps source plus was not found now within our try block let's check to see if there is already a file at this destination because i would not like to save over it if there's already a file there so let's do some basic file detection if os dot path dot exists and i will pass in my destination as an argument to the exists function so if there is already a file here i should probably let the user know print there is already a file there else we can replace our files honestly if you do not care about saving over any files you can omit this part so else os dot replace and we will pass in our source and our destination as arguments and let's print a message to the console window to let the user know that source plus was moved all right let's try this oh i accidentally deleted my file test.txt all right now this should disappear in three two one and it's gone test.txt was moved and it should now be on my desktop which it is now you can also use this to move a directory as well i'm going to create a new directory i will name this folder and i will change source to folder and the destination from test.txt to folder and now this should move my folder there is already a file there oh let's delete that okay folder was moved all right everybody so that is how to move a file and or directory using python if you would like a copy of this code i will post this in the comment section down below but yeah that is how to move a file and or directory using python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to teach you guys how we can delete files using python so sit back relax and enjoy the show all right everybody so in this video we're going to be deleting files using python and in order to do so i recommend importing the os module this is already included with the standard python library all you need to do is import it and now we need a file to work with so let's right click on our projects folder and go to new file i will name this test.txt and we now have a file that we can work with but you know what i would like to delete this file because it's lame so let's do that in order to delete this file let's type os dot remove and we're going to list the file path here since this file is within my project folder i only need to list the file path test.txt if this was someplace else on my computer i would probably need the file path like that but since this file is within my project folder i only need the file name another thing that you can do too at least what i like to do is that i like to pass in a variable called path i will make this a variable and assign it a string value of whatever the path to my file is so i will assign path the name to my file test.txt now when i run this this will delete my file test.txt and you can see that it's no longer there now what if we attempt to delete a file that doesn't exist well we'll encounter an exception so if you want this is optional we can do some exception handling so let's write the remove function within a try block and we will catch this exception file not found error and let's print something print that file was not found now if you attempt to delete a file that doesn't exist your program will not be interrupted and instead you'll print something that file was not found now this function does not remove empty folders this is how to do so and actually let's test that so let's create a new directory i'll call this empty underscore folder now i will attempt to delete this empty folder empty folder we encountered a permission error access is denied so let's create an accept block for that accept permission error print i don't know you do not have permission to delete that right to delete an empty folder there is a different function os dot rmdir short for remove directory we're going to list the file path and pass that in as an argument and let's create an else block as well because we can else if there are no exceptions let's print path plus was deleted all right so rmdir remove directory will delete an empty directory empty folder was deleted now this function will not delete a folder that contains files and let's try that so let's create a new directory i'll just call this folder and within this folder i will create a new file test.txt all right let's attempt to delete this folder i will probably need to change the file name let's change that to folder and we encountered an os error that directory is not empty so let's handle this exception we don't need to but i like to accept os air print you cannot delete that using that function okay to delete a folder that contains files we'll need the shuttle module import shuttle and the function that we're looking for is shuttle dot rm tree short for remove tree and we will pass in our path now be careful with this function it is considered dangerous because it will delete a directory and all files contained within so now we can delete a folder that contains files folder was deleted in conclusion these are three basic functions to delete a file or directory they are remove which deletes a file rmdir which is an abbreviation for remove directory which will delete an empty directory and lastly rmtree which is an abbreviation for remove tree and this is of the shuttle module and this will delete a directory containing files so if you would like a copy of all this code i will post this in the comments section down below but yeah that is how to delete files and or directories using python yo what's going on everybody it's you bro hope you're doing well and in today's video i'm going to be discussing modules in python so sit back relax and enjoy the show all right well welcome back we're talking about modules today a module is a file containing python code it may contain functions classes etc it's used with modular programming which is this concept of separating a program into useful different parts we're currently working within our main module and mine is named hello youtube this is how to create a separate module right click on your project folder go to new python file i think i'll create a module filled with maybe message functions so i'll call this messages and click python file all right we have two tabs one for our main module mine is called hello youtube and a separate module for messages and i can write whatever i want within here since we're using modular programming i'll place a bunch of useful functions within this module and i'll import them to the main module that we're currently working with let's define a function called hello all this will do is print hello have a nice day and i'll create a second function for good measure let's call this pie let's say bye have a wonderful time now if we would like access to this module we need to import it i will head back to my main module and at the top write this import then the name of the module and for this example we used the name of messages for our separate module and to use a function from that module type the name of the module dot and then the name of the function so messages.hello will call the hello function found within the messages module and i can also call the buy function as well messages dot bye and that will print bye have a wonderful time no it can be somewhat tedious to have to write the name the module followed by the function name what we could do to shorten things up is to give our messages module an alias also known as a nickname so at the top write import messages as and what sort of nickname should we give messages let's say msg for short so we'll replace messages with msg msg hello and msg buy and this would work the same and it involves less typing there's also an additional way of importing a module and it goes a little something like this from the name of the module import and then list all of the functions or classes you would like to import i would like to import hello comma buy and we no longer need the module name before calling one of these functions i can simply just call hello and vi directly another way in which this could be written is from messages import asterisk that means to import all and i actually would not recommend using this if you're working on a large program or something that contains many modules because you can run into a naming conflict because some of these modules may have the same named function names or variables so if you're working on a small program i really don't think it's a big deal but if you have multiple modules i would actually refrain from using import alt it's much safer to write the name of the module followed by the name of the function that you want to use now another cool thing is that python has a bunch of pre-written modules that you have access to if you would like a comprehensive list of them type help and pass in the word modules and within my console window this will populate a listing of all the modules available to us here they are let's see if math is in here yep there it is so yeah feel free to take a look through some of these modules because there are some fairly useful tools within some of these modules i suppose you can also go to python's official documentation and search for the python module index and here's a listing of all the different modules too they have access to well everyone those are modules they are files containing python code and they may contain functions classes etc if you would like a copy of all this code i will post all of this to the comments section down below but yeah those are modules in python i guess there's a module called pickle hey what's going on everybody it's bro hope you're doing well and in this video we're going to be creating a basic game of rock paper scissors in python so sit back relax and enjoy the show let's begin by importing the random module because we're going to need the computer to pick a random choice and we'll create a list of possible choices so we have three strings within here rock paper and scissors i think i spelled scissors wrong there we go okay and we will have our computer pick a random dot choice from our list of choices and let's test it by printing whatever the computer picks so the computer picked paper paper scissors and scissors okay what about the player choice let's say player equals input rock paper or scissors and let's print what the player has print player and let's print the computer too maybe i'll add a string before these so let's say computer call in space whatever the computer chooses and same thing with the player player all right let's see if this works rock paper or scissors let's say rock the computer picks paper and i pick rock so i would technically lose this round now what if the player doesn't pick rock paper or scissors what if they type in gun so we would like some way to prevent that so let's put our input for our player within a while loop while player not in choices so we're going to need to initialize player because right now it's an unresolved reference so let's say player equals none for the time being okay now let's test our choices our player choices rock paper or scissors i pick the gun and it's going to keep on asking me until i pick something from my list of choices so if i type in that still won't accept it now let's type in rock again there we go now what if somebody types in one of these choices either all caps or capitalized well that technically wouldn't be in choices because these strings are case sensitive so why don't we take our user input and make it lowercase and i'll just add on dot lower and use the lower method so therefore we can now type in any input that is either all caps or uppercase and then that will still be accepted because we're going to take our player input and then make it lower case so that it matches one of these choices okay let's work on the win conditions next so first let's check to see if we encountered a tie if player is equal to computer that means that we both chose the same thing so let's print whatever the computer picked what we picked and we will print tie now let's write an else if statement e l i f player equals rock so if we pick rock and then we will create a nested if statement if computer equals paper that means we lose so let's print everything we have here except we're going to change tie to you lose now if the computer picks let's say scissors then we win so scissors and you win okay then let's just repeat this process for scissors and paper so this will be another else if statement if we pick scissors and the computer picks rock then we lose if the computer picks paper then you win and lastly we have paper as the player choice so else if player equals paper and the computer picks scissors then we lose if the computer picks rock well then paper covers rock and we win now let's test it rock paper or scissors again i'll try and pick the gun which i can't let's take this seriously i will pick rock the computer picked rock so it's a tie i'm feeling like paper today oh it's another tie i guess and how about scissors okay so i win this round i picked uh scissors and the computer picked paper therefore i win let's try and lose this time just to verify it so i won again let's try rock again okay so i lost that round so we know that the win conditions are working now how about we add a feature where we will ask the player if they would like to play again play another round i think the best way to do that would be to write all of this code within a while loop so at the top let's write while true and we'll need to indent everything so that it's within the while loop so let's just indent everything here now at the bottom we will ask the user if they would like to play again and i will store this within a variable named play again play again equals input and the prompt will be play again yes slash no and depending on their input let's just make it all lower case if play again does not equal yes that means they would like to quit so let's use a break statement to break out of our while loop that we're in and at the end let's print by and pay attention to the indentation this input and this if statement should be within the while loop so they should have at least one indentation and our print statement here we'll just say bye and you can see that there is no indentation so that is outside of the while loop okay let's test this one last time rock paper scissors i'm going to pick the cannon okay that's not valid input how about rock okay the computer picks rock i pick rock so it's a tie do i want to play again i'm going to select actually yes all caps that should still be acceptable elbow paper this time it's a tie again man the computer is really good at this game i'd like to play again i'll pick scissors okay so i lose i would like to play again and i want to win this time okay computer pick scissors i pick rock you win do you want to play again nah and it will print bye well everybody that's a simple game of rock paper scissors i'll post all of this code to the comment section down below and well yeah that's a basic game of rock paper scissors in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to show you guys how we can build a basic quiz game in python so sit back relax and enjoy the show to begin this project i think it would be wise for us to create a skeletal structure for how this program is going to operate and then we'll fill in the gaps later as we go along so to begin let's define all of the functions that we'll need we'll need four we'll create a function that is named new game whenever we call this function it will create a new quiz game for us and for the time being let's write pass just as a placeholder we'll have a total of four functions new game a function to check our answer a function to display our score and lastly a function to play again all right now i'm just going to add some comments here just to separate each of these functions that we have just so that it's a little bit easier to read although this part is not really necessary so i just want to separate each of these functions for some readability okay those are all the functions that we'll need what we'll need now is some sort of collection to hold all of the questions and answers that we have and i think a dictionary would be perfect for this so what i did is that i created a dictionary named questions a dictionary has key value pairs each key is a question that i would like to ask and each question has an associated value we'll have the user guess between answers of a b c or d so these would be all of the correct answers all of the values within this dictionary so here are some of the questions that i want to ask feel free to come up with your own questions if you would like you can copy the questions that i have they should be posted in the comment section down below so the questions that i'm going to ask are who created python what year was python created python is attributed to which comedy group and lastly is the earth round i couldn't think of a fourth question so i just threw in a random stupid question and the correct answers to all of these questions in order would be a b c and a but feel free to come up with your own well we have our questions but we'll need some sort of collection to hold all of the different possible answers to each of these questions and i think a 2d list would work perfect for this so i have a list of lists a list of tuples could work too i suppose so here are all of the answers for the first question and the correct answer is a i believe his name is guido van rossum hey if you're listening man i'm sorry if i'm mispronouncing your name i'm really trying here the second list corresponds to the second question what year was python created it was created in 1991 at least according to wikipedia python is attributed to which comedy group the answer is c monty python like monty python and the holy grail good movie by the way and lastly is the earth round this is a highly debated topic but the answer is hey the earth is in fact round so i have a list of lists each list corresponds to a key value pair within my dictionary of questions and this is a lot to type if you want you can just copy the code that i posted in the comments down below just copy and paste and you'll have all of this or if you want you can pause the video and type it i don't care so now that you have your questions and your options we're ready to begin so the first thing that we'll do within our program is to call the new game function to begin a new game so after we have our questions and options created let's create a new game by calling the new game function now when we run this program we'll generate our dictionary of questions and our 2d list of different options for each question and then we will call the new game function to begin a new game so let's head to the new game function and fill in everything within our new game function so at the top let's declare a few things let's say we have a list named guesses and guesses will be an empty list for now i will declare a variable called correct guesses set it equal to zero because we haven't guessed anything yet and we will set a current question number and set the sequel to one to represent the first question okay now we need to display all of the questions within our dictionary of questions and we can use a for loop for that so for key in questions i'm going to print my key and let's just test this okay yeah here's all my questions i think what i'll do is actually print something to separate each question let's say one of these lines i think it would look better with them okay i'll print this line and then we'll move on to a question all right now after re-running this we have each question and i added just a line break between each of these to make it look kind of fancy now i need to display all of the different options for each question and we can do that with a nested for loop so if i were to write i in options print i let me show you what happens now with the way this for loop is written now it's going to display all of the different options available to us for the entire quiz game what i would like instead is to display only the first list for the first question and then the second list for the second question and follow that pattern so we're going to change our for loop around 4i in options and we'll set an index for options the index is going to be our question number minus one now remember what i said in previous videos where different collections including lists tuples etc the first element in a collection has an index of zero because computers always start with zero then the next element would therefore have an index of one then two three then you follow that pattern we're using this question number variable as some sort of counter and since we initially set this to one i'm just going to subtract one so that we effectively receive zero as the index and now we just need to increment our question number after each iteration so let's do that i will add that to the end here after we finish displaying all of the options let's increment question number by one by typing question num plus equals one and if i were to run this currently we'll display all of the different options for each question who created python here's all of the associated options what year is python created python is attributed to which comedy group and lastly is the earth round now it's time for some user input so i'm going to create a variable called guess and make sure you don't put it within your inner for loop it should be within the outer for loop guess equals input and i'll create a prompt enter a b c or d here's something to consider we would like the user to type in either capital a b c or d with strings they're case sensitive what if the user typed in one of these letters but lowercase if they're correct we would still like to give them their point why don't we take our guess and make it uppercase so guess equals guess and we can make this uppercase using the upper method of strings at the end of this game i'm going to compare our guesses to the correct answers so we have an empty list named guesses and i'm going to append our current guest that we're working on to our list of guesses so guesses dot append and we will append our guess this round now that we have our guess and we've appended our guess to our list of guesses let's check to see if it's the correct answer or not so we're just about to fill in this check answer function next so we are going to call this function and pass in a few items as arguments so let's use the check answer function and we'll pass in the key for the current question that we're on so the key is the correct answer so that would be our questions dot get key this would be the answer and we'll also pass in our guess and we are going to fill in the check answer function but we need to set up the parameters we're receiving effectively our answer as well as our guess so i'm going to name these as answer and guess and we are going to check to see if our answer is equal to our guess if answer is equal to guess let's print something print correct and i think we should give the user a point we'll have our check answer function return one for one point return one else if this is not the correct answer let's print wrong and we will return zero they do not get a point and since this is returning a value we should assign that so let's assign the point we may or may not receive to our variable of correct guesses which is initially set to zero so we'll type correct guesses plus equals check answer and check answer will return one if we scored a point or zero if we did not score a point and make sure you have plus equals because if you just set this to equals then we cannot score more than one point it will either be zero or one so we are effectively incrementing our correct guesses by one for each point that we score and now we're going to work on the display score function and we'll call that at the end after we finish all of our questions that we have so make sure that you do not write this within the for loop it should be outside of it because once we finish iterating through all of our questions we're going to display a final score so let's call the display score function and we'll need to pass in some arguments our correct guesses as well as our list of guesses okay let's head to the display score function so we have as parameters correct guesses as well as guesses i need to remove this pass i'm going to add one of these fancy lines in just to separate the questions from the results and i will print results and maybe another one of these lines okay so i need to print all of the answers answers and i do not want to end on a new line so i'm going to set end equal to nothing and i need to display all of the values within our dictionary all of the answers i will do that using a for loop for i in questions print questions dot get i and i do not want to end on a new line so i'm going to set end equal to nothing effectively and then i'll print a new line okay let's work on the guesses i think i'm just going to copy all this and make some changes i'll replace answers with guesses for i in guesses print i okay let's just be sure that everything's working we're not calculating a score quite yet so i'm just going to answer a then b c and d on second thought after printing each of these answers and guesses i'm going to add a space after each of these so within each of these four loops at the end i will add a space let me try that again a b c d okay not too bad now let's calculate the final score and we're still within our display score function let's set score equal to correct guesses divided by the length of our questions and let me add a set of parentheses around here then i'm going to multiply our score by 100 and if you don't want a decimal portion because we'll display a percentage we can cast this as an end okay that all looks good and we'll print the final score print your score is plus we need to cast our score to a string because we're using string concatenation plus i'll add a percent sign all right let's try it i'm intentionally going to get the last question wrong so we should have a 75 if we have four questions so that would be a b c is the earth round what's earth i'm gonna guess d answers a b c a your guess is a b c d your score is 75 okay let's test it but getting all wrong answers d d d d your score is zero percent congratulations and we'll test it one more time but get all the right answers we just want to be sure that we have 100 that's a b c a your score is 100 now the last thing that you can add is that we can play again if we want and i have a separate function for that if you would like to add this option here's how to do so let's remove that pass let's set a variable named response equal to some input do you want to play again let's ask for yes or no actually let me remove that okay and depending on the user's response it might be a lowercase so let's make it uppercase response equals response and use the upper method if response is equal to yes all caps if response is equal to yes then return true else we will return false and that is it for this function the last thing we need to do is to create a while loop that will continue to ask the player if they want to play again this will be after we call the new game function while play again and remember this will return either true or false depending on the user's response while play again new game and call the new game function to create a new game for us if we escape the while loop that means the user doesn't want to play again so let's print the message such as by e all right let's test it i'm going to get all of the correct answers this time a b c a all right your score is 100 do you want to play again i'm going to type yes all right then we can play again d d d d your score is zero percent do you want to play again no i think i mastered this game bye all right everybody so that's how you can use python to create a simple quiz game i will post all of this code to the comment section down below but well yeah that's a basic quiz game in python for you all hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain object-oriented programming in python so sit back relax and enjoy the show welcome to today's topic on python object oriented programming also known as pop and in today's video we're going to be creating objects an object is an instance of a class by using programming we can create representations of real-life objects so look around you wherever you're sitting or standing right now you are surrounded by objects next to me i have a phone a television some snacks and i'm talking into a microphone point being we can use programming to mimic real world objects by assigning a combination of attributes what an object is or has and methods what an object can do now in order to create an object we'll need to create a class a class can function as a blueprint that will describe what attributes and methods that our distinct type of object will have you can either create your class within your main module or you could create a separate file dedicated solely for your class now to create a class we would type class and then the name of the object that we would like to create so today i would like to create some car objects because i like cars so we would type car and a common naming convention with class names is that they should be capital so car is going to have a capital c and for the time being we need to type in something i'll just type in pass as a placeholder so if you have a small program it may be better to write your class within your main module but if your class is fairly large you may want to consider placing your class within a separate module so if you were to take that route we would go to file new python file and we would name this car click python file and we would declare our class within the separate module so class car and for now i'll type in pass then we just need to import this class so within our main module we would type from the name of the module import the name of the class from car import car now objects can have some combination of attributes and methods attributes describe what an object is or has so what are a few attributes that cars might have they might have a make so let's create a few variables for the time being i'm just going to use none as a placeholder cars can have a model a year and a color now objects can also have methods what kinds of methods could cars perform perhaps a drive method and a stop method so let's define those def let's say drive and we'll have one argument self self refers to the object that is using this method now what do we want to do when we call this method let's say this car is driving let's create a stop method as well def stop and we will print this car is stopped we now have all of the different attributes and methods we would like our car objects to have but there is one more thing that we need it is a special method called the init method that will construct objects for us in other programming languages this is known as the constructor so we need a special method that will create objects for us so we need to define this method def and the syntax on this is somewhat strange it is two underscores init it's short for initialize 200 scores again and then we need at least self as an argument and then we can actually assign our car objects unique variables so take all of these attributes that we have and we're going to place them within this init method now we can receive arguments when we create car objects but we need to pass them in as arguments to our init method so we need to set up some parameters let's say in order to create a car object we need a make a model a year and a color then when we receive these arguments we can actually assign them to each car's specific attributes but we need to precede each of these with self self is referring to the object that we're currently working on or creating so self.make self.model self.ear and self.color and then when we assign these we're going to say self.make equals whatever make that we receive when it's passed in as an argument self.model equals model and continue that pattern for year and color all right that is all we need for our class car we have a constructor we're assigning arguments that we receive to the attributes of our car object and we also have two methods one for drive and one for stop now we can start creating some car objects so going back to my main file here to create an object we need a unique name for it let's call this first car just car one equals the name of the class car then a set of parentheses now in order to construct a car object we need to pass in a matching set of arguments you can see here that we need to pass in a make a model a year and a color so what kind of car should we make let's say that the make is going to be chevy we need a model perhaps corvette a year 2021 is good and a color let's say blue alright now let's actually access some of these cars attributes and i should probably put this one in a print statement so print car ones make and this should print chevy then we can do the same thing for model year and color so let's change some of these around model year and color yep this object is a chevy corvette 2021 and the color is blue and we should have two methods as well so car one i would like this car to use its drive method this car is driving and let's have this car use it stop method car one dot stop this car is stopped there's one thing that i should mention real quick because i forgot to mention it earlier so within our init method you can see that we need five arguments in order to construct a car object self make model year in color but when we pass in our arguments we're not passing in anything for self we only have four arguments here that's because with python we do not need to pass itself that's done automatically for us we're referring to the object that we're dealing with as you can see with our drive and stop method we need to pass in self in order to execute our method but when we call this method we do not need to do so so just remember with python with self we do not need to pass in anything for this argument that is all now the nice thing about this is that we can reuse this class as a blueprint to create more car objects we just call that init method that constructor so this time let's create a second car called car 2 and this will be a different kind of car what kinds of arguments should we pass it let's say this is a ford mustang the year will be 2022 and the color will be red all right let's check card to use attributes and let's have car 2 use its drive and stop method this is a ford mustang the year is 2022 the color is red this car is driving and this car is stopped one other thing that we can do too is that within our methods here let's replace car with the name of the model that we're working with so this plus self dot model plus is driving now this self keyword think of it as you're replacing self with the name of the object that we're working on if car one is using its drive method replace itself with car one if this is car two that called this method then replace itself with car 2. think of it that way and let's do the same thing for stop this plus self dot model plus is stopped all right probably don't need these anymore so let's have car one use its drive and stop method this corvette is driving this corvette is stopped let's try this with car two this mustang is driving this mustang is stopped now you can have them do things independently too let's have car 1 use its drive method and car 2 uses stop method this corvette is driving and this mustang is stopped in conclusion a class can function as a blueprint to create objects we can assign attributes what describe an object is or has and methods what each object can do and then within our class we have a special method called the init method we can pass in some arguments and assign these arguments to each object's attributes and then we can reuse this class as if it was a blueprint so we can create more objects out of it so that is the basics of object oriented programming in python if you would like a copy of all this code i will post this in the comment section down below but yeah that's the basics of object oriented programming in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain the basics of class variables in python so sit back relax and enjoy the show here's a super quick video on the differences between class and instance variables for this example let's say we have two car objects named car one and car two and i'm just passing in a bunch of values to each of these car constructors now within my class car i have my init method also known as the constructor and what i'm doing is assigning all of these values to the variables found within my car constructor these variables declared inside the constructor are known as instance variables and each object can have their own unique values assigned to each of these variables now where a class variable is different is that a class variable is declared inside the class but outside of the constructor and what we can do is set some default values for some variables let's say we would like to add an additional variable let's say wheels wheels equals and we can set a default value for all instances of this class for each car object that we create so we set wheels to equal four this is an example of a class variable whenever we create a car object we can pass in a unique make model year in color but by default they will all have four wheels now if i was to print the amount of wheels that car 1 and car 2 have they will both have four wheels it's as if we're setting a default value if i change this to two wheels well then these cars have two wheels maybe their motorcycles or something now you can actually change these values each object will have their own copy of this variable but you can set it to a default value so let's say car one is a motorcycle car one dot wheels equals two so if i were to print car one's wheels along with card two car one will have two wheels but car two is still using that default amount of wheels which is four now there's another way in which you can access a class variable you don't necessarily need to create an object to do so you can just use the name of the class so what i'm going to do is turn all of these lines into comments and i will print the amount of wheels that our class has so type in the name of the class car with a capital c it should be the same name as your class name followed by the name of the class variable car dot wheels but make sure you spell it right all right so this will display four wheels now what if we decide to change the class variable through our class well that will affect all instances of our class so let's say car dot wheels equals two it's as if we change our mind and we have decided to create motorcycles instead of cars well if we were to change the wheels class variable through the use of our car class well then it's going to affect it for all instances of this class you can see that both car 1 and car 2 now have two wheels when we just changed car 1's wheels it did not affect car 2 at all so that's the main difference between a class variable and an instance variable an instance variable is declared inside of constructor and they can be given unique values with class variables they are declared within a class but outside of the constructor and you can set a default value for all instances of this class for all unique objects that are created and then you can change those values later too so if you would like a copy of all this code i will post all of this in the comment section down below but yeah that is the basics of class variables in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain inheritance in python so sit back relax and enjoy the show let's talk about irritants the term inherit means to receive derive or be left with and we can apply this concept to programming classes can inherit something usually attributes and methods from another class these classes can form parent-child relationships where a child will receive everything that the parent class has much like you inherit jeans from your parents and classes can have children and give whatever they own to their children and in today's video we'll be creating a parent class called animal and children of the animal class will inherit the common attributes and methods that all animals might have to kick off this video i think what we'll do is keep all of our classes within the same file just so that it's easier for us to read and understand let's begin by creating a class called animal so at the top type class animal and what are some attributes and methods that all animals should have let's say we have a class variable called alive and we'll set this to true if you're an animal you begin by being alive and what are some methods how about an eat and sleep method so let's define those def eat what are we gonna do when we call this method let's print something let's print this animal is eating let's also create a sleep method def sleep what are we gonna do when we call this method let's print something as well this animal is sleeping and we now have our animal class now let's create separate classes for specific types of animals let's say a class for rabbit a fish and a hawk so we can make objects of those classes so let's begin with a rabbit class class rabbit now to use inheritance with the class that you intend to be the child class after the class name add a set of parentheses and then pass in the name of the parent class in this case it's going to be animal so we will add that to the parentheses so now rabbit is the child class and animal is the parent class so the child class is going to inherit everything that the animal class has so for the time being i'm going to type pass so this rabbit class will have access to a class variable called alive and an eat and sleep method so let's define a fish and hawk class and i'm just going to copy what i have here and just change rabbit to fish and then do so again and change rabbit to hawk this is our family tree animal is the parent class and it has three children a rabbit class a fish class and a hot class and for the time being we're just going to write pass as a placeholder so i bet we can create objects from these classes so let's do so let's say we have an object called rabbit rabbit equals rabbit let's do the same thing for fish and hawk all right we now have three objects rabbit fish and hawk and let's take a look at their class variables i bet they have an alive variable let's check that so i would like to print rabbit dot oh would you look at that this rabbit class has a class variable called alive even though there's nothing within this class well that's because we used inheritance so each of these three children classes inherit everything from their parents all of these attributes and methods i bet they have eaten sleep functions as well so let's check that with fish let's have fish use its eat method and hawk will use its sleep method hawk dot sleep so the rabbit is alive the fish is eating and the hawk is sleeping now even though we have nothing written within each of these specific types of animal classes all of these animals have access to these attributes and methods because of inheritance and another benefit of inheritance is that we don't need to keep on copying and pasting this code for example let's say we were not using inheritance so we would not need an animal class we could write our code this way where we would just copy and paste everything underneath each of our classes so what if we need to make a change to one of these methods as in your boss says you know what let's change sleep to slumber okay well we would have to go to each of these classes and make the change manually it's not too bad if you have like three classes but what if you have hundreds that's going to take a lot of effort so wouldn't it be nice if we just list everything that each of these classes has in common and then have all of these classes inherit from one common class and then if you need to make any changes you can do so just within this class and this change will apply to all of the different child classes so that's another benefit of inheritance and not only does it make any changes easier but each class can have their own unique attributes and methods as well along with the attributes and methods that they inherit from their parents so for rabbit fish and hawk let's have each of these classes have their own unique method as well so for rabbit let's define a run method if you're a rabbit then you can run so let's print this rabbit is running and i'm just going to fix some of the spacing here all right if you're a fish then you can swim def swim let's print this fish is swimming and lastly we have hawk if you're a hawk then you can fly def fly let's print this hawk is flying like i said before not only do these specific types of animals have access to all of the attributes and methods that they inherit from their parents but they can have their own attributes and methods as well so let's test some of these methods so we have our rabbit fish and hawk objects let's have rabbit use its run method fish we'll use its swim method and hawk will use its fly method and here we go this rabbit is running this fish is swimming and this hawk is flying so in conclusion classes can have children the children classes will inherit everything that their parent class has all of the parents attributes and methods but not only that the children classes can implement their own unique attributes and methods as well so that is inheritance if you would like a copy of this code i will post all of this in the comment section down below but yeah that's the basics of inheritance using python yo what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain how multi-level inheritance works in python so sit back relax and enjoy the show all right welcome back everybody let's talk about multi-level inheritance this is a concept where a derived class also known as a child class inherits from another derived class here's an example let's say we have a hierarchy of classes there will be three levels to this we'll create a family tree of living organisms so at the very top we're going to have a class called organism any class that inherits from the organism parent class will receive one attribute one variable named alive and this will be set to true so if you are an organism you begin by being alive now let's say we have a child class that will inherit from the organism parent class let's say animal class animal inherits from organism so any animal that we create will have this alive attribute set the true and all animals eat so let's define a function that does that at least i believe all animals eat let's pretend that they do so this animal is eating and now why stop there let's create a class for a specific type of animal i like dogs so let's create a dog class class dog inherits from the animal class and all dogs should be able to bark so let's create a function to do that and we'll print this dog is barking okay so what we just did here is multi-level inheritance we had a derived child class inherit from another child class so it's kind of like this dog class is the child animal class is the parent and then the parent of the parent class would be like a grandparent right and then if you added another layer on top of that to this hierarchy well then the parent of the grandparent would be like a great grandparent that's how i think of it at least now let's create a dog object just to verify that everything's working so let's call our dog dog and our dog object should have access to an attribute named alive and our dog object receives that attribute from the organism class and this will print true if i were to print whatever this attribute contains and our dog should be able to eat because it receives this method from the animal parent class and lastly our dog should be able to bark and that method is defined within its own class so that's how multi-level inheritance works it's a concept where a child class will inherit from another child class i like to think of it like a family tree where a child class will have a parent and the parent of that parent would be like a grandparent basically so if you would like a copy of this code i will post all of this to the comment section down below but yeah that is how multi-level inheritance works in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to show you all how multiple inheritance works in python so sit back relax and enjoy the show all right people multiple inheritance multiple inheritance is the concept where a child class is derived from more than one parent class here's an example let's say that all of our children classes are going to be certain types of animals and we would like our animal classes to inherit from either the prepared class the predator parrot class or both depending on what type of animal it is because some animals in the animal kingdom can be both prey and predators and one example that comes to mind would be fish fish will eat smaller fish but also can get eaten by larger fish so here we have two classes prey and predator each has a dedicated method if a class inherits from the prey parent class they will have access to a flea method which will print this animal please if a class inherits from the predator parent class that class will have access to a hunt method that will print this animal is hunting and it's possible that some animals can do both they can both flee and hunt but they'll need to inherit both of these classes both prey and predator and that's where multiple inheritance comes in now let's create some classes based on certain types of animals let's say we have class rabbit and rabbit we'll inherit from the prey class because rabbits are typically prey and not predators but i don't know there could be some killer rabbits out there haven't run into any yet let's have class hawk inherit from the predator class and lastly fish and fish can be both prey and predators so they will inherit from both classes and we just separate each class with a comma so prey comma predator and it's as simple as that now let's create an object from each of these classes we have rabbit equals rabbit hawk equals hawk and fish equals fish now let's just verify all of the different methods that each of these objects inherited so our rabbit should have access to a flea method but no hunt method and let's just test that yep this animal flees and my hawk object should have access to a hunt method but no flea method this animal is hunting and lastly my fish object has access to both a flea and a hunt method and if you take a look on the right hand side of this pop-up window it shows the class that it inherited this method from so fleet comes from the parent class of prey and hunt comes from the apparent class of predator so my fish can both flee and hunt because it's typically considered both prey and predators this animal flees this animal is hunting so that's basically what multiple inheritance is it's a concept where a child class is derived from more than one parent class so that's basically multiple inheritance i'll post all of this code to the comment section down below and well yeah that's how multiple inheritance works in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to teach you guys about method overriding in python so sit back relax and enjoy the show here's a super quick video on method overriding i have two classes a class called animal and a class called rabbit rabbit inherits from the animal class therefore rabbit is the child class an animal is the parent class within the animal class there is one method a method called eat and when you call this method all this will do is print this animal is eating the rabbit class inherits from the animal class therefore rabbit has access to this eat method and if i were to create a rabbit object and this rabbit used its eat method well then this is going to print this animal is eating now method of writing is the ability of an object oriented programming language to allow a subclass also known as a child class to provide a specific implementation of a method that is already provided by one of its parents in this case we're going to override the eat method and what we can do is provide a more specific implementation for the rabbit class and now to override a method what we'll do is that within the child class we need to define a method with the same matching method signature that is the combination of a method's name plus its parameters both of these together are known as a method signature within the child class we will define and eat method with the same parameters def eat and in this case the only parameter is self just to keep this simple and what we'll do is that will provide a more specific implementation of the eat method specifically for rabbits so let's print something more closely associated with rabbits such as this rabbit is eating a carrot now if i were to run this program again we will instead use this implementation of the method instead of the one that it inherits from its parent class of animal basically speaking an object will use a method that is more closely associated with itself first before relying on a method that it may inherit from a parent class in this example we're using this version of the eat method specifically for rabbits instead of the version that we inherit from the parent class of animal that is the basics of method overriding i will post this code in the comment section down below and well yeah that's how to override a method using python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to teach you guys all about method chaining in python so sit back relax and enjoy the show all right everybody let's talk about method training method chaining is used to call multiple methods sequentially and each call performs an action on the same object and return self here's an example of how method chaining would be useful let's say we have a class named car car has four methods turn on drive break and turn off they will all just print a simple message beginning with turn on turn on what print you start the engine drive will print you drive the car brake will print you step on the brakes and turn off will print you turn off the engine let's say we have a car object car equals car and i would like my car object to use its turn on method immediately followed by the drive method with how we've been coding things previously we may write something such as the name of the object in this case car dot and then the method to use i would like my card to use the turn on method followed by car dot drive so currently this will take two lines of code but this will print you start the engine and you drive the car now with method training we can call multiple methods sequentially now the format on this is going to be a little bit different and if we were to write the same code using method chaining it might look a little something like this after the first method call we would add dot and then an additional method that we would like to call so for example after the turn on method we'll immediately call the drive method but there's one more thing that we need to add when we're using python to do method training so normally this by itself will not work when we call a method in python if there is nothing that is returned python will return none so as you can see here attribute error none type object has no attribute of drive so we need to return itself under each method that we're using method training with so let's add return self to each of these methods so let's do that for drive break and the turn off method and this should work now you start the engine you drive the car so think of it like this after we finish calling this method python is going to return self so it's going to return car so then we'll immediately use car.drive now here's another example let's say i would like to call the break method followed by the turn off method so that would be car dot break parentheses followed by dot turn off so this will print you step on the brakes you turn off the engine now here's an extreme example let's say we would like to call all four methods in order so that would be car dot turn on followed by dot drive dot break dot turn off so this will call all four methods in order starting with the leftmost method you start the engine you drive the car you step on the brakes you turn off the engine now if you have one long method chain like this it might become difficult to read after a while so what i would recommend if you're doing a lot of method chaining is that after each method call just hit enter to move each method call down to a new line so it'll look something like that and this backslash might be inserted this is a line continuation character so this is a little more readable but you know it still does the same thing basically all right everybody so that is method training it's used to call multiple methods sequentially and each call performs an action on the same object and returns self if you would like a copy of this code i will post all of this in the comments section down below but yeah that is how to do a method chaining in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain the super function in python so sit back relax and enjoy the show well then since you clicked on this video i should probably discuss the super function now the super function is used to give access to the methods of a parent class it returns a temporary object of a parent class when used here's an example of why the super function would be useful let's take this program that i've written there's three classes a class called rectangle which is the parent class to two children classes square and cube and all we're doing is creating a square object and a cube object but we need to pass in a length and a width for squares and a length width and height for cubes now with programming we don't like to repeat code we like to reuse code and if you take a look within my knit methods for both square and cube we're repeating self.length equals length and self.width equals width twice for our init methods so one thing that we can do any similarities between the square and cube class we can place within the rectangle class and then reuse this code so what i'm going to do is copy this indent method within our square class and paste it within our rectangle parent class and then in order to access this init method we can use the super function so we no longer need these two lines of code what i'm going to do is ask the rectangle class to use its init method so we're going to type super parentheses dot and then the name or the function of the parent class that we would like to use and i would like to use the init method but i need to send a length and a width because it requires that so let's send these so we're going to pass in our length and our width and now we can do the same thing for our cube init method so i will copy this line of code we no longer need these two lines of code because we will be reusing our init method within the parent class of rectangle but we'll still need to keep this line in to assign the height because that's a difference between our square and cube class and now we can just reuse this init method within the rectangle parent class now i'm thinking that we should probably test to see if length and width are assigned to these attributes and one way that i think would be fun would be to create an area method for squares and a volume method for cubes so let's define an area method within the square class def area and i would like to return self dot length times self dot width and we can create a volume method within cubes so let's do that def let's change this to volume we'll multiply it length times width times height but we need to type self dot pipe and we can call these methods to get the area of a square or the volume of a cube let's print square dot area and then cube dot volume so if our init method is actually being used we should have a length and the width assigned to these attributes and it looks like we do in conclusion the super function is used to give access to the methods of a parent class it returns a temporary object of a parent class when used in order to access the methods of the parent class also known as a super class and in this example within the init methods of both square and cube we immediately called the init method of the parent class to pass in some arguments that both of these classes have in common so if you would like a copy of this code i will post all of this in the comment section down below but yeah that is how the super function works in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain how abstract classes work in python so sit back relax and enjoy the show hey what's good everybody let's talk about abstract classes now abstract classes prevent a user from creating an object of that class think of an abstract class more as a template it's an idea it's not real it's like a ghost class basically plus an abstract class compels a user to override any abstract methods within a child class so it's also a form of checks and balances as well which we'll discuss later now here's a small program that i've written let's say we have three classes class vehicle car and motorcycle car and motorcycle are the children classes of the vehicle class now within this vehicle class we have a go method but i'm currently only defining it not actually implementing it so i'm just writing pass now within car and motorcycle we're overriding this method and creating our own implementation of the skull method that we inherit the go method for the car will print you drive the car and the go method for the motorcycle class will print you ride the motorcycle now currently i'm creating an object of each of these classes i have a generic vehicle object car object and motorcycle object now after running this program currently the go method within our vehicle class is not being implemented so this won't print anything but the go method within our car class will print you drive the car and the go method within our motorcycle class will print you ride the motorcycle with that being said let's pretend that we're coding the next need for speed game and we would like a user to create an object from a specific kind of vehicle whether it's a car from the car class or a motorcycle from the motorcycle class we would like to prevent a user from creating an object of the vehicle class because the vehicle class is too generic we do not have all of the implementations set up for a vehicle it would be like somebody unlocked the ghost car or the invisible car which doesn't actually exist and is missing a lot of features we need a user to create an object from a child class because these are fully fleshed out and one way in which we can prevent a user from creating an object of this class as well to turn this class into an abstract class which is what this video is all about go figure now the first step to creating an abstract class is that we'll need some imports so at the top of your program write this from abc abc is an acronym for abstract based class abc from abc import abc all capital comma abstract method all right now with our vehicle class the class that you intend to be the abstract class add us out of parentheses and our vehicle class will inherit from the abc class and now with any methods within your vehicle class you're going to add this decorator at the top at abstract method all right we should now be prevented from creating a vehicle object our vehicle class is now an abstract class and we cannot give it a physical form a physical manifestation and if we attempt to you can see here that we have a type error can't instantiate abstract class from vehicle with abstract methods go so an abstract class is a class which contains one or more abstract methods and an abstract method is a method that has a declaration but does not have an implementation now by definition an abstract class contains one or more abstract methods if i remove this one abstract method within our vehicle class well we could still create a vehicle object and i'm just going to turn this vehicle.go line into a comment because we don't have a go method anymore as you can see we can still create a vehicle object which we would like to prevent a user from doing so we need at least one abstract method within our vehicle class so i'm going to go ahead and add this go method back in an additional feature of abstract classes is that they compel a user to override any abstract methods within a child class a method that is abstract has a declaration but does not have an implementation so let's say that we create our vehicle class our abstract vehicle class and now we're creating the children classes of car and motorcycle and let's say i'm not paying attention and i forget to add a go method so if i just write pass within my motorcycle class i'm currently missing a go method within my motorcycle class well python is going to prevent me from running this because we have a type air can't instantiate abstract class vehicle with abstract methods of go so by inheriting from an abstract class it's a good form of checks and balances to be sure that your children classes are not missing any implementations of any methods that they inherit here's an additional way of thinking of this our vehicle class is telling its children if you're going to inherit from me then you need to override this abstract method of mine and if you don't well i'm not going to let you be instantiated so in order for us to create a cart and motorcycle class we need to override the go method that they inherit from its parent class of vehicle and provide its own implementation now let's say we create an additional method let's say we have a stop method so let's define that def stop for the time being i'll write pass and to make this an abstract method add this decorator at abstract method now car and motorcycle both need to implement that method of stop it's currently missing it as you can see here class car must implement all abstract methods and the same thing applies for a motorcycle as well so we need to override this method and provide its own implementation so let's remove that decorator and let's print something let's print this car is stopped and i'll do the same thing for motorcycle so def stop let's say this motorcycle is stopped and we'll call the stop method for each of these types of vehicles car dot stop and motorcycle dot stop all right and we can now create a car and motorcycle object because we are overriding both of these abstract methods found within the parent class of vehicle all right everybody so that's the basics of abstract classes it's a class which contains one or more abstract methods and an abstract method is a method that has a declaration but does not have an implementation and the benefits of using an abstract class is that they prevent a user from creating an object of that class plus it compels a user to override any abstract methods found within a child class so if you would like a copy of this code i will post all of this in the comments section down below but yeah that is how abstract classes work in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain how we can pass objects as arguments so sit back relax and enjoy the show ladies and gentlemen in today's video i'm going to be demonstrating how we can pass objects as arguments for this example let's say we have a class car and there is one class variable called color color equals none what we'll be doing is calling a function that accepts an object as an argument as well as a color so let's create a function named change color now make sure when you define this function it's not within the cart class then technically this would be a method of the car class what we would like is a separate function outside of the car class now we need to set up some parameters we would like to accept a car object as well as a color so for the first parameter let's say a car and make sure this is in uppercase or capital because python doesn't like that argument names should be lowercase so when we pass in a car we will give it a nickname of car and we would also like to pass in a color so let's set up a parameter called color now when we pass in a car we will assign that car's color with whatever color that we receive so car dot color equals color and now let's create some car objects so let's say car one equals car car two equals car and car three equals cart currently if i were to print their colors this is what we'll see print car one dot color and repeat the steps for two and three and we're not calling this function yet so all of these colors should be set to none they are basically cars with no color they're i don't know iron or something whatever cars are made out of aluminum plastic stuff like that okay so now let's call this function change color perhaps right here so in order to call this function we need to pass in a car object as well as a color so let's pass in car one and a color perhaps red and we'll repeat the steps for two and three so let's say car two will be white and car 3 will be blue now after calling this function we have a car object and a color and we're assigning the color of our car to whatever color that we receive now these cars in order car 1 2 and 3 are red white and blue now one thing that you should know is that the name of this parameter that accepts our object doesn't necessarily need the same name as the class name that created the object that we're passing in we could name this something else entirely perhaps vehicle you'll just want to be sure that this is at least descriptive of the kind of object that you would like to pass in and we're not limited to just passing in car objects we can pass in all sorts of objects but we need to pass in an object as well as a color so this time let's create a class called motorcycle class motorcycle and this class will also have a color set to none so what we're doing is actually reusing this function for all sorts of different kinds of vehicles now let's create a vehicle i'll just name this bike one for short bike one equals motorcycle now let's call the change color function and we can pass in an object as well as color this time we will pass in our bike object as well as a color i think black counts as a color and let's print bike once color and this should work we have red white blue and black in conclusion we can pass objects as arguments to a function much like what we've been doing with variables however the type of objects that we pass in may be limited based on the required attributes and methods that that given class or object might have and we'll get more into this on the next video on duct typing so if you would like a copy of all this code i will post all of this in the comment section down below but yeah that is how to pass objects as arguments using python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to explain duck typing in python so sit back relax and enjoy the show i hope you all like ducks because that's the topic of this video duct typing is the concept where the class of an object is less important than the methods and or attributes that that class might have the class type is not checked if the minimum methods and or attributes are present it's based off of a popular phrase if it walks like a duck and it quacks like a duck then it must be a duck here's an example i have two classes class duck and class chicken both duck and chicken have walk and talk methods but they print something different with the duck class the walk method will print this duck is walking and the duck talk method will print this duck is quacking the chicken class has the same named methods walk and talk but they print something slightly different a slightly different variation the print method will print this chicken is walking and the talk method will print this chicken is clucking now let's say we have a third class a class called person now there is one method within our person class let's say we're attempting to catch a duck we'll pass in self and we need to pass in a duck object as an argument so let's type duck now within this method we'll have our duck use its walk method as well as its talk method duck.walk and duck.talk and then maybe we'll print something such as you caught the critter now let's create an object from each of these classes let's create a duck object duck equals duck a chicken object chicken equals chicken and lastly person person equals person now if we would like our person to use the catch method we need to pass in a duck as an argument so with our person let's type person dot catch and we need to send a duck object because that's a required parameter here so we're passing in our duck object that we created and as soon as we catch the duck it's going to use its walk and talk method and then we'll print you caught the critter so as you would expect this will print this duck is walking the stuck is quacking you caught the critter now with duct typing we can pass in a different type of object as long as it has the same methods and or attributes as our duck we could pass in a chicken because a chicken can also walk and talk so this time let's pass in our chicken as an argument and this will still work even though our parameter is set up to take a duck object this chicken is walking this chicken is clucking you caught the critter in layman's terms think of it like this python is examining this chicken object it's using its walk method it's using its talk method which are required and python is saying well that's close enough remember if it walks like a duck and it quacks like a duck then it must be a duck so duct typing is the concept where the class of an object is less important than the methods and or attributes that it might have the class type is not checked if the minimum methods and or attributes are present now let's say with our chicken object our chicken can no longer walk well we cannot pass in our chicken object anymore we have an attribute error chicken object has no attribute walk so python took a look at this chicken and noticed that it does not have a walk method well it's not walking like a duck but it's talking like a duck so it doesn't count as a duck because it doesn't have its walk method in conclusion the class type of an object is not as important as the methods and or attributes that that class might have when using duct typing the class type will not be checked if the minimum methods and or attributes are present since chickens can both walk and talk like ducks then they can be a substitute for ducks when we pass in our duck object to this method so if you would like a copy of this code i will post all of this in the comment section down below but yeah that is the basics of duct typing in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to discuss the walrus operator in python so sit back relax and enjoy the show all right people i hope you like walruses because that's the topic of this video we'll be discussing the walrus operator also known as an assignment expression it's a colon followed by an equal sign and it kind of looks like a walrus on its side now this is a new feature for python 3.8 what it does is that it assigns values to variables as part of a larger expression here's an example of why the walrus operator would be useful let's say we have a variable named happy happy equals true if you're not happy or you're feeling so so you can set this to false if you want so let's print the value contained within happy so this will print true to the console window now wouldn't it be cool if we could combine both of these statements together so we would want to say something such as happy equals true and then print it to the console window using one line of code well normally we can't do this using the standard assignment operator now one thing that we can do is use the walrus operator this assigns a value to a variable as part of a larger expression so this would technically be allowed if this assignment operator was instead an assignment expression the walrus operator happy walrus true and when they're all within a print statement we can assign a value to a variable and use it as a part of a larger expression so as you can see this new variable of happy was assigned and used in one expression now here's a more practical example of why the walrus operator would be useful let's say we have the smell program what this will do is consistently ask you what food you like and put it into a list called foods foods equals list while true food equals input what food do you like if food equals quit break then append our list of foods with this new food item that we have okay let's run this then so this while loop will continue as long as i don't type in quit and it will consistently ask me what food do i like and place that food item into a list named foods so let's begin what food do i like well i do like pizza i like sushi and i like ice cream and that should be enough for me i'm going to type in quit to exit this program now let's write the same program but instead use a walrus operator so that we can write this program using less lines of code now if i were to use the walrus operator this is how i would write the same program we would still need our list foods equals list now for my while loop it's going to look something like this while food walrus operator input what food do you like all right this is the assignment portion now we can use this assignment portion within a larger expression so let's also check to see if our input does not equal quit alright so then after each iteration of this while loop we will take our list foods dot append food and that is it so we have written the same program in about half the lines of code that we did previously so let's test it what food do you like pizza sushi ice cream and quit well everybody that is the basics of the walrus operator also known as an assignment expression it's a new feature for python 3.8 and beyond so if this doesn't work for you i would check to see what version of python you're using first it assigns values to variables as part of a larger expression if you would like a copy of this code i will post all of this in the comment section down below but yeah that is how the walrus operator works in python hello what's going on everybody it's bro hope you're doing well and in this video i'm going to show you guys how we can assign a function to a variable in python so sit back relax and enjoy the show hey all in today's video i will show you all how we can assign a function to a variable this video will be a prerequisite for a few videos i have coming up regarding functions now let's say we have a function named hello and all we'll do is print the word hello and as you know to call this function you would type the name of the function followed by a set of parentheses and this will print the word hello the set of parenthesis that comes after a function's name is the portion that will call the function if you were to remove that set of parenthesis afterwards we would not in fact call that function now with python python will pretty much treat everything as objects including functions so there's something i want to show you guys if i was to print the name of my function hello what will be displayed is the memory address of this function this is the memory address of where this function is located within my computer's memory and it's in hexadecimal think of it like a street address such as one two three fake street this is the address of where this function is within my computer's memory and each time that i run this program this number can change as you can see here now one thing that we could do we could assign this address to a variable let's say hi equals hello and be sure that you're not adding that set of parentheses afterwards because then you would be calling the hello function and returning the result to high so high equals hello no parentheses and if i was to print hi well the address of hello and hi will be at the same memory address both of these numbers are the same now what do you imagine would happen if i was to call the high function after we assigned the memory address of hello to hi well then what we'll end up doing is calling the hello function even though we're listing that we would like to call the high function even though it doesn't exist so it's as if this hello function has two names you can either use hello or you can use hi and let me demonstrate that so you can call either hello hi or both for this example that's because we're assigning the memory address of hello to this variable of high so we could treat high as a function it's kind of like an alias where this function has two names now here's another demonstration let's say that we would like to assign our built-in print function to a variable so let's say maybe say say equals print and when i say print i'm referring to the print function and be sure you're not adding that set of parentheses afterwards now if i need to print something to the console window i can either use print like what we've previously been doing or i could use say because say has the same memory address let's say perhaps whoa i can't believe this works surprise face all right so we can call the print function by saying the word say say all of this text and this will print all of this text well say all of this text to the console window under normal circumstances i'm not sure why or when you would need to assign the print function to a variable but you can and well that's kind of cool so i thought i'd show you guys that so everybody that's how to assign a function to a variable like i said we'll be building upon this topic so you want to be sure that you understand this all right then well if you would like a copy of this code i will post all of this to the comments section down below but yeah that's how to assign a function to a variable in python hey uh what's going on everybody it's bro hope you're doing well and in today's video i'm going to explain higher order functions in python so sit back relax and enjoy the show all right ladies and gentlemen let's talk about higher order functions these are functions that do one of two things one they either accept a function as an argument or two they return a function as output and in python this is totally allowed because functions are also treated as objects i'll give you guys an example of both of these but let's begin with number one here's an example of number one let's say that i have two functions named loud and quiet both of these functions will accept a string as an argument loud will return that string all uppercase as if we're shouting something quiet we'll return that text i'll lowercase as if we're whispering something now i'm going to create a third function called hello and this will be the higher order function it accepts a function as an argument i'm not sure if we're going to be passing in loud or quiet whatever it is i'm going to give it a name of funk short for function each of these functions will return some text either all uppercase or lowercase i'm going to assign that to text text equals the name of our function we're not sure what it's going to be and i will pass in some text in order to call one of these functions i will pass in just the word hello that's capitalized and at the end i will print whatever text that we have in order to call this function of hello i need to pass in a function as an argument do i want to pass in loud or quiet do i want the loud variety of hello where all of the text will be uppercase or the quiet variety of flow where all the text will be lowercase i would like to pass in loud because i want to make my text all uppercase so i'm typing the name of the higher order function and passing in a function as an argument and the result is that the word hello will be printed to the console window all uppercase now here's a rundown of what just happened we're calling the hello function and we're passing in loud as an argument we're naming loud as funk while we're within this hello function text equals loud and we're sending a string of text that says hello we're returning that text all uppercase assigning it to a variable called text and printing that text to the console window now if i would like to use the quiet variety of hello then i'm going to pass in quiet as an argument so quiet will make all of this text lowercase alright people so that's example one of a higher order function a higher order function is a function that accepts a function as an argument this hello function is an example of a higher order function because we're accepting either loud or quiet as arguments all right people let's move on to the second part of this definition for higher order functions a higher order function is a function that returns a function i'm going to give a different example this time let's say we have a pair of nested functions the outer function will be named divisor and we will accept a number as an argument that we will call x a divisor is a number that is used to divide another number when using division and inside this function we have an inner function named dividend dividend is the number that's going to be divided and we will call the argument that is passed in y all we'll do is return y divided by x we're dividing the dividend by the divisor y divided by x now within the outer function but not within the inner function we're going to return our dividend function so a higher order function is a function that returns a function divisor is a higher order function because we're returning dividend now if i would like to access this nested dividend function i first need to call the outside divisor function and pass in a number as an argument to serve as the divisor the divisor function is going to return my dividend function which we can then assign to a variable so the variable i'm going to name divide divide equals and i need to call divisor and set a divisor let's say that i would like to divide all numbers by two so i will set x to be two and now for the dividend i will print call the divide variable and pass in a number as the dividend the number that's going to be divided and let's say i would like to divide 10 by two and this will work as you can see we have five in the console window so let me explain what just happened here so our program begins here divisor and we're passing in two x will be two and it will stay that way until we finish this program or until we reassign x now x equals two we're skipping this function because we did not call it yet we're returning dividend and assigning it to a variable and we can call a variable if it has the memory address of a function which is what we're doing in this line now we're calling dividend and passing in 10 so y equals 10 and x still equals to we're returning 10 divided by 2 and printing it to the console window well everyone in conclusion a higher order function is a function that either one accepts a function as an argument or two they return a function the format is a little bit strange and we're not quite used to it yet but in future videos we'll have more practice with high order functions if you would like a copy of all this code i will post all of this to the comment section down below but yeah that is how higher order functions work in python yo what's going on everybody it's bro hope you're doing well in today's video i'm going to explain lambda functions in python so sit back relax and enjoy the show all right ladies and gentlemen let's talk about lambda functions these are functions that are written in one line and use this lambda keyword they accept any number of arguments but they only have one expression think of it as a shortcut they're useful if you need a function for only one use or a short period of time and then you're just planning on throwing away that function afterwards here's the syntax for a lambda function you type lambda you add the parameters followed by a colon and then your expression let's say we have this function named double double accepts one argument that we will name x we're returning x times two effectively doubling it so if i need to call this function i would type double and then pass in a number as an argument so the result if i pass in 5 would be 10. now let's write the same function but instead write it as a lambda function so let me turn these lines into comments now the first step is to type lambda then our parameters we only have one parameter and that is x colon and then our expression we would like to return x times two now this lambda function is going to return a function object and we can assign that much like what we do with variables let's say double equals lambda x colon x times two and in order to call this lambda function we're going to type double then a set of parentheses to call this function and then pass in our arguments so let's say that x equals 5 and then we're going to double it and the result is 10. so that's the syntax for a lambda function you type lambda your parameters colon and then your expression this time let's say that we have two parameters we have two numbers that we want to multiply by each other so let's say that this function will be called multiply multiply equals lambda x comma y because we have two parameters colon followed by our expression we would like to multiply x times y and that is it now in order to call multiply we need to pass in two arguments if i were to pass in just one well we'll have a type error so let's pass in five and maybe six and the result is thirty now let's try three parameters let's say we would like to add three numbers together let's say add lambda x comma y comma z so we have all of our parameters we have our colon here and then we need our expression x plus y plus z and let's add five six and seven together the result is 18. now let's try something a little more complex let's pass in some strings this time i'll create a function named full name full name equals lambda first name comma last name the expression is going to be first name plus perhaps a space plus last name now i need to pass in a first name and a last name full name and you can use your own name for this example if you want let's say bro comma code yep this will print your first name and your last name to the console window now let's take it a step further let's say we would like to check somebody's age once using a lambda function we would like to check to see if they're 18 or older because they're signing up for something perhaps let's say a credit card so let's create a function object age check equals lambda we have one parameter somebody's edge colon and then our expression let's type true if age is greater than or equal to 18 else false to call this age track function we need to pass in an age let's say the user is 12 and they're trying to sign up for a credit card while this will return false let's say they're 18 now and this will return true so that's a lambda function it's a function that is written in one line using this lambda keyword they accept any number of arguments but they only have one expression think of it like a shortcut and they're useful if you need to use a function only once and then you're just planning on throwing it away afterwards so if you would like a copy of all this code i will post all of this to the comment section down below but yeah those are lambda functions in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to show you all how we can sort iterables in python so sit back relax and enjoy the show well well well welcome back everybody in this video i'm going to show you all how we can sort data using python we'll begin with the sort method which is used with lists and the sort function which is used with iterables and that would include lists let's start with something very basic and then we'll crank up the difficulty one step at a time i have a list named students and i have a bunch of student names within this list we have squidward sandy patrick spongebob mr krabs let's say that all of these students are taking a college course perhaps on marine biology what i would like to do is to sort this list in alphabetical order and to do that we have a method that is built in with lists so type the name of your list students dot sort and it's easy as that and to display this list i think i'll use a for loop for i in students print i and there you go that's how to sort a list starting with the top we have mr krabs then patrick sandy spongebob and squidward the sort method of lists can accept keyword arguments there are two optional keyword arguments that we can pass in we can pass in key and or reverse we'll cover key a little bit later if we set reverse to true then our list will be sorted by reverse alphabetical order beginning with squidward spongebob sandy patrick then mr krabs now the sort method does not work with other iterables it's a built-in method for lists if our list of students was instead let's say a tuple well then the sort method is not going to work you can see here that we have an attribute error tuple object has no attribute of sort that's where the sort function would come in because that's useful for other iterables you can also use this for a list 2 i suppose the sort function will return a sorted list so let's use the sort function this time and we'll assign the result to a list called sorted students equals sorted and then we need to pass in an iterable and we have the option of passing in a key and or reverse the iterable that we'll pass in as an argument is our tuple named students so this line will be sorted students equals sorted students sorted students is a list the sorted function will return a list but it accepts an iterable as an argument and to display this we should change 4i and students to 4i in sorted students and now this function will accept our iterable our tuple and create a sorted list and all of these are in alphabetical order and to reverse this we can pass in the keyword argument of reverse equals true and now our list is sorted in reverse alphabetical order all right we're gonna take it up a level welcome to level two sometimes data isn't always as simple here we have a list of tuples each tuple has a corresponding student record we have a name a letter grade for their college course and the student's age now how can we sort this list of tuples by either the student's name their grade or their age well that's where the key keyword argument's going to come in with sorting if you take a look at this list of tuples it somewhat resembles a spreadsheet there's rows and then there's columns the first column corresponds to student names the second column are grades and the third column are all the ages of the students so by default sorting by the first column is actually really easy that's the default so if we need to sort alphabetically that would be the same process as before we would type the name of the list students dot sort but if we were to print this iterable for i in students instead of just the individual student names we're going to get each tuple that we have so now all of these tuples are arranged in alphabetical order starting with the first column that we have which are all the student names now how can we sort these iterables by their second column for this case it would be student grades or even the third column which would be the student ages well that's where the key keyword argument's going to come in this is a keyword argument and we set key equal to a function that's going to return the index of that specific column that we have so let's say key equals grid grade is going to be a function object grade equals and we can easily use a lambda expression for this lambda let's say grades colon grades and we will set an index of one now the first index is zero that's the first column because computers always start with zero column two would have an index of one and then column three would have an index of two so grade equals lambda grids colon grids index one you can also rename these if you want so students dot sort we're setting the key equal to grade and grade is a function object via a lambda function and now all of these students will be sorted by their grades starting with sandy then spongebob mr krabs patrick then squidward if this needs to be in reverse order we can pass in that other keyword argument of reverse equals true and for practice if you wanted to sort all of this data by each student's age then we would change grade to let's say age age equals lambda we'll change grades to maybe ages colon ages and the index would then be two because the first column here is zero then one then two and change key to our function object of edge now each student is sorted numerically beginning with the smallest edge well the youngest person starting with spongebob sandy patrick squidward then mr krabs and like i said before if you want your data arranged in reverse order you can set that keyword argument of reverse to true within the sort method and all of our student data is sorted beginning with the eldest student which is mr krabs then squidward patrick sandy and then spongebob and for the last part of this video let's say that we're working with some other iterable let's say we have a tuple of tuples instead well we can no longer use this sort method because that only belongs to lists you can also use the sort function with lists and it will generate a new sorted list without changing the placement of the original so let's say we have a tuple of tuples and this will create a new sorted list let's call this list sorted students equals then we'll use the sorted function we need to pass in an iterable and we can pass in both a key and or the reverse keyword argument so the iterable would be students and let's set the key equal to edge and i will not reverse it we can keep it as it is but let's change for i in students to sorted students and that's how to use the sorted function to sort an iterable including a list well all right everyone that's how to sort iterables in python if you would like a copy of all this code i will post all of this to the comments section down below but yeah that's a basic way to sort iterables in python hey what's going on everybody it's your bro hope you're doing well in today's video i'm going to show you all how the map function works in python so sit back relax and enjoy the show what up everybody let's discuss the map function the map function will apply a function to each item in an interval that would include lists tuples things like that and the map function accepts two arguments are iterable as well as the function we would like to apply to each item within our iterable for example let's say that we have an online store to represent this i have a list of tuples named store each tuple within this list corresponds to an item for sale within our store there's shirts pants jackets and socks and each item has a price in us dollars let's say now what i would like to do is to convert all of the prices within my store to euros and currently the conversion rate as of the filming of this video is one us dollar to 0.82 euros so let's begin we can easily convert dollars to euros with a lambda function so let's say two euros equals lambda the parameter will be data colon and the next part's a little bit tricky within a set of parenthesis to represent a tuple we'll take data at index 0 that corresponds to the first column comma data at index 1. this represents the index of our prices we're going to take data at index 1 times 0.82 and that's it the first column will be left untouched but the data in column 1 will be multiplied by 0.82 now our map function is going to create a map object but we can easily cast that to a different type of iterable so let's say that store underscore euros equals map parenthesis and then we can pass in our function as well as our iterable our function is our two euros function comma and our iterable is our store and that is it now if you want to convert this map object to an iterable you can easily surround this with a cast i would like to convert this map object to a list and we will now have a new store named store euros which will have all of the different prices of our store in euros and to display this i'll use a for loop for i in store euros print i and let's try it yep that seems about right all of the prices in our store are now in euros let's pretend that these prices are already in euros and we would like to convert these to american dollars so we will use the same conversion rate but divide by 0.82 so let's create a separate lambda function two dollars equals i think i'll just copy this but we are going to divide the first index of data by 0.82 and let's say store dollars to represent our store in dollars because we're pretending now that it's currently in euros and we will display 4i in store dollars so if all of these prices are in euros we are now converting them to american dollars but you may want to do some rounding as opposed to the nearest descent well everyone that is the map function it applies a function to each item in an iterable those include lists tuples the like you pass in your iterable and your function as an argument to the map function so if you would like a copy of all this code i will post all of this to the comment section down below but yeah that is how the map function works in python what's going on everybody it's you bro hope you're doing well and in today's video i'm going to show you all how the filter function works in python so sit back relax and enjoy the show all right all right let's discuss the filter function the filter function creates a collection of elements from an iterable for which a function returns true now what the heck does that mean let me explain let's say that we have a list of tuples named friends each tuple has the name of a friend as well as their age i just made up some ages for all of these friends what i would like to do is to create a separate list for all the friends that are 18 or older so let's say that we're all going out drinking and i would like to create a list of my drinking buddies because they're of drinking age i'm in the united states and the drinking age is currently 21 but i think worldwide is 18 so let's go with 18 for this example since i have a worldwide audience all right now with this filter function we have to pass in our iterable as well as a function to get anybody's edge that is over 18. so let's begin by writing a lambda function for this expression here our filter function so let's say age equals lambda data will be the parameter colon data at index one so the first index the first column in this chart here would be zero for other names the next index of one would be all the ages data at index one is greater than or equal to eighteen and that is it that is our lambda function and now we're going to filter our iterable by this function of age so let's write filter pass in our function which is edge comma and our iterable friends now this filter function will return a filter object you can easily cast this i would like to cast my friends list back into a list and i will assign this to a new list let's say drinking buddies equals list filter age and friends and i should be able to print all of the friends that are 18 or older for i in drinking bodies print i and we have rachel monica chandler and ross well everyone that is the filter function it creates a collection of elements from an iterable for which a function returns true i like to think of it as the search results we're searching for any results that meet this criteria where age is greater than or equal to 18 and then you can create a separate collection or other list if you want from the results but yeah that is how the filter function works in python yo what's going on everybody it's bro hope you're doing well and in today's video i'm going to show you how the reduce function works in python so sit back relax and enjoy the show well i suppose we're on the reduce function today the reduce function applies a function of our choosing to an iterable and reduces that iterable to a single cumulative value the way this works is that the reduce function performs our function on the first two elements of our iterable and repeats the process until only one value remains i kind of like to think of it like we're recycling elements within an iterable until a single value remains our finished product so how is this useful let's say that we're playing a game scramble and we have a bunch of different letters within an iterable a list is a type of iterable so i have a list named letters and we have all of the letters we need to spell the word what i would like to do is to reduce all of these individual elements into a single cumulative value until only one value remains so we can do that using the reduce function you can also do this with the for loop too there's multiple ways of doing this so using the reduce function we're going to import func tools and now let's say we have our cumulative value stored within a variable named word word equals func tools dot reduce now the reduce function has two arguments the function we would like to apply to the first two elements and then our iterable the interval is easy that is just letters so let's put that in letters and for the function we can easily write a lambda function for this lambda and now this function needs two parameters let's say x and y now what kind of function do we want to perform on the first two elements of our iterable let's combine them together so let's say x plus y and now let's print our single cumulative value of word so this should print the word hello i'm fairly confident that the word hello is worth like 20 points in scrabble now let me explain what happened step by step our reduce function applies our function to the first two elements within our iterable it performs this expression that we set x plus y but really we can write anything here so we perform this expression on the first two elements then we repeat the process again using the result from the first time we use this expression and the next element so we're combining x plus y again and then we're just going to repeat this process until only one value remains it's kind of like we're recycling all of these letters and creating a finished product out of all of these that's how i think of it at least here's a different example let's say that i would like to find the factorial of 5 so i have the numbers 5 through 1 within a list named factorial so if i was to find the factorial of 5 via the reduce function i would probably write something like this so let me change word to let's say result result equals functools reduce now our lambda function will be x times y because with factorials we multiply the next two numbers together then we take that result and then multiply the next one in this list so the iterable will be factorial and let's print what our result is so the factorial of 5 should be 120. now let's walk through this we're taking the first two elements of this iterable five and four multiplying together in this case in the last example we concatenated the strings together of x and y in this example we're multiplying them together so we take the first two elements 5 times 4 we take the result and apply it to the next iteration of x times y again so 20 times 3 is 60. we repeat this process again 60 times 2 is 120 and 120 times 1 is 120 so that's kind of how the reduce function works it applies a function of our choosing to the first two elements of an iterable and repeats that process until only a single cumulative value remains so that is the reduce function if you would like a copy of all this code i will post all of this to the comment section down below but yeah that is how the reduce function works in python hey what's going on everybody it's your bro hope you're doing well and in this video i'm going to show you all how list comprehensions work in python so sit back relax and enjoy the show all right everybody so list comprehensions a list comprehension is a way to create a new list with less syntax you can also use a list comprehension to mimic certain lambda functions such as in the previous videos where we use the map and the filter functions and not only that but a list comprehension is easier to read than a lambda function but there is a formula that we're going to follow when we create our list within our list we're going to write an expression for item in iterable now let me give you an example of where a list comprehension would be useful let's take this program that will create a list of all the numbers 1 through 10 squared so if i were to print this we'll get the numbers 1 through 10 whatever their square is right so we have 1 through 10 and the square of 10 is 100 so we wrote this program in three lines of code we're creating an empty list we're creating a for loop and then we're writing an expression for what we want each loop iteration to do now let's write the same program but used a list comprehension and we can write the same program with less syntax so i would write something like this and we're going to follow this formula so our list is going to be named squares equals then within a set of straight brackets we're going to write our expression which is this portion i times i for item so that would be 4i in our iterable that would be range 1 through 11 because remember 11's exclusive and then let's print our squares print squares and there you go we made the exact same program using a list comprehension so basically speaking you just follow this formula you set your list equal to your expression and our expression for this example is i times i for item for i in your interval in range one through eleven so this took three lines of code well if you exclude us printing our list and this program took one line of code now we can also use a list comprehension to mimic certain lambda functions i wrote a program where we will be filtering a list of student grades let's pretend that all of these students took some sort of exam so we have one student that received a 100 90 80 70 60 50 40 30 and then one student got a zero because they didn't show up so what i would like to do is to filter all of these student grades into a list that only contains students that passed and the criteria for a passing grade will be a 60 or above so i would like to filter all passing students and if i was to write this program using the filter function i would probably write something like this so i need a function and then my list that i'm working with lambda x colon x is greater than or equal to 60 will filter all of the results and then convert it to a list named past students so the result will look something like this i have five student grades in here with 100 90 80 70 and 60. now let's write the same program using a list comprehension now there's just one portion to this formula for list comprehension that we're going to add at the end we're going to add if conditional we can check some sort of condition after each iteration so let's write the same program using a list comprehension following this new updated formula that we have so we need our list which will be named past students equals first comes our expression and it's just i for this example for item i in our iterable of students and then if we can check our conditional if i is greater than or equal to 60 and this will have the same effect as our previous program but instead it uses a list comprehension now if your program has multiple output if you need an else statement within your conditional you're actually going to move this portion of the if conditional within our formula to right after the expression so let's write an if else statement here so let's say that instead of just excluding any student that didn't pass we'll replace their grade with the word failed and we can do that using an if else statement so let's do this again i'm going to copy what we have here paste it and we'll move our conditional from the end to just after the expression portion i if i is greater than or equal to 60 and you can see here that we need to add an else statement else will return the word failed so we're replacing each instance of a failing grade with the word failed instead so if your condition returns whatever i is you can just add that to the end if you need an if else statement you're going to add it right after the expression so everybody in conclusion a list comprehension is a way to create a new list with less syntax you can even mimic certain lambda functions which we did with the filter function and it has the added benefit of being easier to read than a lambda function so you just follow one of these formulas depending on what you're trying to do so you need at least list equals your expression for item and your interval if you have a condition that you want to check you just add that to the end of your list comprehension if you have an if else statement then you'll add that to right after the expression so you just follow one of these formulas depending on how you want to write your program so that is a list comprehension if you would like a copy of this code i will post all of this to the comments section down below and well yeah that's how list comprehensions work in python yo what's going on everybody it's bro hope you're doing well and in this video i'm going to explain dictionary comprehensions in python so sit back relax and enjoy the show okay people dictionary comprehensions they're very similar to list comprehensions except they're with dictionaries that's it video over okay but seriously a dictionary comprehension is a way to create dictionaries using an expression and they can replace for loops and certain lambda functions and all we have to do is follow this formula dictionary equals key colon our expression for key value in iterable so let's go over a few examples our first example we're going to take this dictionary named cities in f f is short for fahrenheit i have different city names as keys and relative temperatures as values in fahrenheit so new york is 32 degrees fahrenheit boston is 75. los angeles is 100 and chicago is 50. and what we'll be doing is creating a separate dictionary where all of these temperatures will be in celsius using a dictionary comprehension so let's follow this formula let's create a new name for this dictionary let's say cities in c short for celsius equals and we will follow this pattern first our key golden then our expression we'll go back to this in just a moment for key comma value in our iterable of cities in f and since we're working with a dictionary we're going to use the items method now we just need to fill in this expression there is a formula to convert fahrenheit to celsius and it should be on the screen right about now so let's follow this formula so we'll take our value minus 32 and just for good measure i'm going to put these within parentheses and we will multiply all of this by 5 divided by 9 and that is it so we have our key our expression to convert fahrenheit to celsius for key value in our iterable of cities in f our previous dictionary and let's test this by printing our new dictionary cities in c actually i think i'm going to round these numbers just so it's more readable so let's round all this there we go so new york and celsius is zero boston is 24. los angeles is 38 and chicago is 10. so we created a new dictionary using a dictionary comprehension now with these dictionary comprehensions you can add an if conditional to the end of this so let's say that we have a separate dictionary of weather like a description of the weather in each city new york is snowing boston is sunny los angeles is sunny and chicago is cloudy let's say that we would like to create a separate dictionary with a dictionary comprehension that only has cities where the weather is sunny so i would write something like this let's say sunny weather will be the name of our dictionary equals and we'll follow this formula and then we just tack on our conditional to the end so it's kind of the same as before really so key colon and we don't really have an expression here so let's just say value then for key comma value in our iterable of weather dot items then our conditional if value sunny because we are only looking for sunny weather and let's print this print our dictionary of sunny weather and let me just make this more readable for you guys and our new dictionary comprehension will create a dictionary of key values where the value is sunny using an if conditional at the end of our dictionary comprehension here's a third example for you well if you have an if else condition you can add that to where the expression is within your dictionary comprehension so i'm going to reuse the previous dictionary for the first example where we have cities and their temperatures as values so we're going to replace each temperature with a description of the weather is it warm or is it cold so let's do that using a dictionary comprehension that contains an if else statement so let's say we have a new dictionary named desk short for description cities it's a brief description of each city's temperature so we follow this formula key then our if else conditional for key value and iterable actually i probably can copy all this just to save some time okay so our iterable will be cities dot items and our conditional is going to be we will return warm if our value is greater than or equal to let's say 40. else cold and we will print our new dictionary of desk cities description of cities so new york is cold because it's 32 that's below 40. boston is warm los angeles is warm and chicago is warm now if your condition gets somewhat complex you can even call a separate function to keep your code more organized so key then we can call a function and pass in a value for key value in iterable so i'm going to again reuse our city names and our temperatures and this time we are going to call a function instead i think i'll reuse this code from the previous example where we have a separate dictionary named desk cities and i'm going to replace this if else statement with a function so let's say we have a function that is named check temp and we will pass in our value and we just need to define this function so let's define that here so let's define check temp and our parameter is our value that we're currently working on within our dictionary value then we'll write if value is greater than or equal to let's say anything above how about 70 will return the word hot then else if let's say 69 greater than or equal to value and then value is greater than or equal to how about 40 then we will return the word warm and lastly else return cold and let me just fix some of the spacing now depending on the temperature that is stored within each value of our dictionary we will call a function that will return one of a few different outputs so it's kind of like we're using the map function the map lambda function so let's print our description of cities and we should get a short description of the temperature in each city after we call the check temperature function and then pass in each value from our dictionary so new york is cold because it's 32 degrees fahrenheit boston is hot because it's above 70. los angeles is hot because it's 100 and then chicago is warm because that is 50 which is between 69 and 40 within our function so that is a dictionary comprehension it's a shortcut where you can create dictionaries using an expression and they can replace for loops and certain lambda functions so if you would like a copy of all this code i will post all of this to the comment section down below and well yeah that's how dictionary comprehensions work in python hey what's going on everybody it's bro hope you're doing well and in today's video i'm going to show you how the zip function works in python so sit back relax and enjoy the show all right ladies and gentlemen welcome back we're talking about the zip function today the zip function will aggregate elements from two or more iterables iterables are those things like lists tuples sets etc and the zip function will create a zip object with paired elements from each iterable stored in a tuple for each element within our zip object here's an example let's say that we have two different types of iterables i have a list of usernames and a few usernames within here are dude bro and mr and i have a tuple of passwords and i have some very secure passwords such as password abc123 and guest what i would like to do is to zip elements from each iterable together so that they're in pairs and each pair is going to be stored as a tuple within a zip object and here's how we can do that let's say that we will create a zip object called users and we will use the zip function the zip function will take a varying amount of iterables we're going to pass in our usernames and passwords and zip them together so let's pass in usernames as well as passwords and now our zip object of users is actually iterable zip objects are iterable so we can use them within a for loop so let's type for i in users and print i and what we get is that we have a zip object of tuples and each tuple is storing each pair of elements from our two iterables now users is a zip object and if you don't believe me let me prove it i'm going to print the type of users and this will print that users is indeed a zip object but you can easily convert this to a different type of iterable by using a cast let's say that we would like to convert our zip object into a list so we'll surround the zip function with a cast to a list and now the data type of users is now a list what we have is a list of tuples and each tuple is storing a pair of elements from our two iterables of usernames and passwords now currently since we're passing in only two different iterables we can easily make this a dictionary so that these are key value pairs so let's cast our zip object as a dictionary and to display all of the elements within our dictionary all the key value pairs we're going to change our for loop to this for key value in users dot and we will use the items method print key comma value actually i think i'm going to separate each of these with a colon just to make it more readable and now when we zip these two intervals together we end up with a dictionary of usernames and passwords and the name of this dictionary is users now you're not limited to just two iterables you can add a third iterable or more so this time let's create a maybe a list a list of last login dates and i'll just call this login date equals and why not make a list and let's make up some dates let's say 1 1 dash 20 21 12-20-21 and 1-3-20 21 okay so let's create a zip object of users and we're going to zip user names passwords and login date and let's iterate over this for i in users print i now we have a tuple for each element and instead of a pair we now have a trio i guess of all of the different elements from each iterable so in conclusion the zip function will aggregate elements from two or more iterables and create a zip object with paired or grouped together elements stored in a tuple for each element within our zip object so that is the zip function if you would like a copy of this code i will post this to the comment section down below and well yeah that's how the zip function works in python hey what's going on everybody it's you bro hope you're doing well and i'm going to explain the purpose of if name equals main in python so sit back relax and enjoy the show during your programming journey you may have encountered this strange statement of if name equals main now what the heck does that mean so with python files also referred to as modules by including this statement it gives our modules some flexibility one a module that has the statement can be run as a standalone program or two this module can be imported and used by other modules if there's some sort of useful functions or other resources within this module to be imported by including the statement of if name equals main we're checking to see if a user is running this module as either a standalone program or they're importing it from another module behind the scenes the python interpreter will set special variables one of which is double underscore name it's a variable and python will assign the name variable a value of main if it's the initial module being run and we can actually test that by printing double underscore name so since this is the initial module being run module one for my example name is going to be assigned a value a string of main now check this out i have two modules what if i were to import module 2 and check the name variable of module 2. let's try it import module two in order to access a variable from another module i need to type the name of the module module two dot and i would like to check the special name variable of module 2 and print it so when you import a module this name variable is going to be assigned the name of the module in this case module 2. this time what if we change the roles around i'm going to copy all of this text and paste it within module two we're going to import from module one we will print that special name variable of this module module 2 and then print the name variable of module 1 which is being imported now when i run this program i'm going to instead run from module 2. now this time that special name variable of module 2 is main and the special name variable of module 1 is module 1 the name of the module so by including a statement such as if name equals main we're checking to see if this module is being run directly or indirectly so let's test it within this statement of if name equals main let's print running this module directly else that must mean that we're running this module indirectly so let's print running other module indirectly okay so i'm going to go to module 1 and run from here running this module directly now let's do the same thing with module two but we need to import module one and let's run for module two running other module indirectly for the time being i'm just going to write pass within our if name equals main as a placeholder and get rid of our if statement so let's say within module 1 there's a useful function or resource we would like to access from module 2. so let's say we have a function named hello and all this will do is print the word hello let's just pretend that it's a useful function not really but let's pretend so in order to use this function from module two i need to import module one then type module one dot and then the name of the function so i'm going to run from module 2 and this will print hello but what if i run this program from module 1. so right now module 1 cannot be run directly as a standalone program so i cannot print the word hello so what i could do is within if name equals main i can call that hello function directly so let's run from module one hello one other thing that you might see too within the if statement if name equals main there might be a call for a main function and you can write the main body of your program within a main function so everybody in conclusion the reason that people may include this statement if name equals main is that it allows our modules to have some flexibility they can be run as a standalone program or they can be imported and used by other modules and this is because the python interpreter sets that special variable of name with a value of main if it's the initial module being run if you would like a copy of my code and my notes i will post all of this to the comment section down below but yeah that's the purpose of if name equals main in python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to show you all a few useful functions related to times and dates using the time module in python so sit back relax and enjoy the show alright everybody so the time module let's begin by importing time and the first thing that i'm going to explain to you while is how we can find our computer's epic also pronounced as epoch so this is a date and time in which your computer thinks time began think of it that way at least so we use our epic as a reference point so to find your computer's epic it's going to vary based on your computer and your operating system so to find your computer's epic type time dot c time and as an argument we will pass in zero now what this method will do is that this method will convert a time expressed in seconds and convert it to a readable string so if i was to pass in 0 and print it well then this will display the date and time which is my epic our reference point so for me my epic is wednesday december 31st 6 p.m 1969 so i've just added a note that the c time method will convert a time expressed in seconds since epic and convert it to a readable string a readable date and time so for practice let's pass in perhaps 1 million seconds and see what date and time that we receive so our c time method will return a date and time one million seconds past this epic here so that would be for me monday january 12th about 7 a.m 1970. our next method is the time method of the time module let's print time dot time method and what this method will do is return the current seconds that have passed since our epic using our computer's clock so the number that i end up with is just over 1.6 billion and this is in seconds so for me 1.6 billion seconds has passed since that date which is my epic i believe it was december 31st 1969 and every time that i rerun this program you can see that the amount of seconds that has passed is actually increasing so that is the time method it will return the current seconds since you're epic using your computer's clock and you know what just for fun let's change the date and time under clock and see what happens so let's change the year to how about the year 2000 change and close so let's see what number we get with the time method now so we get just under 1 billion 948 million seconds have passed and now if you need to retrieve the current date and time well there's one of a few ways in which you could retrieve that but one way is that we can combine both of these methods of the see time method and the time method of the time module so let's print time dot c time and we're going to pass in an amount of seconds into the c time method as an argument so within the c time method we're going to call the time method so the time method will return an amount of seconds since our epic and the c time method will convert that amount of seconds to a readable date and time so the current date and time is saturday january 23rd about 3 p.m 20 21 now there is more than one way to get the current date and time another way is to use the local time method and the local time method will create a time object based on the current time so what i'm going to do is create a variable called time object and i just need to explain a few things about time objects so to best explain this i'm going to print our time object now a time object is also referred to as a struct time object it is made up of different keyword arguments there's a year a month day hour minutes seconds day of the week day of the year and this keyword argument here has something to do with daylight savings time so there's quite a few uses with time objects and one way is that we can format them however we want because right now this time object is not in a readable format so to convert this time object into a readable string we'll need the help of a separate function and that is the strf time function str is short for string f4 format and time well for time i guess so this function needs two arguments a format and a time object so our strf time function will accept a format and a time object as an argument so our format is really just a string of different directives and to best explain these i'm going to head to python's official documentation on the subject so here i am on python's website regarding the time module and underneath this section on the strf time function there are different directives that we can embed within our format string that we pass in as an argument depending on the directive that we add we can display a certain format of our date and time so for example if i was to pass in let's say percent lowercase a then we will display the time object's weekday name and you're not limited to just one directive you can add any combination of directives so if i was to add percent m well we would display the month of our date time object as a number 1 through 12. so there's a bunch of directives here and i'm going to be using some of these so within a string for the format argument i'm going to pass in percent capital b for the name of the month percent d for the day percent y for the year percent h for the hour and to format this i'm going to add a colon to separate hours and minutes percent m for minutes colon percent s for seconds and then we are going to assign all of this to a variable let's say local time and local time will be a string so let's print our local time and the current time is january 23rd 2021 about 3 p.m oh and i almost forgot you can also get the utc time that is the coordinated universal time if you know how that works so if you need that you would just use the gm time method for the utc time coordinated universal time okay next up we have the strp time function and this function will parse a string representation of a time and or date and return a time object so we need to pass in a string representing the date and or time as well as a format string so let's create a time string and this variable is going to be a string representation of a date let's say 20th of april 2020 and what we can do is take this string representation of a time and or date and parse it to a time object so we're going to pass in our time string variable as well as a format string so let's say i would like to parse the day so that would be percent d for day then percent b for name of the month and then comma percent y for year this function will create a time object so let's assign that to a variable time object equals time dot strp time we're passing in our string representation of a time or date as well as a format string and we can print our time object using a print statement however this is going to be in a form that is somewhat difficult to read but you can see at least we have a time object with all of these keywords filled in with anything that we passed in via these format directives that we have now the next function is the asc time function and this function accepts a time object or a tuple representation of a relative time so this time let's create a time tuple and we're going to follow this order we can pass in up to nine values the first value is a year so let's pass in perhaps 2020 a month let's say four a day how about 20 four hours let's say four minutes 20 and seconds maybe zero let me just fix some of the spacing here okay you can also pass in a numbered day of the week um i'm just going to say zero i don't think it's really that important a day of the year zero and negative one or zero for daylight savings time so we created a time tuple and we can pass in a time object or a tuple representation of a time following this formula so let's pass in our time tuple and this will create a time string a string representation of the time that we create and let's print our time string and we should have april 20th about four in the morning the year 2020. so that is asc time it will convert a tuple representation of a time and date or a time object and convert it to a readable string now another option is to use m k time and mk time will take a tuple representation of a time or a time object and convert it to seconds since epic so april 20th of the year 2020 is about 1.5 billion seconds since our epic date and for me that was december 31st the year 1969 so that is a few useful functions of the time module if you would like a copy of this code i will post all this to the comment section down below and well yeah that's the time module in python yo what's going on everybody it's bro hope you're doing well and in this video i'm going to explain multi-threading in python so sit back relax and enjoy the show think of a thread as a flow of execution like a river and each thread can carry out its own separate order of instructions if we use this process of multi-threading we can have our program run different parts of its program at different times they all run concurrently but not truly in parallel that is a concept for later referred to as multi-processing so with reds they each take a turn running to achieve concurrency this is due to a notorious feature known as the gil the global interpreter lock only one thread can be running at one time but they can all take turns when one thread is idle so this allows one thread to hold control of the python interpreter at any one time so they run concurrently but not truly in parallel which is what we do with multi-processing now programs and tasks can be divided into two different categories they can be cpu bound that is a program or a task that spends most of its time waiting for internal events such as a task that is cpu intensive it is better to use multi-processing for tasks that are cpu bound now tasks that are io bound means that the program will spend most of its time waiting for external events such as waiting for user input or if you're doing activities like web scraping you do a lot of sitting around so with i o bound tasks it's better to use multi-threading because we can have multiple threads running concurrently but not truly in parallel like what we do with multi-processing after importing the threading module we can count the number of threads that are currently running in the background whenever we run a program we have one thread that is running that is in charge of executing our program and we can print the active count of threads running in our program using the active count function of the threading module so this will print one we have one thread that is running and we can print a list of all the threads that are running by using the enumerate function so the one thread that is in charge of running our program is referred to as the main thread by using this concept of multi-threading we can have more than one thread running concurrently not truly in parallel all the threads will take turns while one of them is idle so we can have more than one thread running more than just the main thread which is in charge of running the main body of our program so while our main thread is in charge of running the main body of our program we can have another thread that's in charge of a separate part of it maybe like a countdown timer or something so one good example take that quiz game that we made some number of videos ago while we were waiting for user input which is a i o bound task we could have had a countdown timer going like you only have so many seconds to answer this question we could have had one thread in charge of waiting for user input and another thread in charge of the countdown timer so that's an example of multi-threading we had two threads running concurrently and what we'll be doing in this video is creating a program that involves multi-threading we can have different threads in charge of different parts of our program and they can all run concurrently they'll all take turns while one of them is idle so let's say that we're running late for school or work in the morning and we have three different tasks that we need to complete before we can leave for school or work so think of three different things you do in the morning such as maybe eat breakfast some people drink coffee or maybe a beverage of your choice so drink coffee and some people like me they like to do their homework last minute so i'll say study before i leave for work or school in the morning so what we'll do in each of these functions each of these functions should take some amount of time to complete so we can have our main thread sleep for a given number of seconds using the sleep function time dot sleep and let's say that in order for me to eat breakfast this task will take me three seconds let's just pretend that instead of minutes this will be in seconds so drink coffee will take me four seconds and study will take me five seconds then when we finish sleeping let's print a confirmation message let's say you eat breakfast as in you finish eating breakfast with drink coffee you drink coffee and with study you finish studying now each of these tasks are i o bound they're going to be spending a lot of time just waiting around for external events they're waiting for the sleep function to expire before they can finish their task so we're going to have all of these three functions run on our main thread and we'll see how long it takes for us to complete our morning ritual these three tasks so let's call these three functions within our main thread so let's call the eat breakfast function first followed by drink coffee and then study in that order so this program is going to take approximately let's see 12 seconds to complete so there's going to be a pause for a second you eat breakfast then followed by you drank coffee and then study you finished studying so this program took about 12 seconds overall so if this were realistic what we would have done is we would sit down and eat breakfast for three minutes well three seconds in this case and then once we finish eating breakfast only then are we allowed to drink our coffee and once we finish our coffee only then can we study so we completed these tasks sequentially and not concurrently for us to move down to the next function we need to complete the previous functions because we're doing this in order but realistically us human beings we would probably eat breakfast drink coffee and study altogether because we can multitask and we can complete these three functions in less time and that's kind of the same process as multi-threading we can have these three separate functions running concurrently as if we're multitasking we're eating breakfast drinking coffee and studying all at once now currently we have one thread that is in charge of these three separate functions what we could do is that we can create three additional threads each thread will be in charge of each task and then we'll have our main thread running in the background that will complete the rest of the program so this is how to create an additional thread let's say that x equals threading dot thread we need to pass in a target target equals and then the name of the function so let's say thread x will be in charge of eating breakfast and then you can pass in arguments too if your function has parameters by typing args and then you pass in a tuple so let's say you have one argument to pass in you'll type your argument followed by a comma but we don't have any arguments in this example but you'll need to be sure to enter them in if you do have any okay then to begin this thread you type the name of the thread in this case x dot start so we now have an additional thread and this thread is in charge of eating breakfast now let's create another thread to drink coffee and we'll call this y and the target will be drink coffee and lastly we have a thread in charge of studying and this will be z and the target is our study function okay now let's see how long it takes for us to complete our program oh and be sure to comment out these function calls within the main thread because we don't want the main thread in charge of those anymore okay now we can run the program so we have four threads running this time you eat breakfast you drink coffee you finish studying so this program took approximately five seconds to finish and the reason that this program took five seconds instead of 12 is because before our main thread was in charge of running these tasks sequentially in order but now since we have a thread dedicated to each task we can run them all concurrently instead of sequentially so that this program now took about five seconds to complete and you may have noticed too that the activecount function as well as the enumerate function were called before threads 1 2 and 3 finished their respective tasks that's because the main thread is not going to wait around for these three threads to complete it has its own set of instructions to do so it is no longer in charge of these three functions the program is going to handle those three functions to our three threads and our main thread is going to continue its own set of instructions its job is to print the active count as well as call the enumerate function which it did and it finished its tasks before threads one two and three now one trick that you can do too is that you can use the time modules performance counter function and this function will return how long it takes our calling thread as in our main thread to finish its set of instructions so our main thread is not in charge of executing these three functions our main thread is in charge of creating three additional threads and then calling the activecount function and the enumerate function as well as the performance counter function so our main thread will take approximately 0.075 seconds to complete and our three threads are still running in the background our main threads job its order of instructions is to create three additional threads and then immediately print whatever is returned via the activecount function enumerate and then your performance counter so our main thread says that it finished its tasks in about .07 seconds but threads one through three were still trying to catch up that's why the main thread finished before are three additional threads and once all active threads have completed their tasks then your program will finish and exit there's also this concept called thread synchronization we can have a calling thread in this case our main thread wait around for another thread to finish before it can move on with its own instruction set so let's say we would like our main thread to wait around for thread 1 also known as x so we're going to use the join function of thread x and now our main thread has to wait around for thread x also known as thread 1 to finish before it can move on with its instruction set so let's do the same with y and z so now our main thread before it can move on with the rest of the program has to wait for all of these threads to synchronize and join and then and only then can it move on with the rest of its own instruction set so this time our program is going to look a little something like this you eat breakfast you drink coffee you finish studying so by the time we reach our active count these threads are already joined and synchronized they're no longer active when we enumerate over our active threads we only have our main thread and our main thread completed in about 5.1 seconds this time because it did a lot of waiting around it was waiting for threads x y and z to join and finish in conclusion a thread is a flow of execution like a separate order of instructions that a program can follow and when we run a program we always have at least one thread running initially and that is referred to as the main thread however if you have multiple threads using the concept of multi-threading we can have multiple threads running concurrently but not truly in parallel which is what we'll cover during the video on multi-processing this is due to a feature known as the gil the global interpreter lock which allows only one thread to hold control of the python interpreter at any one time and tasks can be either cpu bound or io bound a cpu bound task is a program or task that spends most of its time waiting for internal events such as a task that is cpu intensive and o bound tasks spend most of their time waiting for external events such as waiting around for user input or web scraping with i o bound tasks it's better to use multi-threading with cpu bound tasks it's better to use multi-processing well everybody that is a quick overview of multi-threading i will post all of this code to the comment section down below and well yeah that's how to achieve multi-threading using python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to explain demon threads in python so sit back relax and enjoy the show okay so demon threads also pronounced as daemon threads a demon thread is a thread that runs in the background and they are normally not important for your program in order to run your program will not wait for demon threads to complete before exiting whereas non-demon threads they cannot normally be killed they will stay alive until their task is complete so a few common uses of demon threads would be background tasks garbage collection waiting for input or other long-running processes so here's an example of why demon threads would be useful let's say that we'll have two threads our main thread will be in charge of waiting around for some user input we'll ask do you wish to exit and in the background we'll have a timer going that will display how long somebody is logged in so let's create a function named timer and what we'll do is just display how long somebody's logged in so let's say we have a count variable while true we'll use the sleep function of the time module to sleep for approximately one second then we'll increment our count variable by one and we'll print a message so let's say logged in for count seconds and let's create a thread that will be in charge of this timer and run it in the background so let's say x equals threading dot thread the target will be our function of timer and we need to start this thread x dot start so our thread x will be in charge of our timer and run it concurrently while we're waiting for some user input our main thread will be in charge of waiting for this user input do you wish to exit now here's the issue of us using a non-demon thread for a background task such as a countdown timer so our main thread is in charge of waiting around for some user input and thread x our additional thread is in charge of running this countdown timer so if i wish to exit this program i'm just going to type okay and hit enter well my background timer is still going but my main thread is complete so i would like to exit this program but my program will not exit as long as there are non-demon threads that are still alive we cannot normally close this program unless we do like a brute force you know close and exit of the program so we can turn this thread of x into a demon thread so that when we wish to exit the program when there are no more non-demon threads alive and to change a thread to a demon thread it's actually fairly easy when you create your thread you can set this flag of demon equal to true and that's it so when all non-demon threads have finished their tasks your program will complete and exit but if there are demon tasks running in the background they will be killed automatically so let's try this program again so do you wish to exit my program is going to continue running my demon thread is in charge of the timer and it's going to continue running until all non-daemon threads have completed their tasks so once i type ok my program will finish running and my countdown timer will stop because all demons are killed when your program is finished running there's also two additional methods that you might be interested in you can use the set daemon method of a thread and you can set it to false or true if you would like to change a thread to a non-demon or a demon however if your thread is currently running well you cannot actually change it from a non-demon thread to a demon thread while it's currently running so you would have to do that before you actually use the start function and you can also check to see if a thread is a demon or not by using the is demon method this will return true or false so everybody in conclusion a demon thread is a thread that runs in the background and they're not important for your program in order to continue running your program will not wait for demon threads to complete before exiting the program whereas non-demon threads cannot normally be killed they will stay alive until their task is complete and demon threads are commonly used for background tasks garbage collection waiting around for input or other long running processes so if you would like a copy of this code i will post all of this to the comment section down below but yeah those are demon threads in python yo what's going on everybody it's bro hope you're doing well and in this video i'm going to explain multi-processing in python so sit back relax and enjoy the show what's up let's talk about multi-processing multi-processing is the act of running tasks in parallel on a different cpu cores it's different from multi-threading although it sounds similar because with multi-threading we're limited to running one thread at a time because of the gil that lock which is used for threading we can run threads concurrently but not in parallel however with multi-processing we can create processes and we can run each process in parallel on a different cpu course so with multi-processing it's better for tasks that are cpu bound where you need heavy cpu usage whereas multi-threading that is better for i o bound tasks where you do a lot of waiting around so before we begin i recommend these two imports multi-processing and time let's begin quick note if you're running the windows operating system you'll probably need to add this line if name is equal to main so when we run a program we have a main process that is running and if we create a child process from that process it's going to copy the module that we're currently working with and that child process will create its own children processes and it's going to be a problem so we're going to add this line if name is equal to main so when we create a child process it will copy our module but it's not going to execute it so let's create a main function and a majority of our code is going to be within our main function if you're running a different operating system you probably don't have to do this but if you're running windows you probably will now with multi-processing multi-processing is better for tasks or functions that are cpu bound where they require heavy cpu usage let's say that we have a function named counter and we'll pass in a number to count up to but the number we're going to pass in is a ridiculously large number like a billion so let's create a function that will count from zero so count equals zero and while count is less than our number that we pass in we will increment our counter by one so that is the function that we'll call with our processes that we create now within our main function we'll create a process and to do that you'll need the multi-processing module so import process and cpu account and we'll save this for a little bit later to create a process let's say we have process a a equals process this step is very similar to creating a thread we have a target our target will be our function of counter and if we have arguments we will pass those in so remember with our arguments we have to pass in a tuple since we only have one argument to pass in to differentiate this from an expression we have to add a comma at the end so our number let's say is 1 billion so that's a million 10 million 100 million 1 billion let me just verify that okay so that's 1 billion we're going to count from zero to a billion and in order to start this process a my process use the start function and then i will use some process synchronization by using the join function my main process is going to wait around for my child process of a to finish before continuing and let's print our performance counter so we'll print finished in let's say time dot performance counter seconds okay so let's see how long it'll take to count from zero to a billion using one process i fast forwarded this video but it took my program 56.7 seconds to count from zero to a billion but we can speed this up by using multi-processing let's create a second process named b and i'm going to divide the amount of work in half so each process will count to 500 million half of a billion so let's change a to b and i'm gonna group these start functions together just so it's easier to read and then b dot join just to synchronize everything okay and then let's change 1 billion to 500 million for each it's the same amount of work but divided among workers so that is 500 million let's see how well it runs this time so it took my program about 40.3 seconds to finish counting from zero to a billion but i divided that task among different processes each of my two processes counted from zero to 500 million this time so this time let's create four processes so we have a b c and d and we'll need to start them and i'm going to join them now this might not actually speed it up for you and i'll explain why later it depends on the amount of cpu cores that you have okay so oh let's change this to so 250 million for each okay see you in a couple seconds okay welcome back so on my computer when i ran four processes and each was counting up to 250 million i could finish my program in 27.3 seconds now for me if i created more processes than this it would probably take longer and here's why so you can print the cpu count of your computer using this function of cpu count so if i were to print whatever this function returns i can get the count of the number of additional processes that i can run for the time being i'm just going to comment out this start function because i just want to print whatever this value is so my cpu count on my computer is four so i can run four additional processes but let's attempt to run eight processes so i'm going to copy all these and let's say that we have e f g and h and we will start all of those two so give me a second just to start them so a b c d e f g h and then i'm going to join all of them e f g and h okay so let's run this now oh and change the arguments to i keep forgetting to do that so let's say 125 for each so 125 million times eight is one billion okay see you in a bit all right welcome back this time when i had eight processes working it actually took me longer than when i had four processes working when i had four processes working it took me about 27 seconds this time it took 30 seconds when i had eight processes working that's because i had more processes than my cpu count and that's partially because whenever you create a process there's significant overhead with beginning and destroying a process and if i can only run four processes on my computer at one time well then i'm creating additional processes to no extra benefit it's actually hindering the performance of the computer because i'm creating all of these additional processes when it really doesn't help me in conclusion multi-processing is the concept of running tasks in parallel on different cpu cores it's similar but different from multi-threading because with multi-threading we can run tasks concurrently but they're all taking turns because of the gil with multi-processing we can run all of these different tasks together in parallel multi-processing is better for cpu bound tasks where a task has heavy cpu usage and multi-threading is better for i o bound tasks tasks that involve a lot of waiting around so that's multi-processing if you would like a copy of all this code i will post all of this to the comment section down below but yeah that is how multi-processing works in python hey what's going on everybody two bro here hope you're doing well and in this video we're going to be creating our very first graphical user interface in python so sit back relax and enjoy the show welcome one and all today we'll be creating our very first graphical user interface in python also known as a gui for short we're going to be using the tk inter gui which is a module that is included with python our first step in order to use tk enter is to import this module so that we can begin using it our first line of code will be from tk enter import asterisk this will import everything related to the tk inter module and with this import we can now use all of the gui features that this module has to offer now there is one important distinction that we need to make we need to discuss the differences between windows and widgets here's a few quick definitions that i definitely did not copy from the internet widgets are gui elements such as buttons text boxes labels images you name it and windows they serve as a container to hold or contain these widgets for this topic we'll be creating and customizing our own window and in future topics we'll be exploring different widgets that are available to us so let's begin by creating a simple window and we should give our window a unique name such as window that's pretty creative and in order to instantiate this window we're going to follow this window name with equals tk make sure you get the capitalization right this is a uppercase t and a set of parentheses to serve as the constructor what this will do and i'm just going to add a comment is instantiate an instance of a window for us and when we compile and run this nothing appears to happen that's because we only instantiated our window and we're not actually displaying it in order to display our window we're going to follow this with the name of the window dot main loop and this will display our window and this is our first graphical user interface and we'll be adding widgets to this window so i'm going to add a comment that this will place window on computer screen and it will also listen for events but we'll get to that in future videos now what we'll be doing is customizing the appearance of this window let's begin by changing the size and we can do that with the geometry function so we're going to first begin by typing the name of our window which is window follow this by using the geometry function and we pass in a width and a height but make sure this is within quotes and set this to whatever width and height that you want so if i want 420 by 420 that would be 420 x 420 and the size of our window is now the size that we set with the geometry function now take a look at the top left of this window we have this feather icon as well as a title of tk that's kind of lame so let's change that let's first change the window title and there is a function to do that so we type in the name of our window window dot title function and we can pass in a new title that we want to set and i will set the title to be maybe bro code first gui program that'll work and we now changed the title of this window and it says bro code first gui program the next thing that we can do although not necessary is that we can change the icon of our window bar at the top i would like to replace this feather icon with an image of my choosing here's my desktop don't mind all of the clutter and i would like to use this image of the logo for my channel and set this as the icon for my window so what i'm going to do is copy and then go to my project folder and then paste it click ok and i now have this image within my project folder but it's in a format that we cannot use currently we need to convert this to what's called a photo image that is a format that tk enter can use so we'll need to convert our image to a photo image so do that anywhere within the window between window equals tk and window.main loop right here is good i suppose we're going to create a photo image from this image and this is a png file but yours might be something different so let's give our photo image a unique name like maybe icon and in order to create a photo image we'll follow this with equals photo image and within the constructor of our photo image there is an option for file we can either list the file name or the file path if it's somewhere else on your computer since this image is within my same project folder i only have to list the file name and this is called logo.png and this is probably going to be named something else for you though so we now have this photo image called icon that we can use and i need to set the icon of my window to this icon and luckily there is a function to take care of that for us type in the name of the window which is window dot and we're going to use the icon photo function there are two arguments the first we're going to set to true and the second is the photo image that we want to use and this photo image is called icon so we're going to pass this photo image as an argument to this function of icon photo and now when we compile and run this the image that we wanted to use is now set for the top left icon of this window bar however it loses a lot of the quality since the dimensions are so small but you can still tell that it's my logo though so that's how to replace the icon of your window bar in the top left corner now let's change the background color of this window and one way in which we can do that is to use the config function you can use the config function anytime that you want to make any changes to this window so let's change the background color here and there is an option called background and we can set this equal to either a color name or a hexadecimal value let's begin with just some color names let's say that i want the background color to be black i'll just type in the word black here and this will change the background color of my window to black alternatively you can set a hex value as the color so if you were to look up or google hex color picker you can select whatever color you want let's say that i want a sky blue color like this well this is the hex value i'm going to copy this value and then paste it within the option for my background make sure you have this hashtag as well because that represents that this is a hex value so now the background color is that sky blue color that i picked well everybody that's the basics of creating a window in python and in future videos we're going to be exploring different widgets that we can add to this window that have some functionality so if you would like a copy of all this code i'll post all of this in the comments down below but yeah that's how to create your very first gui in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create labels in python so sit back relax and enjoy the show what is a label well i'm glad you asked that question it's an area widget that holds text and or an image within a window so to begin we'll need to create a window to act as a container to hold this label we can create a window with window equals tk followed by window.mainloop and this will give us a window in which we can add a label to now let's give our label a unique name such as label and in order to instantiate a label we'll follow this label name with equals label with a capital l and a set of parentheses the parentheses are acting as the constructor for this widget our label and we can pass in arguments into these parentheses the first argument that we're going to pass in is a master the container for this label we're going to pass in the name of our window because our window is acting as the container with widgets in python we can de-eliminate the arguments that we're passing in with a comma and there are options available to us options are keyword arguments that we can pass in to the constructor for this widget one option available to us is text and we can set the text of this label equal to a string that we set so let's say that we want this label to say hello world well we're going to pass in this option text and it's a keyword argument so if we were to do this we're going to set the text of the label but this label currently doesn't appear within our window what gives bro i thought you knew how to code hold up wait a minute there's one more thing that we need to do so we're going to actually add this label to the window now we set the master of the label to be our window but now we actually have to add it as step two one way which we can do that is to use a pack function of our label so follow label equals label and pass in all of your arguments and then follow this with the name of the label dot pack so with the pack option by default this will place our widget in the top center of our window another way in which we can add a label to a container or window is to use the place function and we can set some coordinates of where we want this label or other widget to appear within the window if we want this to appear in the top left corner we can set x to equal zero and y t equals zero and these are options available to us too that we can pass in so this place function will place our label at some position or some set of coordinates within the window and with x equals 0 and y equals 0 that will place our widget in the top left corner of the window and if i were to change these to let's say x equals 100 and y equals 100 well this is going to be placed down by 100 pixels and to the right by 100 pixels so you can use pack or place there's a few others like grid but they're a little more complex so we'll get to that in a future video for the time being i'm going to use the pack function of the label and turn this place function into a comment dot pack all right now how can we customize this label we can pass in different options when we instantiate this label let's change the font and that's another option we can change the font with font equals and then we can pass in a font let's begin with a font family i will say maybe ariel a size perhaps 40 and then a style if you so choose like bold there's also italic and underline uh but this will work just fine then so this will change the font of the text of our label and it says hello world still now let's change the foreground color so that is another option the foreground is the font color and the option is fg for foreground it's short for foreground foreground equals we can state a color name such as green and our text should now be green you can select something more specific by passing in a hex value so a custom color that i like is hashtag zero zero ff00 this is bright green you can always look up what different hex values are and we can also change the background color too that is bg short for background color and we can pass in a color name or a hex value i'm just going to set this to black just to demonstrate that we can pass in both either hex values or color names and what we have is green text on a black background and this is the limits of our label within the window because when we expand this window the label is still going to stay the same size if we were to change the text within the label our label is only going to take up the room that it needs and you can see that our label is now smaller now we have all of these arguments within our constructor and it's getting a little bit difficult to actually read so i'm going to separate each of these arguments line by line just so that this is more organized but it'll work just the same as it did before now how do we add a border around our label one we can set the border style with the relief option and one border that i like is raised but right now the border width is one so it's a little difficult for us to actually see the border let's increase the border width with the option bd and i'll set this equal to maybe 10. so this border is now more visible another relief which is the border style is sunken and this will give our label a sunken appearance but i think i'll change this back to raised we can also add some padding around the text between the text and the border we can pad x and pad y pad x will add some padding some space between the x-axis of our text between the border so let's set this to maybe 20 and we now have 20 pixels worth of space between the text and the border let's also pad y this will add some space above and below our text between the text and the border now how do we add an image to a label we first need to create what's called a photo image and we will create this within the lines of window equals tk and window.main loop and let's give this photo image a unique name like photo and in order to create a photo image we're going to follow this with photo equals photo image and within the constructor of our photo image there's an option called file and we can list a file path or a file name right now on my desktop there is a image that i want to use and i need to convert this to a photo image here's my desktop and this is an image that i want to use to add to my label i need to get the file path and i can get that by going to properties then underneath location i can copy this location address and paste it within the quotes for file and then i need to add the image name and this is person.png and with these backslashes these need to be double backslashes because that is the escape character for a backslash but what would be a better option is to add this image to my project folder that contains the python file that i'm working with so in place of listing the entire file path i'm going to copy the image that i want to use go to my project folder and then paste it and i no longer need this entire file path i can just list the image name that i have and now what we need to do is add this photo to the label and there's an option to do so that is the image option and we'll place this within the constructor for the label we're going to set image equal to the photo image that we have and our photo image is called photo this will add our photo image to our label or other widget depending on what we're working with so we have our image but it replaced all of the text that we had for this label how do we add both text and an image to a window well we can follow this with the compound option we can set a direction of where we want this image to be placed relative to the text that we have so i'm going to set compound equal to bottom so that the image appears on the bottom or underneath our text so we can both have text and an image or if i want this to be in a different location i could set this to maybe top left or right if i were to set this to top we have our image on top of our text and one thing to know about labels and many other widgets in python is that the size of the widget will actually increase to accommodate the size of all the components that's contained within if i were to give the text a longer string of characters such as bro do you even code then the width of our label is actually going to expand to accommodate the size of the longer string of text that we have so that's the basics of labels everyone if you would like a copy of all this code i will post all of this in the comments down below but yeah that's the basics of labels in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create buttons in python so sit back relax and enjoy the show buttons you click them and then they do stuff that's pretty much it so this is how to create a button in python we'll need a window window equals tk followed by window.main loop let's call our button just button and in order to create this we'll follow this with equals button and within the constructor for this button we're going to list what we want to add this button to what is the master the master is the window and in order to display this button we're going to follow this with button dot pack and we should have a small rectangular button within our window but it doesn't display any text nor does it do anything so let's add some text and there is an option to do that within the constructor we're going to list the option for text and set this to whatever text you want to display let's say click me and then when we run this our button now says the text that we set and it says click me however it currently doesn't do anything though we need to set a command that is another option command equals and we list a function name this is what's known as a callback so let's create a function called click and then outside of the window let's define what our click function does def click and let's print a message you clicked the button now with the command we're going to list the function name without the parentheses so make sure you're writing it as this and not that this is what's known as a callback so when we click on this button it's going to perform our callback and perform whatever is within our function click just like that let's customize the appearance of this button i'm going to change the font that is another option font equals and let's pick a professional font such as comic sans it's very professional and i'll set a size of 30. and now you can actually read what's on this button it's large enough let's set the foreground color that is the font color fg you can place a color name or a hex value here i'll pick green that is 0 0 ff00 and our text should now be green which it is let's also change the background color that is bg i will pick the color name of black and now we have green text on a black background notice that when i click on this button or hold my mouse button down the color scheme has changed that's because there is a different active foreground and active background and we can change those too so that this won't flash every time you click on the button so let's change the active foreground and active background those are other options active foreground and i'll set this to the same color as my foreground which is green so the text color is going to stay the same and i'll also change the active background and i will also set this to black to match my background and then this should no longer flash when we click on our button if you need to disable somebody from clicking on this button there is an option to do so and that option is the state option and normally this is active but you can set this to disabled and we can no longer click on this button and you can see that the color scheme has changed too it's all grayed out and whatnot so i'm going to replace this back with active because we still have a few more things to do now how do we add an image to a button there is an image option and we set this equal to a photo image but first we need to create a photo image i have this photo of a like button a thumbs up that i want to use i need to create a photo image from this image file so within the window let's call this photo image just photo photo equals photo image then i'm going to list the file path or the file name since this image is within my same project folder i only have to list the file name and this is called like.png but if you use your own image it's probably going to be named something else then i need to set the image equal to my photo image which i named photo but the photo replaces the text on this button but it still works the same so we would like to display some text as well as our image we need to use the compound option and we list a direction we can list top bottom left right we want this image to be on the perhaps bottom so let's list the bottom and now when we run this we have our text as well as our image and if we changed compound to a different direction like top then the image is going to be displayed on the top relative to the text what if we wanted to count the amount of times that we clicked this button we could create a variable called count and we'll set this equal to zero but in order for us to access this count variable within the function of click we're going to list count as global so that this is a global variable every time we click this button let's increment our variable count by one by saying count plus equals one and then we will print whatever the value of count is so within a print statement we'll just say count now when we click on this button we have access to our count variable that's outside of this function and every time we click on this button it's going to increase our count variable by one well everybody that's the basics of creating buttons in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of buttons in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create a simple entry box in python so sit back relax and enjoy the show if you find this video helpful please remember to like comment and subscribe your support will help keep this channel running alright my fellow bros in this video we're going to be discussing the entry widget this is a text box that accepts a single line of user input as always we'll need a window window equals tk followed by window.main loop and let's give our entry box a unique name let's call this entry for short and then to create this entry widget we're going to follow this with equals entry and within the constructor we have to state what we're adding this to we're going to add this to our window and we should finish this by packing it or placing it entry dot pack and we should have an entry box within our window however the text is somewhat small so let's change that we can set this as an option within the constructor of our entry box so let's set the font font equals and pick whatever font you want i'm going to pick maybe ariel and then a size it'd be 50. and this should be a little bit larger and we can type in some text like this cool right now we should add a submit button because right now this currently doesn't do anything if we type some text in so let's create a button i'm going to create this button maybe after the entry box and let's say that this is a submit button so let's call this submit button equals button what are we adding this to writing the square window and we'll set some text text equals submit we'll also need a command for this button command equals and we'll create a function called submit and we want to pack the submit button to add it to the window submit button.pack all right now let's put our entry box on the left hand side and our submit button on the right hand side when you pack these widgets you can set these on a certain side side equals left and our submit button we want this on the right not necessary but i think it looks better and we also need to define our submit function outside of the window let's define what this does def submit what's this going to do we need to get the current value that's within our entry box one way in which we can do that is use the entry boxes get function this will return a string and we can do something with that string such as store this within a variable so let's create a variable called maybe username let's pretend we're having a user submit their username to login to something i suppose so we'll get the current value of the entry box store that within a variable and we'll call this username and then we will maybe print this for fun print hello plus user name and let's try this so here's our entry box here and our submit button i'm just going to make up something click submit and it displays our message hello ergo gerger gerger i didn't say that this video was going to be professional let's add a few other buttons let's say we want a delete button as well as a backspace button so let's copy what we have for our submit button and create a delete button and then a backspace button the delete button is a little bit easier to code so let's rename our submit button as delete button make sure to change the name to when you pack this and the text we will say delete and we'll create a function called delete and let's define what delete does so after our submit function let's define our delete function and we need to delete all of the text within our entry box one way in which we can do that is to type in the name of our entry box dot delete function and this takes two positional arguments which portion of our entry box do we want to delete so we want the very first character that is index 0 followed by the last character and we can say end so this will delete all of the characters within our entry box and let's try it so i'm just going to type in my name bro i'm going to delete this and all of the text is now gone just like that let's create a backspace button we'll copy what we have for our delete button and change the word delete to backspace make sure you change that when you pack this as well and for the text we'll set this to backspace and we'll create a function called backspace and let's define what backspace does so after our delete function let's define back space and this is going to do something very similar to our delete function except we're going to change the first positional argument we need to place the second to last character within this positional argument one way in which we can do that is to first get the entire length of all of the characters within our entry box so let's begin by typing entry dot get and we need to determine the length of this and we can surround this by placing this within the length function so this will return the current length of all of the characters within our entry box and then we're going to add -1 so that this first positional argument is the second to last character and the second positional argument is the end the last character and then when we run this let's type in our name i'm just going to type in draw code this time i'm going to click backspace and then it's only going to delete the last character and then if you were to click delete it deletes everything broy and then if you click submit it's going to submit your name all right let's customize the appearance of this entry box so within the constructor for this entry box let's change maybe the color maybe the background color and foreground color let's begin with the foreground color you can pass in a color name or a hex value i want this to be green so the hex value for that is zero zero f zero ff00 and the foreground color of the text when we type it in is now green and we can also change the background color that is bg we could pass in a color name or a hex value i'm just going to say black to keep it simple and we now have a black background and the text color is now green here's a few useful features that you might be interested in let's insert some default text for our entry box so we can use the insert function entry dot insert we place a positional argument as well as some text so for the positional argument let's say zero so that's the very beginning index zero and let's set the text to maybe spongebob and then the default text within our entry box is now spongebob another option available to us is that we can set the state of this entry box we can set this to active or disabled let's say that after somebody submits our name we want to disable this entry box so we can either pass in this option within our constructor or we can use the config function to make any changes to the state of our entry box so let's say after we submit our username we want to disable this entry box so let's type in the name of our entry box dot config and for the option for state let's set this to disabled and then once we type in a name and then click submit our entry box is now disabled there's also an option called show where you can show a certain character in place of the normal text on the screen so this would be useful for a password let's say that we're typing in a password but we don't want to display the password on the screen we can use the show option to show a certain character in place of our text so you might see bullets or an asterisk so let's pretend that we're now typing in a password so we're going to set the option for show and place a character that we want to replace each character with let's say we want to only display asterisks when we type in some characters and i'm going to type in the word password but it's only displaying asterisks now but if i were to click submit it displays our text and i would say plain text instead of our hidden text because we're only showing whatever character that we set so that's an option available to you as well well everybody that's how to create an entry box in python you can submit information such as a username for example or even a password if you set the show option available to you if you want a copy of all this code i'll post all of this in the comments down below but yeah that's some of the uses of the entry widget in python hey how's it going everybody two bro here hope you're doing well and in this video i'm going to teach you guys how we can create and customize our own check buttons in python so sit back relax and enjoy the show all right my fellow bros in this video we're going to be creating and customizing our own check buttons in python i sometimes refer to these as check boxes so in case i do that's what i'm referring to as always we'll need a window window equals tk followed by window.main loop and let's call this button just check button and in order to create this check button we type in the name of the check button equals check button and within the constructor what are we adding this check button to we're adding this to our window and also within the constructor we can set the different options for how we want to customize this check button let's begin with the text text equals i agree to something and last but not least we need to add this check button to the window one way in which we can do that is to use the pack function of this widget so follow this with check button dot pack when we run this we have our check button within our window and we can toggle this on or off right now i'm agreeing to something i'm not sure what i'm agreeing to but hopefully it's not anything bad now currently this doesn't do anything so we'll need to associate a variable with this check button so we'll add that as an option variable equals and let's create a variable called x and we'll need to define this within the window so after we create our instance of our window let's say x equals now with check buttons they store a 1 or a 0 by default within our variable our variable that we call x so with x we're going to set this equal to a int var if this were to return a string we would say string bar but normally by default this returns a one or a zero and we can actually change that using the on value and off value options so the on value is what's going to be stored within our variable if it's toggled on so by default this is one and the off value is the opposite this is what is stored within our variable if this is toggled off alright now let's have some fun with this so let's associate a command with this check button command equals and let's create a function called maybe display and then let's define this before the window def display and we're going to check the value of x to see if it's one or zero so within our display function we're going to check to see if x and to get the value of x we're going to use the get function so if x dot get is equal to one that means that somebody clicked on the check box or toggled it on so if they check the check box or check the check button then they agree so print you agree if it's zero and we can do this with an else statement else print you don't agree frowny face and let's test this theory so we have our check button when we click on this it's actually going to call our display function i agree to something and it says within our console window you agree and if i were to toggle this off it says you don't agree let's change the font of our check button so we'll add that as an option font equals and we can pass in a font that we want i'll say maybe ariel and then a size of 20 and now this should be readable i agree to something let's also color this because well i like coloring let's begin with the foreground color so that is fg for short fg equals and then we can pass in a color name or a hex value i like hex values so i'm going to stick with those i want a green foreground color so that is zero zero f zero zero but feel free to adjust these values however you want so our text should now be green that is a very bright green and it hurts my eyes so i'm also going to change the background color which is bg and i'm going to set this to black so we'll have green text on a black background okay now when you click on this it flashes that's kind of annoying that's the active foreground and active background if we click on this or hold this down the color scheme switches to our active foreground slash background and we can change those too so i'm going to set those options active foreground i'm going to set this the same as my foreground color and the active background will be the same as our normal background so that's active background equals black and this should no longer flash when we click on it not too bad not too bad let's add some padding pad x i'll set this to 25 and pad y i'll set this to 10. we have a little more padding around our check button one feature that's available to us is that we can add an image next to our check button i downloaded an image of the python logo that i want to add so we'll use the image option to add a photo image to this check button but first we need to create a photo image from our image file so within the window let's call this python photo but you'll probably use something different for your project python photo equals photo image and within the constructor for our photo image we can set the file path or the file name since this image is within my project folder i only have to list the file name and this photo of mine is python.png and now we set the image equal to our photo image that we have image equals python photo but when we run this it's going to overlap the text we still have our image though and this still works as intended so in order to display the image as well as the text we're going to need to use the compound option and let's add that at the end compound is where we're adding this photo relative to the text i want this photo on the left hand side of the text so i'm going to set this to left and now when we run this surprise surprise our image is on the left hand side one thing that you should know is that with the on value and the off value data type if you were to change this to a non-integer value let's say we're going to replace the on value with a boolean value of true and the off value is false with this variable make sure to change the data type as well to reflect what you're storing within it so with our int var variable we want to change this to a boolean var value so replace int with boolean and this will work much the same now with this display function we'll need to account for that so within the if statement here we'll say if x dot get we don't need to say is equal to one this will return true or false and this will work just the same as it did before and if you replace this with a string let's say the on value is yes all caps and the off value is no this is now a string bar and we'll change our display function to say if x dot get is equal to yes and this should work you agree you don't agree you agree you don't agree and i'll change that back to one so one and zero is the default for this but you can edit these based on what you need all right so that's the basics of check buttons in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of check buttons in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to be teaching you guys how we can create radio buttons in python so sit back relax and enjoy the show okay everybody let's create some radio buttons now these are similar to check boxes but you can only select one from any single grouping so let's pretend that i'm buying you lunch and you can only select one item from a menu you can select either a slice of pizza a hamburger or a hot dog so let's begin by creating a list i will call this list food food equals pizza hamburger hot dog and let's create a window window equals tk followed by window dot main loop so to create a radio button we'll need a name so i'll call this radio button radio button equals radio button and we're going to be adding this to our window and we're going to put this within a for loop so we're going to iterate through all of the items within our list so let's create a for loop so we'll say for index in range length of food so this is going to iterate once through all of the elements within our list so when we run this it's going to create three radio buttons for us because we're instantiating one radio button for each item in the list now what i'm going to do is set the text equal to our list of food at a certain index so when we first run this for loop it's going to be zero for the index then one and then two and then so on and so forth for each item within our list and then we just need to pack this so radio button dot pack and then let's take a look at this alright so here are all of the radio buttons that we have currently they're all selected though so we'll need to link these within a single grouping the next thing we'll add is a variable and we'll set this equal to x and we'll need to declare this after we create an instance of our window so x equals int var so this will hold an integer object so these are all within the same grouping however if we try to run this again and select one of these options they all become selected so we're going to need to give each of these individual radio buttons their own value because right now they're all sharing the same value so we can add value equals whatever the index is currently so the first item within our list of food is going to have an index value of zero then one then two so let's try that again and you can see by default it's zero so pizza is already selected then we can select either hamburger or hot dog but we can only select one so that's kind of what we want then so do you guys usually know how i call the config function after each change that i make for an object well that's because i like to add comments just for teaching purposes for what each change does however it might be easier for you instead of calling the config function a bunch of times just to list all of the changes within the parentheses when you create an instance of the object that you're working with however just for teaching purposes i'm going to put this all within separate lines that allows me to add some comments so i think i'm going to start doing that from now on uh so what this does is that this adds text to radio buttons and this groups radio buttons together if they share the same variable so if you wanted a completely different grouping of radio buttons you can give them a different variable like y and what this line does is that this assigns each radio button a different value all right so let's make some cosmetic changes to our radio buttons so right now they are centered let's anchor these to the west so we'll place this within the pack function so anchor equals w alternatively you can just say capital w without the quotes this would also work too so now they're all lined up let's add some padding so i'm going to add pad x and i'll set this to 25 and this adds padding on x axis let's also change the font so we'll save font equals maybe i'll pick impact for a font style and set the font size to 50 and now we can actually read these because the font is large enough now let's add some images so let's create some photo images you'll want to be sure to create these after you create your instance of your window so let's create a pizza image first pizza image equals photo image file equals the file path or the file name and my file is pizza.png and it kind of looks like this it's just the pizza emoji so pizza.png and then i'll do the same thing for hamburger and hotdog so this will be hamburger image file equals hamburger.png and then hotdog image and this is what the other emojis look like and then let's create a list of the photo images that we have i'll call this food images equals than the names of these images pizza image hamburger image and hot dog image so then we can set the image for each radio button image equals the name of the list food images followed by the index that we're currently on within our for loop so this adds image to radio button and let's test this cool here's our images now if you want some images as well as text you'll have to use compound so let's add that next so i'm just going to add a comma followed by compound equals let's say left so this will add the image to the left of the text adds image and text i'll just say left side so this will display both an image and text so with these radio buttons you can eliminate these circle indicators and there's actually a way to do that so what we'll add if you want to get rid of those is indicator on equals zero so this will i should say eliminate circle indicators so it's going to change these to these push buttons however they are going to be of uneven size you can set the width if you want to so we'll do that so we'll say width equals what about 75 i'm not sure if that's a good size or not okay that's way too small let's try 375 so yeah you can have some push buttons if you want to if you don't like the circle indicators so this sets width of radio buttons now let's actually set a function to uh be called when we click one of these buttons so let's call this function maybe order like we're ordering one of these items so def we'll call this order like we're ordering something and what we'll do is just a few if statements because i'm feeling lazy so we'll just say if x that's the value that's going to be stored because each of these radio buttons is grouped together by the variable x if x dot get is equal to zero that's our first index for pizza what we'll display is print you oops you ordered pizza then we'll just add else if x dot get is equal to one we will print you ordered a hamburger and then else if two you ordered a hot dog else print huh so there's probably a more efficient way to write this however i was just feeling lazy and this is probably the best way to keep this simple and easy to understand so let's try this now oh however we need to set the command for our radio buttons so command equals then the function name which is order and make sure you do not add the parentheses so don't do this do that and this will set command of radio button to function all right let's test this so if we click on pizza it says you ordered pizza you ordered a hamburger and you ordered a hot dog okay everybody so that's the basics of radio buttons if you would like a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of radio buttons in python hey what's going on everybody it's you bro here hope you're doing well and in this video i'm going to teach you guys how we can create a sliding scale in python so sit back relax and enjoy the show let's create a scale so we'll need a window window equals tk followed by window.mainloop we'll create a scale called scale scale equals scale we need to add the scale to our window so we'll put that here we can list a from position and a 2 position both of these values will be our range of values that we can use for our scale so from sure to add an underscore after from it won't work without this underscore from equals let's say 0 and 2 equals 100 so we're going to create a scale for temperature and this will be in celsius so 0 will be freezing and 100 will be the boiling point uh you know for water so then to display the scale we'll need to add scale.pack and let's run this so the front position is zero so that's at the top here and then if you go down it increases so you can actually flip this so we'll save from 102 will be zero so now you can scroll up and the number will increase let's also get the current value so we'll need a button so button equals button we'll add this to the window we'll add some text text equals submit and then a command command equals submit but we'll have to make this function so let's do that outside the window def submit and we will simply print the current temperature so let's display message the temperature is plus scale dot get plus degrees celsius we can just say degree c so let's try this uh but we also have to pack the button so button.pack so if we were to try and submit this right now scale.get is going to return an integer so we need to convert this to a string so str scale.get and you have to do that with python if you're displaying a integer value along with another string uh you need to convert it to a string so now this should work so it is 82 degrees celsius so let's do some cosmetic changes for our temperature gauge because right now it's kind of ugly so the first thing we'll change is let's say the length so length equals 600 so that should be fairly large you can also set the orientation so that is orient spelt like that so this can either be vertical which it currently is or horizontal but i'll keep this as vertical so i'll let a comment that this is orientation of scale let's also change the font so font equals pick whatever font you want and a size so maybe 20. now you can add some tick intervals maybe i'll set this to 10. so these will be numeric indicators on the scale and show value this hides the current value so if you set this to zero this will hide current value so it no longer displays what the current value is next to the slider to actually retrieve it you'd have to get the value so right now it's 40 but it helps that you have the tick intervals on the left-hand side i should probably add that this adds uh numeric indicators for value good enough let's continue on now let's use the set function we can set the current value of the knob on our scale and by default it is zero so we can use the scale dot set function and we can place a number in here a value so let's say we want this to be 100 so this is now at the 100 position instead of zero if we wanted this in the middle we could set this to 50 and now it's in the middle however if you change the range of your skill of from minus 2 and set this to 50 now 50 is all the way down here so it no longer appears in the middle so this isn't really necessary but if you want this to be a little more sophisticated there's actually a formula that you could use we can use scale straight braces and then place the word from within here this will give us our max basically uh so this is from without an underscore so this not this this scale from minus scale two and then we're going to divide this by two and then i'm just going to put this within a extra set of parentheses plus scale two just in case our two value is greater than zero we just want to account for that and then i'm just going to put these within another set of parentheses so this should always appear in the middle then even if we were to change this range yeah it seems like it works uh like i said it's not really necessary but if you want this to be a little more sophisticated that would work now let's make some cosmetic changes to this scale and make it look pretty so first let's change the trough color this is this gray portion right here so let's set the trough color equals whatever color you want you could say like blue or you can place a hex value here and i actually picked one out already so i'm going to use 6 9 e a f f and that is this icy blue color kind of like this is sliding on ice and i'm also going to change the font color and i'm going to pick this fiery red color to symbolize heat and then you can change the background color too so that is bg and i'll just set this to like black it's looking kind of cool now right and for no good reason i'm going to add some pictures so feel free to pause the video if you'd like to download some images i'm going to use an image of a flame for the hot side of our scale and a snowflake for the cold side so let's begin by adding the hot image uh to the scale before we actually add the scale to the window so we'll do this after we instantiate the window because that's the only place that we can do that so we're going to create a image i'll just call this hot image for the fire icon so hot image equals photo image file equals this is hot.png so hot.png we're going to add the image to a label i'll call this hot label hot label label image equals hot image and then we need to pack this so hot label dot pack and this should appear at the top let's test it yep there it is let's do the same thing for the cold side so i'll add this here before the button and i'm going to replace hot with cold same thing with the file name cold.png this will be cold label cold image and cold label dot pack and that should be it let's take a look not too shabby it's looking pretty sweet it has our submit button at the bottom too uh so right now the temperature is 100 degrees celsius the temperature is 0 degrees celsius the temperature is 60 degrees celsius well that's how to create a scale in python if you would like a copy of all this code i'll post all of this in the comments down below but yeah that's how to create a scale in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create a list box in python so sit back relax and enjoy the show all right you wonderful people let's create a list box a list box is a listing of selectable text items within its own container so as always we'll need a window window equals tk followed by window dot main loop let's create a list box simply called list box big surprise there right so list box equals list box what are we adding this list box to we're going to place that here within the parentheses of the constructor we're adding this to our window and then we're going to follow this with listbox.pack you can also do listbox.place as well and place some coordinates but we've always done pack let's just stick with that for now all right so this is what our list box looks like it's a small rectangular box and we're going to add some text items that are selectable and eventually we'll be able to submit a choice so i have an idea let's create an online menu like we're ordering food from a restaurant let's say it's bros italian restaurant so let's add some food items to our menu and somebody can submit an order so we'll need to use the insert function of the list box to add some items so list box dot insert we place an index and a text item so let's say for index one we'll have pizza and this is what we end up with we have the item pizza it's selectable and well that's really it we'll need to create a submit button and populate the rest of this list box so let's add a few other items for our menu so let's say we'll have five items and we need an index for each so one two three four and five so we have pizza for the first item for the second item let's have pasta and third let's say garlic bread because garlic bread is awesome and restaurants usually have appetizers so why not soup and salad and that should be enough for this example and this is what we have we have our menu and we can select an item from this menu so let's customize the appearance of this menu well because we can so let's do that let's change the background color so we do that with the option bg for background and you can set this equal to a color of your choice or a hex value so i have a hex color value already picked out it is f7fde and this has the appearance of i would say paper like it's kind of faded i think that would fit some sort of menu for a restaurant but pick whatever background color you want so let's change the font next so we can do that with the option font and i will pick the font it's somewhat fancy i think it would fit like a restaurant menu and then a size of 35. yeah we're getting somewhere we can also change the width and the height so width equals let's say 12. that's not too bad for a width let's also change the height so we can do that with a function of our list box so let's get the current size of the list box and let's actually do that after we insert all of the items within our list box so to change the size of our list box what we do is type in list box dot config you usually use config if you need to change any uh options and we want to change the length of or the height of this list box so we're going to say height equals list box dot size function so then this will adjust the size of our list box dynamically even if we were to remove an item then the size of our list box is going to shrink just like that but let's keep salad in there for now because we need salad all right so how do we actually submit one of these options we'll need to create a submit button so let's do that after we create our list box so near the bottom we'll call this submit button submit button equals button we're adding this to our window let's set the text to submit and we'll need a command so we'll create a function called submit and then we need to pack this submit button submit button.pack now at the top of this program let's create a submit function so at the top def submit so to retrieve or get the current selected item of a list box there is a certain function that you can use so we'll begin by saying list box dot get what are we getting we want to get anything that is currently selected and there is a function for that so what we're going to do within the parentheses of the get function is type in listbox dot current selection it's shortened to cur selection all right and then we can either store this within a variable or we can just print this but i think we'll just print this to keep it simple now when we select an item and click on the submit button it's going to submit our order actually better yet let's actually uh print you have ordered whatever item that we select so garlic bread you have ordered garlic bread cool what we're going to work on now is a way to submit or insert an item to our list box after this program is compiled and already running so we'll create an entry box within our window where we can submit a custom item to this menu so let's create an entry box and let's do that before the submit button that would be a good spot for this so let's call this entry box where somebody can type in something to add to the menu so entry box equals entry and we're adding this to our window and then entry box dot pack then we're going to create a button called add and i'm just going to copy everything from the submit button and we'll change submit to add we're going to add an item to the menu so we'll change the text to add and command add add button dot pack then we're going to create a function called add and we'll do that at the top def add parentheses colon so to add an item to the list box first we need to get what is currently in the entry box so we can do that by typing in list box dot insert then within the parentheses we need to get an index number as well as a text item so for the number what we can type here is the listbox dot size so this will give us the current position of the index that we're currently on for the list box and then we need to get the text in the entry box so we type in the name of the entry box entry box dot get and this will insert a new item within our menu our list box so let's try it again so we can type in an item let's say soda we want to add soda to the menu and then we click add all right there's our soda but we have to scroll down to see it so let's change the size of our list box so there's actually a line of code that we did that already listbox.config height equals listbox size so let's add that within the add function at the very end so then the height of our list box will adjust so currently there's no soda within our menu let's type in soda or some other item click add and then that item will appear and the size of the list box will change to accommodate any new items let's say now that we serve sushi we're now an italian and japanese restaurant now we have sushi on the menu you know what why stop there let's create a delete button to delete an item from this menu so we'll create a delete button i'll just copy everything for add and change this to delete so delete button text equals delete command equals delete as well and delete button dot pack and then at the very top we'll create a delete function so we'll do that here d e f delete and to delete an item from a list box there's actually a function to do that so list box dot delete and then within the parenthesis of the delete function we can pass in list box dot current selection or just cur selection for short and then we want to readjust the height of this list box after we delete an item so we'll just add listbox.config height equals listbox.size because the size of all the items within the list box is going to shrink after we delete an item so let's try this so here's our menu let's say we no longer want salad because salad is healthy well we can delete it same thing with soup and you know what let's also delete the pasta and the pizza so we're only left with sweet sweet garlic bread well ladies and gentlemen we're going to get into some more advanced stuff with list boxes what if you want to select more than one item from this list box we're going to need to change a few things so when we create our list box there is a select mode select mode and we are going to set this equal to multiple so now we can actually select multiple items from this list box like i want to select one of everything but what happens when we submit this well we're going to run into some problems so we're going to need to change this program around so let's begin with the submit option so what we're going to do within the submit option is first get rid of this line let's say we no longer need this anymore uh and then before we print out the items that we ordered let's create a list called food and we'll just leave this empty for now we'll fill this later so we'll create a for loop for index in list box dot current selection what we're going to do after each iteration food dot insert our index number as well as listbox dot get the item name at this index what this for loop is doing is that it's going to iterate once for each item that we select so since we have three items that are currently selected this is going to iterate three times get the index number as well as the item at that index number and now we just need to display the contents of what we have within our list of food so we can do that with another for loop so let's add that after you have ordered then for index in our list food all we'll do is print index so this will print out everything that we ordered so let's say that we want one of everything and submit this you have ordered pizza pasta garlic bread soup and salad now what happens if we try to delete multiple items so let's say we want to delete soup and salad and we click delete well we're going to run into an error because our function is not set up to accommodate for multiple items so we'll need to change a few things around so let's get rid of this line for now list box dot delete list box dot current selection and we're going to place a for loop here so for index in list box dot current selection then after each iteration what we're going to do is use list box dot delete and we're deleting the item at whatever index we're currently on so you would think this would work at first glance let's say we want to delete pizza and pasta we're going to click delete so pizza was deleted but not pasta that's because the indexes are changing after we delete an item so when we use this for loop we should actually reverse this so with listbox.currentselection we are going to enclose this with reversed so then we're going to start at the last index and work our way to zero in that order so now if we want to delete pizza and pasta i don't know why we would because they're amazing and we click delete it deletes pizza and pasta but we still have garlic bread soup and salad then we can add an item let's say we want to add sushi against the menu we can do that and then we can order one of everything because we're really hungry you have ordered garlic bread soup salad and sushi so that's the basics of creating a list box in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of list boxes in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create message boxes in python so sit back relax and enjoy the show okay people let's create some message boxes but first we'll need an import so from tk enter import message box and what this will do is import the message box library so it's not necessary to add this comment uh so we'll need a window window equals tk followed by window dot main loop let's create a button so button equals button we're going to add this to the window we're going to set the command to execute a click function that will have a message box appear when we click on the button and let's set the text so text equals click me and then we will need to pack this button so button.pack now we'll need to create a click function so let's do that at the top def click and what do we want to do so there's a few different uh message dialog boxes that you can use so let's begin with a basic show info message box so message box dot and there's a few options let's begin with show info show info this just displays a simple message so if we were to run this we have a button we click on the button and it's going to create a message box for us and it just shows some info but we don't really have any info to show yet so we can set a title and we can set a message so let's set the title title equals this is an info message box although part of the title got cut off let's also set the message message equals you are a person click me you are a person thanks i didn't know that so there's a few other message boxes that we can use too so for now i'm just going to turn this into a comment and i'll just copy this just to save some time and the next one that we have is show warning so this will have a different icon so the title let's say warning and the message you have a virus so now we get this annoying warning message but you can just click ok to get rid of it so one thing that you might see with tech support scams they'll have a message box like this that shows a warning but they'll put this within a while loop that's set to true so this will just continue on and on kind of like this so if we were to try and close out of this it's just going to reappear while true is true basically so that's just something funny that i wanted to show you so let's move on i'm going to turn this into a comment then the next one we have is show error so show error title set it to whatever you want error message something went wrong there's a few more sophisticated ones too we can ask for some user input so this next one is message box dot ask and there's a few to choose from let's go with ask okay cancel first we'll set the title title equals ask okay cancel and a message message do you want to do the thing so we can actually put this within an if statement so this returns either true or false depending on what you click so let's put this within an if statement if this is true print you did a thing if it returns false we can use an else statement else what else do we want to do we'll say else print you cancelled a thing and let's test this but i am forgetting a colon there do you want to do the thing okay you did a thing let's try it again do you want to do the thing cancel you cancelled a thing cool there's a few others so i'll turn all of these into comments and the next one we can go over is ask retry cancel and this is fairly similar to what we had before i'm going to copy this let's change this to ask retry cancel ask retry cancel do you want to retry the thing you retried a thing or you cancelled a thing so it's very similar to what we had before do you want to retry the thing retry you retried a thing and cancel you cancelled a thing okay the next one we have is ask yes no so we can get some user input if it's a yes or a no so this returns a boolean value a true or false value so message box dot ask yes no and we'll set the title title equals ask yes or no and a message do you like cake so let's put this within an if statement because this returns a true or false answer print i like cake too else they answered no then if this is false print why do you not like cake and i'm missing a colon there we go so if they click yes this returns true and we execute this line of code i like cake too if they answer no it's going to execute this else statement do you like cake no why do you not like cake now what we have next is ask question and this doesn't return a boolean value of true or false it actually returns a string of yes or no so this is message box dot ask question and we'll set the title to ask question and a message message equals do you like pi so let's just print the result what this returns so print everything within here so like i said this doesn't return it true or false but yes or no so what we could do is assign the response to a variable such as answer so answer equals whatever the answer is whatever they click whatever button they click on so if our answer is equal to yes will print a message print i like pie 2. then else the answer is no will print why do you not like pie so do you like pie yes i like pie too do you like pie no why do you not like pie so this next one is probably the most difficult it's ask yes no cancel so it's message box dot ask yes no cancel it's this last one so let's set the title title equals whatever you want yes no cancel and a message message equals do you like to code so let's just print the results what this returns so print everything just so we can take a look so the possible answers are true false or none so we can just run some if statements for this so if answer is equal to true what we can do is print you like to code oh but we need to assign this to an answer so answer equals all of this else if answer is equal to false let's print then why are you watching a video on coding and then else the response is none so we can just use an else statement so else you have dodged the question okay let's try this do you like to code yes you like to code uh but this should really be a smiley face right do you like to code no then why are you watching a video on coding do you like to code cancel you have dodged the question no one other option available to you is that you can change the icon that you're using so let's say that we want to change this icon so right now it is currently this question mark so we can set this to one of a few preset icons so icon equals and let's set this to warning so instead of that question mark we get this yellow exclamation point and you can also use info it's just an eye and error so do it fits best for you all right well that's the basics on message boxes in python if you'd like a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of message boxes in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys about the color chooser module in python so sit back relax and enjoy the show okay everybody so before we begin it we'll need a second import so let's add this at the top so from tk enter import color chooser and the reason that we need a second import and it's not included with this first import is because this is a sub module it's not necessary to add this comment i just like to add comments for teaching purposes so make sure you have these two imports before we begin now we'll need a window and a button that we can add to the window and when we click on the button we're going to select a color and change the background color of the window so let's create a window window equals tk followed by window.main loop and then let's set the geometry so we're going to change the background color of the window after we select a color so let's select a fairly large size for a window maybe 420 by 420 so this is the width and the height and then let's create a button so button equals button let's set some text text equals click me and we're going to set a command for this button that is called so we're going to create a function maybe called click and then we just need to pack this button so we can add this to the window so button.pack now we're going to need to create a function and we'll call it click so when we click on the button this function is going to be called so def click and what do we want to do after clicking this button what we're going to do is take color chooser and we're going to use the ask color function so currently this is what this does we can select a color after clicking this button and pick whatever color you want then you hit ok however we need to store this color within let's say a variable so we'll create a variable called color color equals color chooser dot ask color and then we can do something with this color but for now let's just print this color just to take a look to see what it contains so print color so let's say that i want this green color click ok this is what this prints this is our color so this is the rgb values that we have in this first element so this is the amount of red then green and then blue and the second element is the hexadecimal representation of these values so what we want is this hexadecimal value so what we can do is create a second variable to store this so let's just call this color hex color hex equals color and we're going to get the first element well technically it's the second element but it's the element at position one so this one this is zero index zero so we're going to basically extract this hexadecimal value and let's just print this just to be sure that it's working fine so print color hex and let's try this again but select a different color uh maybe i want this purple color then click ok so this is cb42ff and here we have cb42ff now let's change the background color so since we have this hex value that's actually fairly simple so we're going to take window dot config bg for background color equals color hex and this will change background color and let's set this to a sky blue color maybe like this click ok and it changes the color however it's not really necessary to continue printing these values you can take these out if you want and this would work like just the same then now this part isn't necessary but if you want you can condense these three lines of code that we have for our click function into less lines of code so what you could do instead of assigning the value of color at index 1 to a separate variable we can take color at index 1 get rid of this line and assign bg equals color at index one so now this is done with just two lines of code and why stop there we can write this with just one line of code so now we're going to take color chooser dot ask color get rid of this line bg equals color chooser dot ask color at index one and now this is done with just one line of code however it's a i would say a little more difficult to teach so that's why i kind of like to separate this line by line so if you want you can condense all of this into just one line of code so here's some ideas of where the color chooser sub module could be helpful so of course you can change the background color too but let's say that you're creating a game and you can customize your character or avatar well it would be kind of nice if you could have some way for the user to actually change maybe the character's hair color eye color something like this would actually work fairly well so yeah that's the basics of color chooser if you'd like a copy of all this code i'll post this in the comments down below but that's the basics of color chooser in python hey what's going on everybody it's bro here hope you're doing well and in this video i'm going to teach you guys how we can create a text area in python so sit back relax and enjoy the show all right my fellow bros let's discuss the text widget this functions like a text area you can enter multiple lines of text i'm not sure why it's called a text widget instead of a text area widget text area would make more sense but idk though so let's begin by creating a window window equals tk followed by window.main loop so to create a text widget also known as a text area let's call this text text equals text and we're going to add this text to our window and then we need to pack this text text dot pack so we should have a text area and you can enter in stuff like this all right but what good is a text area if you can't actually submit some text so let's create a button to do that for us so button equals button we're going to add this button to the window and button dot pack so we need a command for this button and a function as well so let's create a function called submit it's going to be a submit button and let's change the text to because we can text equals submit cool now let's create a function called submit and we'll do this at the top d e f submit and what is this going to do well it's going to get the text from the text area and let's assign this to a variable and we can call this maybe input or whatever you want so to get the text from the text area let's say text that's the name of this text area dot get but we need a starting index as well as an ending index so we're going to place 1.0 here for the beginning index this is the first line we want to get everything so for the second index we can just put end then we can do anything we want with this input so let's just print this to the console window so print input and this should work hey you drink plenty of water love you and click submit and then you can do whatever you want with this input well that's how a text area functions but now let's customize the appearance of this text area and i have a few ideas that you might be interested in so let's change the background color of this text area so bg equals and i will pick light yellow and you will see why in just a second so now this text area kind of resembles maybe a piece of paper a notebook a post-it note however this font is really small so let's change the font styling and the font size so font equals and i will pick the font ink free this somewhat resembles handwriting so i kind of like this and it kind of fits our notebook theme and then a size maybe 25. one thing you should know the text area size corresponds directly with the font size so 25 is a fairly large font so if we were to compile this and run this the size of our text area is now massive because it corresponds directly with the font size so we might want to limit the width and the height so the height is the amount of characters that this is tall so let's say 8 and the width is the amount of characters that this is long and let's say 20. and now this should be much smaller and it kind of resembles a post-it note which is kind of cool let's also change the amount of padding that we have we can do that with pad x and pad y so pad x let's say 20 and pad y also 20. so the text shouldn't actually touch any of the borders this is some sample text cool let's finish this by changing the font color so that is fg for foreground foreground equals and i'll pick purple because purple is a pretty color and let's run this one last time roses are red violets are blue booty booty booty booty rockin everywhere well that's the basics of the text widget in python if you would like a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of the text widget in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can use a file dialog in python to open and read the contents of a file so sit back relax and enjoy the show okay people so this is how you can use file dialog to open and read the contents of a file but first we'll need a second import along with this import at the top so what we're going to be importing is from tk enter import file dialog and then we'll need a window like what we usually do so window equals tk followed by window dot main loop now we'll need a button that we're going to add to the window and when we click on this button it's going to launch our file dialog so we can select a file so we'll call this button button equals button let's set some text maybe to just open like we're opening a file and we'll associate a function to our command for this button so let's create a function called open file that's fine and then we need to pack this button so we can add it to the screen so button.pack now we need to create a function called open file and we'll do this before we create our window let's type def open file and when we call this function we're going to take file dialog and use the ask open file name function so this is going to return a string and that string is the file path of where your file is located so what we could do is store this within a variable so let's store this within a variable called file path and to test this let's just print this just to take a look at the contents of this variable so let's just print the file path now i have a file on my desktop that i want to use called test file so let's click the open button and this might not necessarily bring you to your desktop it might bring you someplace else within your file directory so this just happens to be bring me to my desktop so i'm going to click the test file that i have and click open so this prints the file path so it's going to return a string and it's the file path basically so now we want to open and read the contents of this file so we don't really need this print line anymore so what we'll do is create a file variable and we're going to use open we're going to list the file path and then we're going to use r for read so the default is normally rt for read text otherwise you can read binary uh but we can just set this to r r is the same as rt basically uh so then we're going to open this file and then we're going to read it so let's just print this to the console window so print the name of the file which is file where this is located file dot read function and then it's a good idea to close your files after you're done with them so file dot close and let's test this so i'm going to click open find the file that i want click it and then open and that text file says my name is bro i like pizza now let's say you want to make this a little more advanced so what i'm going to do is that i'm going to set the initial directory of where we begin looking for a file when we launch our file dialog so with that test file i'm going to move this to my project folder so i'm just going to paste it so now this is within my project folder now i'm going to set the initial directory within the function of ask open file name so we're going to set the initial d i r for initial directory and then we can list a file path so one thing you could do i want to get this path here this file path so if you're using pycharm what you could do is right click this copy path and then get the absolute path and then i'm just going to paste this and then uh with these backslashes you'll have to do double backslashes because this is the escape character for a backslash alright so this should open my project folder which it does and here's that test file another thing we could do is that we can change the title of our file dialog right now the default is just open so we can change that to something else so i'm going to add a comma maybe put this on a different line uh so this is still within the function of ask open file name so i'm going to set the title to something else i'll say open file okay so if we were to run this again instead of just saying open it says open file okay and we can also limit the file types that we accept and look for so we can use file types so let's say that we want to initially look for a txt file so what we'll do is type in like a name for the file that we're looking for so this is what's going to appear to the user uh text files followed by an extension so we want asterisk dot txt and then we can also have an option for all files so i'm going to add a comma for a second option and then let's say all files and then an extension so comma asterisk dot asterisk this will look for all files uh but i think i am missing a parenthesis there that should be good so then when we open our file dialog it's going to initially be looking for plain text files and with this drop down menu it says text files and all files so that's what we have listed within our file types of what we want to search for so you can see that if i switch to all files our python file actually appears because we don't have any limits on the files that we're trying to open or search for so if i change this back to text files only folders and plain text files are visible so then we can open our test file again but yeah that's the basics of file dialog in the next video we're going to be saving a file so if you'd like a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of opening a file using python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can use python's file dialog to save a file someplace on your computer so sit back relax and enjoy the show okay everybody so this is how we can save a file we're going to be reusing a file dialog again kind of like what we did with the video on opening and reading a file so from tk enter import file dialog we're going to be creating a window and adding a button as well as a text area to this window so let's create our window window equals tk followed by window.main loop let's create a button so button equals button let's set the text of the button so text equals save it's going to be a save button and then a command so we'll need to link a function to this command so let's create a save file function and then we need to pack this button so button dot pack now let's create a text area this is just called text so text equals text we're going to add this to the window and we need to pack this text so text dot pack and now let's create a save file function so at the top of our program d e f save file and then we're going to take file dialog and use the ask save as file function and we're going to store the contents within file file equals file dialog dot ask save as file let's run this just to test it out so we have our window a save button and this is our text area we can type in multiple lines of text yay and let's try and save this just to see what we have so far so this will bring me to my desktop it might bring you someplace else for your computer so i'm just going to save this as test file now with this drop down menu save as type there's nothing set up so we'll need to do that manually uh if we were to save this and here's that test file on my desktop so let's take a look at the properties we did not list a file extension so the type of file just says file so we'll get to that later on in this video and if we were to open this with a program like notepad well it's currently empty that's because we need to write some text to this file so let's do that next let's store all of the text from our text area to a variable let's call this variable file text file text equals and then we need to get all of the text from our text area so text dot get and we're going to list the starting index as well as the ending index for this function so we're going to begin at 1.0 that is the beginning of this text area and the ending we can just put end and then we need to convert all of this into a string so let's surround this with str and then we can store all of the text from our text area within this variable file text and now we just need to write our text to this file so file dot write and we're going to pass in file text and then it's a good idea to close your files when you're done using them so file dot close and let's try this again hello my name is bro let's save this i'll call this hello and click save and we still can't save s-type so we'll work on that next let's go to my desktop here's the test file that we created i'm going to open this with notepad and it has all of the text that we added to that text area now let's list some available file extensions that we can have the user save this file as so let's begin by setting the default extension so default extension and let's set this to a text file that is dot txt and then we can list all of the available file types so file types and we're going to place these within a set of straight brackets and i'll just separate these line by line so let's begin with a plain text file so this will take two strings the first is the message that will appear within that save as type drop down menu so let's place text file and the second string the file extension and that is dot txt then let's add another let's say html so i'm going to copy this and paste it and let's say html next dot html and then lastly you can do just all files so all files and that is dot asterisk and let's try this again so hello my name is bro i like pizza and ice cream and this time i think i'll save this as an html file and this is we'll call this pizza and ice cream i guess and click save now let's go back to my desktop here's that file pizza and ice cream and it is an file let's just verify that yep.html for the type of file so we can open this with notepad and it has all of the text i could even open this with sublime text as well kind of like that all right let's change the initial directory for saving a file let's change it to my project folder for uh this python file that we have so that is and i'm just going to organize this a little bit initial d i r equals and then we can list a file path so i'm just going to copy this so copy path paste it then i want to make sure that these are double backslashes and i need to add a comma at the end okay let's try this again so testing one two three and this should go to my project folder which it does testing123 and let's save this as a plain text file click save and here's that plain text file testing123 another option available to you is that you don't necessarily need to use a text area to get some text to write to a file you could use the console window to accept some text so to demonstrate this i'm going to turn this line into a comment and we're instead going to use the console window this time so we'll say file text equals input and then let's just have a prompt here enter some text i guess and then let's run this again so we still need to click this save button and select a file location i'll just save over our file testing123 i'll click save yeah i'll replace it alright so we need to enter some text i guess so i will write a message such as the cake is a lie and hit enter so then our file testing123 now says the cake is a lie so you don't necessarily need to use the get function for a text area you can use the console window as well here's one last thing to consider before you go so what if we begin the process of finding a file location to save a file to and then we exit out of this window well we're going to encounter an exception so one way that we can prevent this is to add this line if file is none return so then if we were to try this again begin saving a file and then exit out of this there is no exception that we encounter so that's just one little extra i thought i would throw in but yeah that's the basics of saving files in python if you would like a copy of all this code i'll post all of this in the comments down below but yeah that's how to save a file using python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create a menu bar in python so sit back relax and enjoy the show all right people let's create a menu bar not too different from the menu bar that you see at the top of many programs there's usually a tab for file edit view help stuff like that except we're going to create one that doesn't have as many options or features it's going to be the generic brand menu bar like the walmart variety so let's begin by creating a window so window equals tk followed by window.mainloop then we're going to create a menu bar and add menus to the menu bar and each menu is going to function like a dropdown menu where you hover over one of these tabs and there's a drop down so we need a menu bar let's just call this menu bar menu bar equals menu and we're adding this to our window so then we're going to take window dot config and we can set the menu of this window to equal the menu bar that we just created with each of these tabs for your menu bar you need to create a separate menu and add each menu to your menu bar and the menu bar is added to the window there's different levels to the stuff so let's create a file menu because well this one has a file menu why not our program so file menu equals menu kind of like what we did with our menu bar except instead of adding this to our window we're going to add this to our menu bar so menu bar like that there's one other step two we need to use this function menu bar dot add underscore cascade this will have a drop down menu sort of effect so let's create a label just called file to mimic the file tab that you see at the top of many programs so label file and we're going to set the menu to equal the file menu that we created so file menu and let's take a look just to see what we have so here's our menu bar and here's our menu there's a drop down effect for this but we need to add actual options to this file menu so let's do that so let's begin by creating let's see we got maybe open save and exit that should be good so file menu dot add underscore command so this is a clickable option and let's create a label called open and we can open a file and maybe two more so we got open save and exit open save exit and let's take a look at this so here's the drop down menu we can open save exit now you might notice that there is this annoying line this is called a tear off you can actually get rid of this if you want so when we create this file menu we're going to set tear off to equal zero and that should get rid of that and it's gone so sometimes you might see a line to separate sections well you can do that with a separator so let's separate the exit command that we have from open and save and to add that separator we just type in the name of our menu file menu dot add separator so this will separate your different commands from each other within a menu you can see that there is a line between save and exit because we placed a separator here now if you want each of these file commands to actually do something you need to associate a command with each of these commands it's a command within a command so command equals for our open file command we'll create a function called open file and we'll need to declare that function and then let's create a command called save file and then another called exit actually one shortcut if you want to exit something you can just say quit all right let's create an open file and a save file function so def open file let's just print something just to keep this simple i already have another video on opening files so print file has been opened and let's do the same thing for save file file has been saved and then our last command exit we'll just quit so let's try this so let's go to file here's the drop down menu we can open a file file has been opened we can save a file and then exit and exit will close out of our window let's create a second menu called edit to mimic the one that we have at the top of our ide so let's create a edit menu so it's the same process that we did with our file menu so let's call this edit menu equals menu we're adding this to our menu bar and i do not want a tear off so tear off equals zero then for the next line we need to add cascade so i'm going to copy this menu bar dot add cascade the label name will be edit and the file i mean the menu will be edit menu and we're setting this menu that we're adding to edit menu and let's try this so we have file and edit but we need to add commands to this edit menu so it's the same process that we did with our file menu i'm just going to copy this change file to edit and let's make a command called cut copy and paste so the label will be cut we'll create a command called cut we'll copy this and we'll create a another command called copy and then paste all right then we just need to create some functions for this so cut copy paste let's do that at the top so cut you cut some text so cut copy and then paste you copied some text and paste you pasted some text all right let's try this so here's our edit menu here's the drop down we can cut we can copy and we can paste not actually but it's going to call a function that can do something like that if you want to set that up maybe that's a video for a different day let's customize these menus well because we can so let's begin by changing the font so we can just type in within each of these menus font equals pick a font that you want and then a size so i'm going to add this font for both of these menus that we have and then when we hover over and click on these menus you can see that the font has changed did you guys know that you can actually add images next to each of these commands well you can and this is how we can do that first you'll need some images here's a few that i'm using so add these to your project folder i plan on using a floppy disk for save and open folder for open and for some reason a stop sign for exit because i couldn't really think of anything at the moment i guess an arrow would have worked too i guess so let's create some photo images out of these images so i already did this i'm just going to copy and paste the text that i had so create a unique name for each image i have open image save image and exit image they're all photo images and here is the file path or the file name for each of these pictures that i'm using so to add an image to each of these commands when you add the command we can just say image and then the photo image that you want to use so with my open command i'm going to use this open image photo image that i have and this is the open folder so i'm going to do the same thing for save and exit so we have save image and exit image but when we run and compile this let's take a look yeah so all the text is gone that's going to be a problem so we'll need to compound views so with compound we can add an image on a certain side of the text and keep the text so compound let's say we want the image on the left so compound left and i'm just going to add this to each of these commands and now we should have an image as well as some text well that's the basics of creating a menu bar in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's how you can create a simple menu bar in python what's going on everybody it's bro here hope you're doing well and in this video i'm going to teach you guys how frames work in python so sit back relax and enjoy the show what's going on people we're going to be discussing frames today a frame is really just a rectangular container to group and hold widgets together so we're going to practice using frames today but first we'll need a window we're going to create a frame and add a frame to the window so window equals tk followed by window.main loop well we're going to need some widgets to add to our frame so let's create a bunch of buttons because why not so i'm going to show you guys a shortcut too so let's say button equals button and then for now we're going to add this to our window but we're going to replace this eventually with frame when we create this and i'm just going to set the text to equal let's say w we're going to have four different buttons wasd like the buttons on the keyboard if you're playing a game and you want to move forward left back or right so we're adding this to the window for now let's set the text to w and what else can we do uh let's change the font so font equals i'll pick the font consoles because that tends to be even uh with buttons the size of the button adjusts to uh the size of the uh letter that you're using or the size of the text uh so let's set this to 25 and then a width so maybe width equals three all right and then button.pack and i just want to take a look at this so here's our button w so i'd like to show you guys a shortcut if you don't plan on using this button by name you don't really need to give it a name you can just say button and then have all your uh options here and then instead of having button.pack just add dot pack to the end so this will do the same thing however you can't adjust this button by its name though because it doesn't have a name anymore so let's create a few other buttons one for a s and d so we have w a s d and by default they're all top and center so with pack we can actually put these on a certain side so let's say we want uh w on the top and then the other three will be all left so side equals left and then after i show this to you you'll see the benefits of using a frame all right so right now they're all at least it appears that they're all within a container so what if i were to expand this well w is just drifting off it's sailing away by w so what if we could put these within a frame or container to actually contain all of these widgets well we can so let's create a frame frame equals frame and instead of adding these buttons to the window we're going to add these buttons to our frame and now we need to add the frame to the window and this is what this looks like however we need to actually add this by using pack or place so frame dot pack so now what this looks like is that all of these buttons all of these widgets are now contained within a frame a container let's change the background color of this frame just so that we can see the width and the height of this frame so when you create your frame there is an option for background color it's just bg and let's set this to a color we haven't done pink yet pink is a very masculine color so now the background of our frame is pink and that might be a better visual cue to the balance of the frame let's also give this frame a border so let's set a width of 5 using bd and then the type of border that we want and we can specify that with relief so relief equals let's say raised so this will have a 3d pop effect kind of like that let's try sunken there's a few other ones as well but i don't feel like it's necessary to go over all the border types let's stick with sunken for now that'll work alright so with this frame we are currently packing this we can set this on a certain side within our window so currently it's at the top let's set this to maybe the bottom so side equals bottom now this frame is sticking to the bottom of the window and it still contains all of the buttons all of the widgets that we added another function available to you is the place function we can place this frame at certain coordinates within our window so let's set x to equal zero and y to equal zero so then when we place this frame within our window and set some coordinates this entire frame is going to stick at these coordinates even if we were to resize this window and we can change these too let's say x is now 100 and y is also 100 so the frame along with all of the components all of the widgets that it contains are sticking within the container and they move along with this so that's the basics of frames it's really just a rectangular container to group and hold widgets together so if you want a copy of all this code i'll post all of this in the comments down below and well yeah that's how frames work in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys a few different ways in which we can create new windows using python so sit back relax and enjoy the show let's get started everybody so we're going to create a window and we'll add a button to this window when we click on this button it'll create a new separate window for us so window equals tk followed by window.main loop we'll need to add a button so let's do that button we're adding this to the window let's add some text to the button let's say create new window and we'll set a command command equals and we'll need to define a function let's create a function called create underscore window and let's pack this as well so we will define this function create window and let's do so at the top def create window and what do we want this to do well we're going to create a new window and let's call this next window new underscore window equals and there's two popular ways of creating a window one is we can use tk and the other is that we can use something called top level and let me explain the difference between the two here's a definition for a top level window this is a new window on top of other windows and it's usually linked to a bottom window our main window is serving as the bottom window and our new window is serving as the top window the top level window so let's try this and just experiment here is our main window the bottom window and if we were to click on this button it's going to create a new window for us a new top level window if we were to close out of the bottom level window any top level windows associated with this would also close kind of like what you just saw now however it's not the same case the other way around if we have a bottom window and a top level window and we close out of the top level window our bottom level window is just fine it didn't close out of that so think of these like jenga pieces if you were to pull one of the pieces one of the windows out from underneath the bottom any pieces or windows on the top of it will close out as well or collapse kind of like in the game jenga so that's one way to think of top level windows they're stacked on top of any bottom level windows if you remove a bottom piece it removes any from the top on the flip side we have tk this is a new independent window and we've actually been doing this since day one of our gui programming tk is a new independent window and our main window and the new window that we create are not linked whatsoever they're completely independent so if we were to create a new window this is our new window and close out of our old window well this new window still persists so this could be useful for let's say a login form or a login screen after you log in you'll be brought to your main program which could be within the new window one other thing that you can do too you can also destroy the old window after creating a new window so we need to type in the name of the window that we want to destroy actually let's call the main window just old underscore window just to clarify things so let's rename that here here and here as well so we want to destroy our old window as if we're closing out of it so we type in the name of the window old underscore window and we use the destroy function and that sounds pretty sweet so we're going to destroy our old window after creating our new window so let me add a comment that this will close out of old window and let's test it so we have our old window our main window we'll create a new window it creates our new window and then closes out of the old window so that's one of a few ways in which you can create a new window for your program so if you want to copy of all this code i'll post all of this in the comments down below but yeah that's how to create a new window using python hey what's going on everybody too bro here hope you're doing well and in this video i'm going to teach you guys how we can create separate tabs for our gui applications in python so sit back relax and enjoy the show okay let's begin so in order to create tabs for our python gui application we're going to need access to a widget called notebook and that's found in a different module so this time we're going to need two imports so at the top from tk enter import just everything but the notebook widget is found within a separate module so we'll need a second import from tk enter import ttk so this ttk import gives us access to several different widgets that are normally not available to us so once you have these two imports you're ready to begin so we'll need a window window equals tk followed by window.main loop and we need to create a notebook widget so right after you create your window we're going to create a notebook we'll call this notebook equals ttk dot notebook and we want to add this notebook to our window so let me add a comment here what this widget does so this is a widget that manages a collection of windows and displays and that's really all there is to it so in order to create different tabs we're going to create some frames so for the first tab i'll call this tab 1 equals frame and we want to add this to the notebook and with our notebook we're adding this notebook to the window all right so this will be a new frame for tab one and let's create a second tab and we'll call this tab two and you can create more tabs if you want but that might be overkill so this is a new frame for tab two after you finish these two lines of code we're going to follow this up with notebook.ad so notebook.ad what widget are we adding we're adding our tab 1 frame and we can set some text for this tab so text equals and i'll type in tab one and we'll repeat the process for tab two so notebook dot add tab two and we'll change the text to tab two and then we need to pack this notebook notebook dot pack and let's take a look to see what we have all right we have tab one and tab two but we'll probably want to actually add something to each of these tabs so that the content is visible so let's create some labels so after we pack our notebook let's create some labels i don't really feel like giving these names because we don't really plan on using them for anything else so we'll just say label tab one that's going to be the parent widget and let's set some text text equals hello this is tab number one then i think i'll give this a width and a height too just so it's more visible so for the width i'll make this 50 and the height 25 so this will be roughly a square shape and then we need to pack this so i'm just going to add pack and let's create a second label for tab two so label tab two maybe i'll say goodbye this is tab number two okay we should have some actual content for these labels now for these tabs so here's the label this is tab one and this is tab two and you can switch between these and they display each of these separate labels however with the way that this window is arranged if we were to expand the size of this window well our frames and our tabs kind of stay in the top and in the center so i'm going to add a few lines within the pack function of our notebook the first thing i'm going to do is use the expand option and set this to true so what this does and i'm just going to add a comment that expand this will expand to fill any space not otherwise used so what happens now is that this will actually expand and it's staying in the center of the window but there's one more thing we're going to add fill equals both normally this is x or y or you can do both so i'll add a comment as to what this option does so fill will fill space on x and y axis so if you combine both of these together what you get is that these tabs will stay in the top left corner and if you were to expand the size of this window the tabs aren't going to move they're going to stick to the top left but the size of the window will expand all right so that's the basics of creating tabs in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of creating tabs in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys all about the grid geometry manager in python so sit back relax and enjoy the show all right everybody let's talk about the grid geometry manager well because we have to this is a useful way to organize widgets within a container imagine our windows being arranged into a series of rows and columns similar to an excel spreadsheet i tend to use that example a lot the top left most cell is row zero column zero computers always begin with zero so that's why our grid doesn't begin with row one column one and we can list which row and column we would like our widgets to be placed within and by default we only have one row and one column to work with at the start but we can explicitly state which row and column this widget should be placed within relative to the container that it's in and python will create new relative rows and columns for us if we state where these widgets should be placed so let's create a small submission form and then organize all of our widgets using our new grid system that we have so let's begin by creating a window window equals tk followed by window.mainloop now that we have our window we'll need to create some widgets to add to this window so let's say that we want an entry box and a label for a first name last name and email address as well as a submit button so let's create a label and an entry box for a first name just to demonstrate this so let's call this label first name label equals label we're adding this to the window and let's set the text to first name for now i'm just going to use that pack to demonstrate the differences between pack and grid and let's create an entry box let's call this first name entry equals entry we are adding this to the window and for now we're just going to pack this and let's take a look so here's our label on the top it says first name and then it has our entry box right underneath so what if we want to have this label on the left hand side and our entry box on the right hand side of the label we're better off using the grid geometry manager so we're going to replace pack with grid and we have to set which row and column that we want each of these widgets to be placed within normally if you use the pack geometry manager as you create new widgets they're just going to be placed directly underneath in one long column so let's say that for our name label we want to place this where the row is zero and the column is zero that's the top left corner so within the grid geometry manager when we call it we're going to set row to equal zero as well as column to equal zero and then for the first name entry we want this to be on the right hand side of our label so we'll place this within the same row row equals zero but in a different column column equals one so column one is directly to the right of column zero and then when we compile and run this we now have our entry box to the right of our label that we have so let's repeat the process for a last name an email address and then a submit button so i'm just going to copy what we have here and change first name to last name so last name label and we'll change the text to last name last name entry and we'll keep that the same now we want this last name label to be underneath the first name label because right now they're going to overlap because we have them in the same row and columns so you can see that we can no longer see the first name label or the first name entry so let's place this directly underneath we're going to put these underneath by one row so we'll keep the columns the same but we're going to put this underneath by one row so row one and row one for the last name entry and what you get is that these two labels and entry boxes are arranged neatly into rows and columns and let's do the same thing for an email so i'm going to copy what we have and we're going to change last name to email so email label and email entry and then change for the text last name to just email and we're going to place these where row equals 2 and we'll keep the column the same and for email entry row 2 column one so doesn't that look a lot better now let's create a submit button so let's call this submit button equals button and then we're adding this to the window and we should set some text text equals submit i guess dot grid and we want to place this underneath currently kind of just shoves it underneath for now let's say that we want this between these two columns so we'll want to set the row and the column to begin with row is going to equal three and column we'll set this equal to zero for now there isn't going to be any apparent change it's still going to be in the same place but one thing that we can do is use an option called column span we can have a widget take up more than one column and it's going to place this widget in between both of these columns in between the combined width of both of them so we'll add column span equals two so this widget is going to take up the next two available columns including the one that it's currently in and you can see that our submit button is now between these two columns that we have one thing that you should know is that the column width is dependent on the width of the largest widget that is contained within that particular column let's say that we increase the width of our first name label well our column is going to expand to actually fit that widget that we have so for our first name label let's set the width to maybe 20 and this is going to increase the width of column 0 and to even better demonstrate this let's color each label a certain color just for a visual for our first name label let's say this is red and then for our last name label let's set this to green and then for email maybe blue now all of these are color coordinated and you can see that the background color of our first name label is taking up the entire column space now what if we changed the size of our email label to something even larger like 30 so width equals 30. and now the column 0 has expanded to accommodate the size of our largest widget which is our email which has a width of 30 and before we finish this video let's add a title to the submission form right on top of the first name label and the entry label so let's call this title label equals label writing this to the window let's set some text let's say enter your info and let's pick font font equals what am i feeling like today maybe just arial and then a size maybe 25 we're going to use the grid geometry manager and we want this at the top so we want row zero at least i want this to take up two columns so we'll say column equals zero and then set a column span column span equals two now a few things are going to overlap here so we're going to move everything down by one row besides our title label so we want this first name label to be directly underneath our title label so let's move everything down by one row and our title is going to be directly on top of our first name label as well as the first name entry box that we have all right so that's the very basics of the grid geometry manager if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of the grid geometry manager in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create a progress bar in python so sit back relax and enjoy the show okay let's create a progress bar but we'll need a few imports to begin the progress bar widget is found within that ttk module so we'll need a separate import from that from tk enter dot ttk import everything and we'll import everything from time as well let's create a window window equals tk followed by window.mainloop we're going to add a progress bar and a button to this window when we click on the button it's going to fill our progress bar let's begin by creating a button to begin with let's call this button equals button we're adding this to the window let's set some text text equals maybe download and then a command maybe i'll call this start finish by adding this button to the window and we'll just use pack to do that let's define what our start function does def start we'll fill this in later i'm just going to print nothing just as a placeholder and we should just have a button now let's add a progress bar before this button and we'll call this progress bar just bar for short bar equals progress bar we're adding this to the window we can set an orientation this can be horizontal or vertical later on in this video i'll show you the differences between the two but for now let's set this to horizontal and then i'm going to pack this bar bar dot pack and add some padding pad y equals 10 and let's see what we have okay this is our progress bar at the top and this is the button when we click on this button it's going to fill our progress bar but i think i'm going to increase the length of this progress bar let's set this to maybe 300 i believe 100 is the default okay that's not too bad of a size now let's define what our start function does we can actually increase the value of our progress bar by typing in the name of this progress bar here value plus equals some amount let's say 10. so what's going to happen right now is that every time we click on this button it's going to fill our progress bar by 10 out of the total which is 100 let's pretend that we're waiting for a certain amount of tasks to complete so let's define a few variables let's say we have a variable called tasks and let's set this to 10 just to keep it simple and x will represent the current task that we're on and we'll say 0 to begin with let's create a while loop while x is less than the amount of tasks that we have we will increment the value of our bar by 10. 10 10 for each test that we have which is 10 for a total of 100 and we'll want to increment the task that we're on as well which is represented by x so let's increment x by 1 after each iteration of this while loop now when we run this and click download this spills instantly let's add a delay just to simulate each task waiting to be completed so let's add that here let's add a delay by using time dot sleep and let's set this to one second we're going to wait one second and then complete a task what ends up happening now is that nothing appears to be updating well what gives bro you lie to me well that's because the window is waiting to have this progress bar complete before it's actually going to display it being filled so we would want to refresh this window after each iteration of the while loop so at the end of this while loop let's add one thing window dot update underscore idle tasks after each iteration of this while loop it's going to update the window that we have so then when we download something it's going to update our progress bar after each iteration of this while loop until it's completed right about now let's take this a step further by adding a label that displays the current percent of the progress bar that is complete let's add this label after the progress bar but before the button sandwiched right between these two widgets so let's add that here we'll call this label percent label equals label we'll add this to the window and we'll need a text variable text variable equals let's call this percent so the reason that we use a text variable is so that we can update this label with some text after each iteration of our while loop and we'll need to pack this okay within the window near the top let's define percent percent equals string var this allows us to update percent with some new text and set the percent label with the new text that we have within the while loop but before we update idle tasks let's set what percent is percent dot set and let's say x divided by tasks and then we'll multiply this by 100 i'm just going to put this within its own set of parentheses times 100 and then we'll convert all of this to a string so we can display this along with some text there are a lot of parentheses here so it might be difficult to keep track of all this all right and then we're just going to tack on percent and that's it let's try it so we got 10 20 30 40 50. i'll shut up now one change that i'm gonna make is that i'm going to cast all of this as an integer before we convert it to a string because i do not like that decimal at the end of our percentage so yeah it says 10 percent 20 so on and so forth let's add a label that displays the current task that we're on so let's copy what we have for our percent label and let's rename this as maybe task label task label text variable will equal maybe text and let's define what text is so text is also a string var and within our while loop let's update the value of our text text dot set will display x plus maybe a forward slash plus our tasks and since we're displaying integers along with some strings we need to convert these to strings and we can use the str function to do that for us so surround x and tasks with str to convert these to strings and then we'll add just plus tasks completed so the value of x will update after each iteration of this while loop let's try it and after clicking download this will display the percentage as well as the amount of tasks that have been completed all the way until it reaches the end let's change this into a more practical example we'll pretend that we're downloading a video game so let's replace or rename tasks as maybe gb4 gigabytes and this game will be 100 gigabytes we'll rename x as well so let's refactor rename and change x to maybe download to represent the amount of gigabytes that are downloaded and let's create a variable called speed and let's set this to one alright so while our download is less than the amount of gigabytes for this game we'll sleep for maybe a portion of a second .05 should be good we'll increase the value of our bar by this amount speed divided by gigabytes and then multiply this by 100 for the download we're going to increment this by whatever our speed is and right now it's one so that's the same we can keep percent the same for our text let's change tasks to gigabytes and that's all the changes that we have to make and now when we download something we're kind of pretending that we're downloading a large file or a game you can see that once it reaches 100 it says 100 100 out of 100 gigabytes completed now we can change this to a different value let's say maybe 50 and the speed will be maybe two so this will adjust to accommodate whatever the new file size is as well as the speed and before i forget you can change the orientation to a vertical bar if you so choose so we have this vertical download bar now which could be good for something all right so that's the basics of progress bars in python if you want to copy of all this code i'll post all of this in the comments down below but yeah that's the basics of progress bars in python what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can use the canvas widget to draw some simple shapes so sit back relax and enjoy the show welcome back everyone well in this video we're going to be creating a canvas a canvas is a widget that is used to draw simple graphs plots and images within a window we're going to be creating some simple shapes in this video not anything too sophisticated i might get more into the canvas widget in a separate video and at the end of this lesson we're going to practice by creating a pokeball so to begin we'll need a window window equals tk followed by window.main loop to create a canvas we can just simply call this canvas canvas equals canvas and we're adding this canvas to our window and then we need to follow this with canvas.pack or place but i'm just going to use pack because it's simple this is what our canvas looks like it's a rectangular area which we can draw graphics on we can also set the width and the height of this canvas so when we create this canvas we're going to set the options for a height and a width so let's begin with the height height equals let's say 500 and the width will be the same 500 and now we have a square canvas that we can draw graphics on let's begin by creating some simple shapes maybe a line i think a line is a shape maybe a one-dimensional one i don't know i don't geometry so let's create a simple line so we type the name of the canvas dot create and there's a bunch of different shapes that we can create let's create a line now i'm just going to turn this into a comment for a moment we need to set some coordinates for this line this top left corner of our canvas is 0 0 and the bottom right corner of this canvas is 500 by 500 depends on what you set the dimensions of the canvas to so when we create a line we need a starting point and an ending point so if we want this to start in the top left corner we're going to pass in 0 0 that is the starting position and we can place the coordinates for the ending position if we want this line to end in the bottom right corner that would be where x is 500 and y is 500 and this is what this looks like we just have a simple line going across the screen but that's not all we can also change the color of this line and the thickness let's begin by changing the color so we can do that with fill fill equals let's pick color blue and now we have a blue line going across the screen but we can also change the width of this as well so we can do that using the width option and let's set this to five now we get an extra thick line across the screen now let's make a red line so i'm just going to copy this canvas.createline and let's change some coordinates for this uh let's say we want this to start in the bottom left corner and go up to the top right so the starting x position would be zero y would actually be 500 x for the ending position would be 500 and y would be zero let's set this to red and we'll keep the width the same okay so here's our red line and notice that this red line is overlapping the blue line so when you create shapes on a canvas if there's any that overlap the one that you most recently created will appear on the top one option available to you is that you can actually give these graphics a unique name with our blue line we could call this blue line blue line equals all of this and then we can call our red line something different like red line this would be useful if you want to call or use a graphic by its name if you want to like move a graphic on the screen or have something appear you can use this by its name but we don't really need it for this lesson so i'll just revert this back to what we had previously i'm just letting you know that you can do that alright what do we have up next let's create a rectangle so canvas dot create rectangle we can set some starting coordinates and ending coordinates the starting coordinates are for the top left of the rectangle and the ending coordinates are for the bottom right so for the starting coordinates let's say we're going to place this where x is 50 y is 50. for the ending coordinates we want this where x is 250 and y is 250 i'm just making up numbers put it whatever you want really and this is what this looks like but i think i'm going to comment out these lines for now and here is our rectangle well i guess it's also a square we can actually give this a fill color as well so we do that with the fill option fill equals purple i guess and now we have a purple rectangle next on our list is create polygon we can create many sorts of shapes using create polygon but it really depends on how many coordinates that we enter let's create a simple triangle so we need at least three coordinates for this to work so canvas dot create polygon and i have some coordinates picked out already so let's place the first set of coordinates where x is 250 y is zero for the second set where x is 500 and y is 500 in the last set the third set we'll place this where x is zero and y is 500 and what this looks like is that we have this black triangle that's taking up most of the canvas we can also change the fill color as well so we do that with the option fill and we can set this to whatever color you want let's say yellow and we now have a yellow triangle on our screen and it kind of resembles the triforce from the legend of zelda series one of my personal favorites let's also add a border this is actually done with outline outline equals and then pick a color for the outline let's say black and we have a black outline around this graphic and you can also change the thickness of this too with width and let's set the width to five and now we have an extra thick line around our triangle with these shapes you can pass in a list of points too so i'm going to get rid of all these and we're going to pass in a list so let's create a list called points points equals all the points that we just entered in previously and then instead of passing in all these coordinates individually i'm just going to pass in our list of points and this will work exactly the same okay let's create an arc now so canvas dot create arc and arc is really just a curved line between at two points however when we list some coordinates we're not listing the coordinates of the starting position and ending position for this arc it's more or less for the amount of space that we want to allocate to actually draw this arc so let's say that we want this arc to take up the entire canvas we can pass in the dimensions for this canvas so the top left corner is zero zero and the height and the width are five hundred so this is our arc it resembles a pie slice it's not starting in the top left corner and ending down here that's the amount of space that we're giving this crate arc function to actually draw an arc it's really an entire circle but only a portion of it is visible let's also set a fill color for this so fill equals what color did we not pick yet let's say green and now we have a green pie slice there's different styles you can do too so we can change that with style equals the default is pi slice that's what we had previously let's change this to chord this will draw a line between these two points and this kind of resembles like a bow like a ball with arrows and there's also just arc where it's simply just a curved line let's change this back to pie slice well because i like pie we can change the starting position of where this arc begins with the option start so start equals 0 by default so there's going to be no apparent change let's adjust this by 90 degrees so this is in degrees so this shifted what is this direction counterclockwise by 90 degrees so 180 would theoretically flip this and now this is on the other side of what we had previously and then 270. all right we can also set an extent so the default is normally 90 degrees but let's change this to 180 and now we have a what is that hemisphere half a circle all right people let's practice by creating a pokeball there's still one more function that we have to cover it's called create oval but we'll do that as we're making this so let's begin by creating the top red hemisphere of this pokeball so that's canvas dot create arc and we're going to set the extent of this to 0 0 500 500 so that this is going to take up the entire canvas and then let's also set a fill color to red so fill equals red we need to change the extent of how far this extends so we'll do that with the extent function so extent equals 180 so that this is a half circle and let's also change the thickness of this outline as well using the width option so width equals 10 would be good and we have a red hemisphere for the top of our pokeball let's work on the bottom half so that is a white hemisphere so canvas dot create arc these are all the same we'll change the fill to white the extent will be the same but we need a different starting position so start equals 180. so this is going to begin at the 180 degree mark so when you combine these both together we get two different colored hemispheres that form a perfect circle now let's create an oval within the center of this pokeball so we're going to do that with canvas dot create oval we're going to set the amount of space that we want to give the circle to be drawn so we'll place this where x is 190 where y is 190 where x 2 or the second x position is 310 and y2 is 310 let's set the fill color next so we do that with fill fill equals white and lastly let's just give this a thicker border so that is width equals 10 to match the width for the two arcs that we have and there you have it we have a simple pokeball all right well that's the basics of the canvas widget if you'd like a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of the canvas widget in python what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create key events in python so sit back relax and enjoy the show welcome back everyone in this video we're going to be discussing at key events we can bind a key event and a function to a widget or a window so that when we press a certain key or do something we can trigger a function to be called that will perform some sort of task for us so we can actually do this by using the bind function so widgets and windows have access to a bind function so when our window or our widget is selected and then you press a certain key or do something then it's going to call a certain function to perform a task for us so there's two arguments within the bind function this takes an event as well as a function name let's say that when we press the enter key we want to call this function to do something so for this event what we type for that is a set of quotes angle brackets and the name of the button so for example if you want to press w to move forward like you're playing a game this would be w a s d there's also up down and then let's say we want to press enter to do something that is actually a return and then we will call this function so let's create a function called do something and let's define this at the top def do something now pay attention to this part we need to set up one parameter for this do something function this needs an event so be sure to include that and it's easy to forget so what do we want to do after we press enter let's just print a message you did a thing and this should work now so let's try it so while this window has focus ability we can actually uh have this respond to events so right now i'm pressing all sorts of keys you can probably hear me right now going crazy on my keyboard but now i'm going to hit enter and it says you did a thing and you can bind all sorts of keys to this window let's say that i want to press q to quit so we'll just replace this with lowercase q so i'm typing all sorts of keys but now i'm going to press q and it says you did a thing kind of like we're quitting the game you can actually have this respond to all keys well almost all of them so to do that you just type in key with the capital k so i can pretty much press on any key then it's going to trigger or call our function kind of like that so one thing that we could do we can display the key event that was pressed so i'm just going to add that here maybe i'll change this message u pressed plus and to display what key was pressed that is event dot key sim i believe that's for key symbol so this will actually display what button you pressed so w-a-s-d here's a unique idea for practice let's say that we want to add a label to our window and we're going to change the text on the label to reflect whatever key that we press so let's create a label label equals label we're adding this to our window and let's change the font as well to something massive like helvetica and a size of 100 that should be good then we need to pack this label so label dot pack then within this function let's turn this into a comment and we're going to use label dot config and we're going to update our text and the text is going to be whatever key that we press so we can do that with event dot key sim so now this label is going to display whatever key that we press so for example w a s d backspace escape up up down down left right left right b a start all right so that's the basics of key events if you could do me a favor and in the comments down below just press f to pay respects so if you want a copy of this code i'll post this in the comments down below but yeah that's the basics of key events in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys all about mouse events in python so sit back relax and enjoy the show hey everyone we're going to be discussing mouse events in python so before we begin we'll need a window so window equals tk followed by window.main loop and in the last video we learned that we can bind a widget or a window so that when a certain event occurs we can call a function so we're going to do the same thing for this video but we have various mouse events that we can cover so we're going to use the window.bind function and this takes two arguments an event as well as a function name so let's define a function let's call it the do something function so do something and we'll need to define this so at the top def do something and remember that we need to set up one parameter for this function the parameter is an event and then we'll just print something print you did a thing okay so there are various mouse events for a left button click within quotes and then within angle brackets a left button click is button dash one so then if we were to click within this window it's going to call our function you did a thing but if i were to right click it doesn't do anything so there are other mouse events too so button two is that scroll wheel not if you scroll up or down but if you press in on it so right now i'm clicking left i'm clicking right now i'm going to press in on the mouse wheel and it says you did a thing button three is a right mouse click so i'm clicking left nothing but i'm gonna click right and that seems to work all right so button one i'm just going to add a note left mouse click button two is the scroll wheel that's if you press in on it and then button three is a right mouse click so did you guys know we can actually get the x and y coordinates of where this event occurred so to do that we type in the name of the event dot x however since we're displaying this along with some text we'll need to convert this to a string so string event dot x then i'll add the y coordinates as well event.y i think i'll just add a comma between these to separate them and we'll change our text so we'll say mouse coordinates all right let's try this again so this is going to give us the coordinates of where we click and right now i'm just left clicking so the top left corner is zero zero well at least close to it not there exactly alright so here's a few other events that we can cover i'm going to copy this we have button release if we were to release a button it's going to trigger our event so right now i'm holding in on the left mouse button but i'm going to let go then it triggers our event if i were to right click and hold it it doesn't do anything but as soon as i let go then our event is triggered we also have enter not to be confused with the enter button just going to get rid of that so that is enter if we were to enter our binded window or widget so if i were to enter it's going to give the coordinates of where i entered this there is also leave so i'm going to say that enter the window and leave is leave the window so if i enter nothing happens but as soon as i leave it gives the coordinates and the last one is motion as long as the cursor is in motion so this one might be good for a game so that is motion where the mouse moved it's consistently giving me the coordinates if i'm moving the mouse but if i were stationary or stop moving it stops all right so that's the basics of mouse events in python if you want to copy of all this code i'll post all of this in the comments down below but yeah that's the basics of mouse events in python hey what's going on everybody it's bro here hope you're doing well and in this video i'm going to teach you guys how we can drag and drop widgets in python so sit back relax and enjoy the show all right people let's just dive into this so we'll need a window and then we're going to be adding widgets to the window so window equals tk followed by window.main loop now you can drag and drop all sorts of widgets but let's just stick with the label because creating a label is simple so let's define a label label equals label we're going to be adding this label to the window and let's set a background color so we can actually see this label pick i don't know your favorite color i'm going to pick red and then i'm going to set a width and a height because normally if you have a label without any text it's really small so let's set a width of maybe 10 and then a height of 5. that should be good and we want to place this label someplace within the window so label dot place and we can pass in some x coordinates as well as y coordinates so x equals zero and y equals zero so that this is going to appear in the top left corner of our window so this is what we have this is our label and we want to be able to drag and drop this label someplace within the window what we're going to need to do is actually bind this label twice but let's begin with just the first binding so in order to bind a widget you type in the name of the widget followed by calling the bind function so this bind function can take two arguments it can take an event as well as a function name so for the function name let's call this drag underscore start but you don't really need to name it the same that i do and for the event that occurs this is going to be a left button click with the mouse so that event is within quotes and within angle brackets button dash one so if we were to click someplace within the label using the left mouse button it's going to call our drag start function but we need to define this so at the top of our program let's define this function def drag start and this takes one parameter the parameter we have is our event so what we're going to do is actually get the coordinates of where we click within this label and we're going to assign these to a new variable or attribute of our label so label dot let's create an attribute called start x equals our event dot x so this is where we click within the label and not necessarily the window and let's repeat the process for y so label dot start y equals event dot y so we're going to have some coordinates of where we click within this label and we can actually use that for our next function so we're going to bind this label a second time so i'm going to copy this line and paste it the second binding let's say is drag underscore motion for the function name and this event is going to occur if we were to hold down the left mouse button and then drag so that is b one dash motion and then we need to define this function so at the top d e f drag underscore motion and this takes our event as a parameter so this part is going to be a little funky we're going to get or create new x and y coordinates so let's begin with x x equals the name of our label or widget label dot w info underscore x this is a function so add some parentheses this will get the top left x coordinate of our label relative to the window that we're in minus label x well labeled.startx plus event dot x all right so we're going to do the same thing for y well we're going to replace x with y for the second line all right so this is the top left corner the x coordinate of our widget relative to the window this is the place where we click within the label itself and this is where we begin dragging our widget to it's a little difficult to explain but if you can find combine combine all of these together you'll get the new coordinates of where you want to drag this component this widget to so we need to replace this widget so label dot place x equals x and y equals y so then when you combine all of these together we have our widget and we can drag it and drop it someplace else within the window now wait a second what if we have more than one widget well with the way that our functions are written now they wouldn't be compatible with more than one widget just this label itself so what if we were to create a second label so i'm going to call the second label just label two so i'm just going to rename them and let's change the background color to maybe blue and i'm just going to place this somewhere else within our window so maybe where x is 100 and y is 100 and we'll need to bind label two as well so make sure to bind label two so we have label one binded it's just called label and the same thing with label two all right let's see what happens i'm going to attempt to drag label 2. the label 1 is moving that's because with our functions we stated we're getting the coordinates and we're storing them within the attributes of label 1 and not necessarily label two so in order to make these functions compatible with all widgets we can actually add one line of code widget equals event dot widget so this is going to get the widget of the event that we're dealing with and we're going to temporarily rename this as widget so now we're going to replace all instances of where we use label and replace it with widget be sure to do the same thing too with drag motion and then we will need to add this line at the top of drag motion so now these functions are now compatible with any widget that we create and we should be able to drag and drop both widgets all right well that's the basics of dragging and dropping widgets in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of dragging and dropping widgets in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can move an image on both a window and a canvas in python so sit back relax and enjoy the show all right my fellow bros i'm going to divide this video into two different sections in the first section we're going to move a widget within a window and in the next section we're going to move an image on a canvas so let's begin by moving a widget within a window so we'll need a window window equals tk followed by window.mainloop and we'll also need to set some geometry for this window window dot geometry let's make this 500x500 500 x 500 and let's take a look okay that should be a decent size let's add a label to this window so i actually have a race car image that i want to use if you would like an image feel free to pause the video and download one what i would like to do is create a photo image from this png file that i have i'm just going to call this my image equals photo image file equals since this is within my project folder i can just list the file name otherwise you might have to list the file path and for me this is called racecar.png i want to add this image to my label not necessary but it'll be helpful for this example i'm going to call my label just a label label equals label i'm adding this to the window and i'm going to set the image to equal my image that i created it's a photo image if you do not have an image that you want to use you can simply just change the background color you could say bg i don't know red oh then we need to place this so be sure to do that label dot place and i'm going to place this in the top left corner that is where x equals zero and y equals zero and then we should have a race car or whatever image you used and a red background you can get rid of the background color if you prefer that's just if you don't have an image to use you can set the background color just for a visual to show you where the label currently is let's set some key bindings for this window and let's add them maybe here before we create the label and our image so let's find the w key for up s for down a for left and d for right so we do that with window dot bind and we pass in an event as well as a function name so we want to tie the w key to a function and we'll call this move underscore up and then we will need to define this so outside of the window let's define move underscore up and this takes an event so we'll place that as a parameter and to move our label up we're going to take label dot place and we're going to place this at some new coordinates x equals the label's current position relative to the window that it's in so that is label dot w info underscore x all right so then for y it's similar y equals label dot w info underscore y but we're going to subtract maybe one all right so this is all we need although this is only going to move up so i'm going to press w and our label our race car or whatever image you used is going to move slowly up i'm going to increase this to 10 so the change is more drastic so now our race car is drifting off into space let's find a few other keys s a and d sad all right so s will be down move underscore down a for left move left and d for right move right we'll just copy what we have here and make a few changes let's begin with move down the only thing we're going to change within here is in place of subtracting 10 from the y coordinate we're going to add 10 and with our race car oh i guess we have to define these so let's do that real quick uh so we have left move left we're going to subtract 10 from the x coordinate and keep y the same and then the same thing for move right move underscore right and this time we are going to add 10 to x and y will stay the same okay now with our image we can move up down right and then left and y stop there we combine these to our arrow keys so up is just up with a capital u down is down these are all capital by the way left is left and then right is right and now i can use my arrow keys to move this image now for this part of the video i'm going to teach you guys how we can move an image on a canvas this time and not just within a window but we'll need a window to begin with window equals tk followed by window.mainloop and we're going to create a canvas canvas equals canvas we're adding this canvas to the window and let's set a width and height for the width let's make this 500 and the height 500 as well so this is an even square and we'll need to pack or place this canvas canvas.pack should take care of that and let's run this and this is our canvas at this step we need to add an image to our canvas and i have an image of a racecar that i want to add so i need to create a photo image from this file so we can do that let's give this photo image a unique name i'm just going to call this photo image to keep it simple photo image equals photo image and i can list the file path or the file name since this image is within my project folder i only have to list the file name and my file is called racecar.png this next step we need to give our image a unique name the image that's being added to the canvas i'll call this my image equals and we need to turn this photo image into an image added to the canvas so we type in the name of the canvas canvas dot create underscore image we first need to list the coordinates of where we want to place this photo image so let's place this in the top left corner that is where x is 0 and y 0 and we need to set the image of the image that we're creating so we can do that with saying image equals the name of our photo image and let's see what we have so far so this image is somewhat cut off in the top left corner we can easily fix that by anchoring our image when we create it so let's at the end add anchor equals northwest so that should fix that problem and we now have our image that we want to use and to move our image we can set some key bindings so we type in the name of the window dot bind and we pass in two arguments an event as well as a function name let's tie pressing the w key to moving up so the first argument is going to be w and the second is going to be a function name so let's say move underscore up and let's find some other keys w for up s for down a for left and d for right we'll need to define these now so at the top outside of the window let's begin by defining move up def move up this has an event as a parameter and let's create the other definitions here so i'm just going to rename these so we have move up move down move left and move right okay now this next step we can use the canvases move function to move an image a certain amount of pixels on the x-axis and y-axis so let's begin with move up we type in the name of the canvas dot and use the move function and this has three arguments the image that we want to use and this image is called my image the one with the race car the next argument is the amount of pixels we're moving this on the x-axis with up we can keep this the same but on the y-axis let's say we want to move this up 10 pixels so that would be -10 and let's repeat the process for move down move left and move right for move down we're going to change y to 10 for move left we'll keep y the same at zero but we're going to subtract 10 and then move right we are going to add 10 to our x's and that should be it so we can move up down right left and if you want to bind these to some arrow keys all we have to do is just change the event so we can bind these to our wsad keys as well as up down left and right and this time i'm going to use my arrow keys up down right and left all right so that's a few of the basics of moving either widgets or images on a canvas or window if you would like a copy of all this code for both examples i'll post both of them in the comments down below but yeah that's the basics of moving widgets and images in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can create some simple 2d animations in python so sit back relax and enjoy the show alright my fellow bros in this video we're going to be animating an image on a canvas we're only going to be moving this image up down left and right feel free to download an image that you want to use i'm just going to use this ufo emoji that i found so we'll need two imports at the top from tk enter import everything that's what we usually have we'll also need to import time as well we'll need a window window equals tk followed by window.main loop we'll need a canvas i'm going to call the canvas canvas canvas equals canvas we're adding the canvas to the window i'm going to create something that's called a constant we're going to create a constant for the width and the height of our canvas so a constant is a variable or value that you don't plan on changing later at all and a common naming convention for a constant is that the name of the constant is all uppercase so i want the width and the height of this canvas to be constants so for the width this is going to be all uppercase it's not necessary to make it all uppercase but that's a common naming convention for the width i'm going to set this to 500 and the height set to 500 as well and for the width of this canvas i'm going to set the width to equal my constant which is 500 and the height to my constant height so the reason that i'm making constants is that we'll be reusing these a lot later in this program so we might as well just declare them now and get it over with so for the canvas we're adding this to the window we're setting the width to our constant of width and the height to our constant of height and we need to follow this by packing this or place canvas dot pack pack to make it simple so we should have a canvas on our window now if you have an image that you want to use we're going to animate it i need to create a photo image from this file it's a png file it's called ufo but yours is probably going to be named something different so don't copy me exactly i need to create a photo image from this i'm going to call this photo underscore image but name it whatever you want this equals photo image and i need to list the file path or the file name since this file is within my project folder i only have to list the file name and for me this is called ufo.png our next step is that we're going to take our photo image and add this photo image to the canvas and we'll also give this image a unique name i'm going to call this my image equals we're going to use the canvases create image function so canvas dot create image there's a few arguments that we need to pass in where we want this image to appear we need a set of coordinates if we want this to appear in the top left corner that is where x is zero and y is zero for the image we're going to set this equal to our photo image whatever you named this and lastly we should anchor this i'm going to anchor this in the northwest corner to keep it simple and we should have our image on our canvas in the top left corner and here is my ufo that's being piloted by a green alien that's waving to me aliens are usually not that friendly unless they're abducting you our next step is to create a while loop so we'll say wow true this will continue forever until we close out of the program if you're looking at the code for a game this might say instead while running running will be a boolean variable that contains either true or false so if this is true while the game is running they're going to continue moving all of the characters on the screen and then if somebody pauses the game or closes out of the game then they'll flip this running variable to false but to keep things simple we'll just say wow true but that's something that you might see what we'll want to do is get the coordinates of our image within the canvas and this will return a list of coordinates so let's create a list called coordinates so coordinates equals canvas and we can use the chords function to get the coordinates i guess that's short for coordinates and we're getting the coordinates of my image so we'll pass this into this function and then let's print this just to see what this returns we'll print coordinates okay now to update the window after each cycle of this while loop we can use the update function of our window so window.update will also have this thread sleep for let's say 0.01 seconds so time dot sleep 0.01 one so here's a quick rundown of what we have going on so far within this while loop we're going to first get the coordinates of where our image is located we'll print the coordinates to the console window this part isn't required but it's going to help us for learning purposes we'll update this window for any changes and then our thread which is in charge of running the program is going to sleep for i believe that's a hundredth of a second so when we run this our image is staying in place and we know that our while loop is running because it's continuously printing the coordinates the first number is the x position the second number is the y position and now we're going to give our image a speed or velocity i like to call it velocity and in fact i'm going to give this image two velocities one for how fast this image is moving on the x-axis and another for how fast it's moving on the y axis so i'm going to create two variables one called x velocity and i'm going to set this equal to one and y velocity and i'll set this to one as well okay so what we need to do now is update the position of our image so let's do that before we update our window so i'm going to type in the name of the canvas and use the move function this move function takes three arguments what you want to move i want to move my image my ufo and how far i want to move this image on each axis each coordinate so what i want to do is update the x velocity the x position of my image so i'm going to pass in my x velocity variable and then y we'll just keep the same for now so we'll just say zero so after each iteration of this while loop my ufo is going to move one pixel to the right and it's just going to go off into the void forever and now if we replaced x velocity with zero and for y we set this to our y velocity this image is now going to travel down and it will continue into the void forever and then if we combine both of these together we're going to move diagonally down and to the right so what if we want this image to bounce off the walls we're going to add some if statements we're going to begin by just having this image bounce off the left and right walls for now let's set y velocity to zero so that this image is only moving left and right so before we move this image we'll add an if statement we're going to check to see if the x position of our image is either greater than the width of the canvas or if it's less than zero so we take our coordinates and we're going to get the first element from this list so that is zero that is x the x value if coordinates at element zero is greater than or equal to the width of this window and this is a constant so we can just place that here if coordinates well x within our coordinates is greater than or equal to width or coordinates at index 0 is less than 0 then we want to reverse the direction or flip the velocity so we want to change our x velocity and make this a negative number one easy way to do that is that we can take x velocity equals x velocity times negative one or another way of writing this is just to say x velocity minus negative velocity now what ends up happening is that when this image reaches the right border it's going to bounce back however it only bounces back after it reaches the top left corner of the image we need to factor in the width of the image as well so we're going to create two new variables and let's do this right before the while loop we'll want to determine what the height and the width are for our photo image that we have so this is what we're going to write let's call these two values image underscore width and image underscore height so we need to determine what the width and the height is for our photo image and there is a function to do that type in the name of the photo image dot and there is a width function and the same thing for height photo image dot height and then we can reuse these so i'm just going to add one line to the sift statement if the x position of our image is greater uh greater than or equal to the width of our window minus the width of our image and i'm just going to put these within parentheses just to keep these more organized and what ends up happening now is that when the right portion of our image hits the right wall it's going to bounce off and let's do the same thing for our y velocity we're going to replace coordinates at index 0 with 1 and change that here as well replace with with height and this is image underscore height and we're going to change the y velocity this time and when we move this image let's also add the y velocity and now our image is just going to bounce off the walls forever but it's kind of predictable since we set x and y to equal one now let's change the speeds to kind of spice things up let's say for the x velocity this is three and y velocity this is now two this is going to go in a completely different direction so you can mess with the speeds however you want so guys how about we add a background image to this well because we can i'm going to reuse this image of space from my java video on this same topic i need to create a photo image from this and i'm going to copy what we did for our normal image that we were moving and animating so this is called space.png well that's the name of my file and i'm going to give this image a different name maybe i'll call this background underscore photo and then i'm going to add this photo to the canvas and i'm going to call this a different name i'll just call this background all right so our window should have a background now and then our image moves on top of the background so make sure you add and create the background before you add any other images otherwise the background might overlap your image alright so that's the basics of some simple animations in python if you want to copy all this code i'll post all of this in the comments down below but yeah that's the basics of some animations in python hey what's going on everybody it's your bro here hope you're doing well and in this video i'm going to teach you guys how we can animate multiple objects in python so sit back relax and enjoy the show welcome back my fellow bros in this video we're going to be animating multiple objects within a window more specifically we'll animate some circles and each of these circles will have their own characteristics speeds and directions so we'll need two imports to begin from ck enter import everything we'll also be importing everything from the time module as well we'll need a window window equals tk followed by window.main loop i'm going to create two constants one for the width and one for the height let's set the width equal to 500 and the height equal to 500 as well we'll create a canvas and we'll be animating the circles that we're going to create on the canvas so let's create a canvas canvas equals canvas we're going to be adding the canvas to the window and we'll set the width of our canvas equal to our constant width which is 500 and our height equal to our constant of height which is also 500 and we will add this canvas by using the pack function canvas.pack here's our canvas and we're going to be creating multiple circles let's pretend that they're all different sports balls like a tennis ball baseball volleyball bowling ball they'll all be bouncing off of the borders and once each of them encounters a border they will change direction since we're going to be creating multiple objects i think it's best if we do this with another class so let's create another class i'm going to go to file new python file and let's call this class ball and click python file and we need to define this class class ball and we also need a constructor for this ball class we can create one with def two underscores i-n-i-t two underscores again and we can set up the parameters of what we want to receive if we were to create a ball object so let's pretend that we're going to be creating a volleyball to begin with so let's call this ball volley underscore ball equals ball and we'll pass in some arguments so let's set up the parameters first what do we want to receive one we want to receive our canvas so that we can actually draw this oval we can draw this ball we should also have an x and y position a diameter x velocity y velocity and a color all right so when we create a ball like a volleyball we're going to pass in whatever the parameters require so we need a canvas x y a diameter an x velocity y velocity and a color so within the constructor for the ball we're passing in our canvas it's kind of like what we do with widgets we're specifying what we're going to be adding this widget to we're going to be adding this ball to our canvas we also need x y and a diameter let's make this simple by setting x and y to both zero for the diameter let's set this to maybe 100 and we also need an x velocity and y velocity let's set this both to one and a color so let's pass in a string like white let's head back to our ball class and finish assigning all of these arguments that we're going to receive the first step is that we'll say self dot canvas equals the canvas that we receive when it's passed to us as an argument our next step is to draw this oval draw this ball and we'll say self dot image equals canvas dot create underscore oval and with creating ovals we can pass in x y and with circles the diameter is equal for both the width and the height so we'll pass in our diameter twice and lastly a fill color and we'll say this is equal to the color that we receive which is white we're going to set the x velocity and the y velocity this is related to the direction that it's initially going to head in so self dot x velocity equals the x velocity that we receive and we'll do the same thing for y velocity self.y velocity equals y velocity now since this is in another class we need to import this class from ball import everything and you can see that this red underline went away so let's see what happens now we have our volleyball but it's not currently moving so that's the next step so let's create a function within the ball class called move that we can call upon so we'll do this after the constructor cef move and this will take self as an argument the first thing that we should do is get the coordinates so we'll say coordinates and this is a list coordinates equals self dot canvas dot c o o rds and we'll pass in self dot image and we will print these coordinates just to see what's here all right now we'll create a while loop within our main class so let's add that near the end and we'll just say while true so while this is running let's move our volleyball so volleyball dot move so this will call the move function of our volleyball and then we will update the window window dot update so that this refreshes and we will sleep for maybe a hundredth of a second time dot sleep 0.01 but you can put whatever you want here so this is going to at first just print the coordinates of this ball so it's not currently moving and this time with our list we have four coordinates zero zero that's the top left corner and 100 100 that's the bottom right corner so this time we have four coordinates that we have to deal with the top left corner as well as the bottom right corner our next step is that we should move this image self dot canvas dot move what object are we going to move we're going to move self dot image and in what directions self.x velocity as well as self dot y velocity now our ball is going to move across the window and it right now it's displaying all of the coordinates we don't have any bounds set up so it's just going to continue into the void forever so we should set up some if statements to check to see if one of the borders touches one of the walls of the window if so it's going to change direction so let's check to see if the left or right side of our ball touches one of the left or right borders so let's write an if statement if and then let's take a look at these coordinates if coordinates at index 2 that is this one 0 1 2. so this is the bottom right corner with these two sets of coordinates if coordinates at index 2 is greater than or equal to i'm going to put these within parentheses self dot canvas and we need to get the width of the canvas one way which we can do that is to use the w info underscore with function so this is going to get the width of the canvas and then let's add one more thing or coordinates at index zero is less than zero so if this ball touches the left or right border we want to change direction so we can flip the x velocity self.x velocity equals negative self x velocity and let's do the same thing for the top and bottom borders so let's copy what we have and we'll replace coordinates at index two with three and we'll also replace w info underscore width with height and coordinates at index one change self dot x velocity with y velocity same thing here as well alright and that should be everything let's try it so let's see if this ball actually bounces off the borders which it does pretty cool so that's everything we need to do within our ball class now if we need to create multiple balls we can just construct them so let's say this time we would like a tennis ball i'm going to name this volleyball as tennis ball and let's make the diameter smaller like five but we'll make this a lot faster like for the velocity let's say four and three and the color let's make this yellow and we also need to call the move function of this tennis ball so within the while loop tennis ball dot move and then we should also have a tennis ball moving across the screen in a different direction now technically we don't need to print the coordinates but i tend to do that just for teaching purposes to better demonstrate all of this now our ball class is acting as a blueprint for how balls should be created and the behavior that they exhibit and if we need to create a ball we can just come up with a name for the ball and call the ball constructor to take care of that for us kind of like what we've been doing with widgets so all we need to do to create another ball is come up with a unique name for the ball and instantiate it using our ball class that we created so this time let's create a basketball i'll rename this as basketball and we'll pass in different arguments based on how we want to customize this unique ball so for the diameter let's say this is now 125 and the x and y velocity let's set this to something very fast like eight and seven and with the color let's change this to orange and make sure you also call the move function so basketball dot move and we should have a basketball moving across the screen all right everybody so that's the basics of animating multiple objects in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's how to animate multiple objects in python hey what's going on everybody it's ibro here hope you're doing well and in this video i'm going to teach you guys how we can create a clock program in python so sit back relax and enjoy the show all right my fellow bros in this video we're going to be creating a clock gui program so we'll need a few imports from tk enter import everything and from time import everything as well we'll need a window window equals tk followed by window.main loop and in this program we're going to be creating three separate labels one for the time another for the day of the week and another for the date so let's begin with just displaying the time and work on the day of the week and the date later so let's create a label for the time called time label equals label we're adding this to the window and let's set the font because we can i'm going to choose maybe ariel and then a size of 50 so that this is somewhat large i'm going to change the foreground color that is the font color and i will pick a hex value of green so that is 0 0 f 0 0 but feel free to pick whatever color you want and i'm also going to set the background color and you can pick a hex value or a color name i'm just going to say black and then i'm going to pack this label time label dot pack now we're going to call a function and we'll call this update and we'll define what this does after every second has passed we will use a recursive function to keep on updating the time every one second or so so let's define what this function does def update there is a function within the time module called strf time which we can use to return the current time and format it however we want so we're going to actually place this within a string variable and we'll call this time string and this function is strf time i'm actually going to go to python's website just to give you an example of how this works here we are on python's website and this is the strf time function and this converts a tuple representing a time as returned by gm time or local time to a string as specified by the format arguments so when we call this function we can pass in directives as arguments based on what we want to display if we want to display the current time there is a few directives that we can pass in so let's say that we want a 12 hour clock as represented by a decimal number between 1 and 12 well we would pass in percent i as an argument if we want the minutes that would be right here percent m and if we want the seconds that is percent s so we're going to pass in these directives as if they are arguments so within this function we'll pass in those format specifiers or directives so i want percent i followed by percent m and percent s alright uh but these also have to be within quotes so don't forget that because i just did okay this will display the current time oh then we also have to update our time label so time label dot config text equals our time string because remember that this returns a string of text text equals time string so this will display the current time and right now it is six in the morning or so however we just get one long jumbled number so it would be a good idea if we separated some of these numbers so within our strf time function i'm just going to add some colons to separate these values and this will display the current time it is currently 6 46 in the morning let's add am or pm to the end of this so the directive for that is percent lowercase p 6 46 am now how do we update this label every one second to reflect the current time well that's a good question and i'm glad you asked it so we're going to use the time labels after function we pass in a delay and then a function that we want to call after that delay so let's say we want to call this function update every 1000 milliseconds or one second so we'll pass in the delay as an argument 1000 milliseconds and the function that we want to call and we're going to perform what is known as a recursive function we're going to call a function within itself so after 1000 seconds we're going to call update again and it's going to repeat the process it's going to return the time and format that time and update our label with the new time so what ends up happening now is that our clock is going to update every 1000 milliseconds now let's add a few other labels let's say the day of the week i'm going to copy what we have here and let's rename this as day label but i probably don't want this to be the same size for the font let's say ink free because i like that font and a size of maybe 25 and i'll get rid of the coloring it's the same process as before really so let's replace time string with day string the directive for strf time to display the day of the week is percent a and we're going to replace time label with day label text equals day string and this will display the day of the week and it is currently wednesday and if we want to display the current date we can create a label and we'll call this date label and i'll make the font slightly bigger maybe 30. we'll copy what we have for our day string and rename this as date string so we have a few options for the date i want to display the name of the month the day and then the year so that would be percent capital b percent lowercase d i'm going to add a comma to separate the day and the year and percent capital y and then i want to set the text of my date label to my date string so that this will now display the current date there's just one quick change that i think we should make right now we have three different labels a time label a day label and a date label and right now we're using the after function of the time label so since we have all of these different labels i think we should replace time label with our window because our window has an after function as well so that after 1000 milliseconds has passed we can update the time the day of the week and the date all right so that's the basics of creating a simple clock program in python if you want a copy of all this code i'll post all of this in the comments down below but yeah that's the basics of creating a clock in python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to show you all how we can send an email using python so sit back relax and enjoy the show oh a quick note for you all you're going to need a gmail account to sign into as well as your username and password so once you have those set you're ready to begin all right let's begin by importing the simple mail transfer protocol library we'll need a couple variables to hold strings let's say we have a sender a receiver a password a subject for your email as well as a body for the email okay sender is going to be you sending the email so enter your email in here i'm just going to make up one you at gmail.com actually sender would be better i would say let me change that sender at gmail.com let's say we have a receiver this is who you're going to send the email to receiver gmail.com don't actually enter in these emails use your owner the person that you intend to send the email to for your test because these will probably not work i'm assuming then enter the password for your gmail account so let's say password123 and a subject uh let's say python email test and a body what do you want to say within your email i wrote an email okay so that should be good so remember that you're going to want to change these to your actual gmail account and you'll want to send it to a valid email address too and make sure that you use your password for your gmail account okay now we're going to create a header for our email and the syntax on this is a little strange we're going to say message f and then triple quotes so what this triple quotes is is that a triple quote string can span multiple lines of text so the first thing we'll enter is from within our header from and then since we're using an f-string we can insert a variable at a given location when we insert a pair of these curly braces so from will be sender the next line to colon receiver then the next line subject colon subject this will be the title of the email then i'm going to add a new line and then insert the body and if you want you can give yourself a name when you send this email let's say maybe snoop dogg and if there's somebody you want to send the email to and give them a name you can say like nicholas cage but these aren't necessary okay so we have our header completed let me just add a note that this is our header okay we're going to create a server object server equals smtplib.smtp there are two arguments the first is smtp the other argument is the port number and that is going to be 587 that is the default mail submission port 587 now we're going to take our server object and start tls transport layer security okay now we need to log in so server dot login we will pass in our sender email that's us as well as our password password and let's print logged in we'll eventually place all this within a try and accept block later all right and then to send an email type server dot send mail and we pass in our self sender receiver and our message sender comma receiver comma message and let's print a confirmation print email has been sent now if you were to run this program you may encounter this error smtp authentication error that either means your username password combination was not correct or you need to turn on the less secure app access on your gmail account which you can find here however i would recommend turning that back off when you're done with this program just because your account will be less secure and i'm not liable if you get hacked hey you know what let's place this code within a try block we will try all of this code and then if we encounter this exception we can catch and handle it properly so we will try these four lines of code and we will handle our exception of smt lib dot smtp authentication error that means we could not sign in so let's print unable to sign in so i'm going to run this one more time and instead of getting that ugly error we should get a simple message that says unable to sign in once you have the proper username password combination for your gmail account and if you need to set less secure app access to on but make sure that you turn it back off when you're done with this you should be able to send an email let's try it logged in email has been sent here is a snapshot of the email that i received i blurred out my actual email because i don't want it public because some of you guys are weird so we have our sender our receiver and i gave myself a nickname of snoop dogg that's why it says snoop to nicholas the receiver but you don't actually need a name for these as long as you have the sender and receiver fields filled in you should be good we have our subject python email test as well as our body i wrote an email well everybody that's how to write and send a simple email using python if you would like a copy of this code i will post this to the comment section down below but yeah that's how to send a simple email using python hey what's going on everybody it's you bro hope you're doing well and in this video i'm going to show you all how we can run a python file using command prompt so sit back relax and enjoy the show hey y'all in today's video i'm going to show you all how we can run a python file with command prompt so first we'll need a script to work with let's just make a very simple program let's say print hello world and then maybe we will ask for some user input name equals input what's your name and then at the end we will print the word hello plus the user's name okay so let's save this to a place that will remember perhaps my desktop now to save this file to a separate location go to file save as you can pick a name for this python file then to directory click these three dots and pick a location you want to save this to to make this easy i'm going to save this python file to my desktop and then click ok so the name of this python file of mine is hello underscore world dot py then click ok now our second step is to open command prompt to open command prompt just search for cmd if you're using mac i believe it's terminal step number three is that we need to navigate to the directory that contains our python file i saved this python file to my desktop so if you right click on your file and go to location you can just copy this address now within command prompt type cd to change directory space and then paste that directory that contains your python file hit enter and for the last step we need to invoke the python interpreter by typing python space and then the name of the script and the name of my script is hello underscore world dot p y hit enter to run the script hello world what is your name bro hello bro so that is how to run a python file with command prompt i will post all of these notes to the comments section down below and well yeah that's how to run a python file with command prompt it's you bro hope you're all doing well and in this video i'm going to show you all how we can use pip for python to download packages and modules so sit back relax and enjoy the show alright people pip for python pip is a package manager for packages and modules from the python package index if you're using python version 3.4 or above pip should already be installed if you're using a python version below 3.4 one option is that you can always update your version of python just click download open when done go to customize installation make sure that pip is checked go to next and add python to environment variables then install now to use pip open up command prompt and type pip for a help menu all sorts of different general options and commands will appear if you need to check your version of pip type this command and here's a cheat sheet that i wrote so to check the current version of pip type pip dash dash version enter and currently the version that i'm using is 21 if you need to upgrade pip use this command pip install dash dash up grade pip mine should be the latest version yeah requirement already satisfied and if you need a list of installed packages type pip list so here's all of the packages that i currently have installed some of these you might recognize like numpy pie game pie installer those are just a few to check to see if any of your packages are outdated type pip list dash dash outdated and this might take a second here are four packages that are outdated on my computer babel pi game pi tz and setup tools if you need to upgrade one of your packages type pip install the name of the package let's say that i would like to update pygame then dash dash upgrade i just realized that in my notes i'm missing updated package so i just added that here now you can see that pie game has successfully updated and let's just check to see if it has by using pip list outdated pip list dash dash outdated and pi game is no longer in here so it is up to date and if you would like to install a package type hip install and the name of the package you would like to download let's say i would like to download pandas pip install the name of the package in this case pandas two valley boring minutes later and it's done so i should now have pandas installed and let me check pip list and here it is i have successfully downloaded the package of pandas so those are a few commands for pip and if you're interested in downloading more packages head to python's package index on second thought i should probably show you all where that is python's package index is located at pipi.org and you can do a search for all sorts of different projects and packages so everybody that is pip4 python i will post my notes in the comments section down below and well yeah that's how to use pip for python hey what's going on everybody it's bro hope you're doing well and in this video i'm going to show you all how we can convert a python file to an executable so sit back relax and enjoy the show here's a quick disclaimer before we begin windows defender and other anti-virus programs may prevent your executable from running but if you head to the settings section of your anti-virus you can disable that so that your python file can run also please be sure that pip and pi installer are both installed and up to date i have a separate video on that if you're interested now the program that i'm going to be converting to an executable has a gui portion to it i created a clock program in a previous video so i'm going to turn this clock program into an executable now i recommend creating a new folder on your desktop just because this process is normally somewhat messy so we'll create a folder to contain it all now copy any relevant python files and or images and paste them to within this folder if you have an image that you would like to set as an icon for your executable i recommend moving that to the same folder as well our next step is to open command prompt and we need to change the directory of command prompt so that it's pointing to that folder that contains our python file so on your python file right click on it go to properties and copy this location and in command prompt to change directory type cd space and then paste that location now here's the cheat code to convert a python file to an executable make sure that pi installer and pip are installed and both up to date so type pi installer dash capital f to make all of this one file if you need the terminal window in your program then omit this next part since i'm running a gui application i do not need that terminal window so to remove that window type dash w if you have an icon that you want to set type dash i and the name of your icon however it should be an ico file so if you have some other image that you would like to convert to an ico file here's how if you need to convert an image to an ico file you can just google convert to ico but one website that i commonly use is icoconvert.com just pick a file to upload so choose file i'm going to convert this png file of an alarm clock upload it there is a bunch of different settings you can use convert ico and then download my icon and once your ico file is downloaded i will drag and drop it to my folder and i will rename this let's rename this as icon dot ico and here's that cheat code one more time pi installer dash f dash w if you do not need the terminal window dash i if you would like to add an icon the name of your icon it should be an ico file followed by the name of the python file and mine is named clock.p.y then hit enter alright looks like building our executable has completed successfully so open that folder back up your executable is located within this dist folder i would recommend just dragging and dropping it to your desktop and we can get rid of this old folder but close out a command prompt and by clicking on this executable this executable will now run my python program well everyone that is how to convert a python file to an exe file i will post my notes to the comment section down below and well yeah that's how to convert a python file to an executable what's going on everybody it's you bro hope you're doing well and in this video i'm going to show you all how we can create a basic calculator using python so sit back relax and enjoy the show let's create a calculator after importing tkinter we'll need to define three separate functions our first function will be named button press and there is one parameter which we will call num we're not going to fill this in quite yet we'll get back to it later we'll use pass as a placeholder we'll also need an equals function to calculate our expression and a function to clear our calculator okay that's it for our three functions let's create a window window equals tk and at the end of our program we'll write window.mainloop let's set a title window dot title calculator programs good but make sure you spell title right and let's set a geometry of 500 500 should be decent now we're going to create a string named equation text equals a set of quotes this will effectively be empty for the time being and we'll need to create a string var and i will call this equation label equals string var let's create a label label equals label we're adding our label to our window i will set our text variable equal to our equation label you can pick a font if you wish i'll set the background color equal to white a width of 24 and a height of two and we need to finish this by using label dot pack and we should have a blank label within our calculator this will display our numbers that we're entering in or our expression okay this is the tedious part we have to create all of the buttons and i think we should place these all within a frame frame equals frame we're adding our frame to our window frame dot pack now let's create button one we'll do some copying and pasting later so it's not as tedious so button one equals button we're adding our button to our frame i'll set the text equal to 1 the height equal to 4 and the width equal to 9 and a font size of 35 okay we'll need a command command equals i'll write a lambda function here lambda we will call button press i think i'm going to put this on the next line just so it's easier to read button press and we will pass in the number one and we need to add our button to our frame button one dot grid and i'm going to set a row equal to zero and a column equal to zero and let's just test it okay let's add the other buttons i'm going to copy and paste everything that we have for button one and change button one to button two set the text equal to two pass into to button press and for the row and column i'm going to set the column equal to one but keep row the same okay button three it's gonna be the same process really so text equals three button press three row zero column two and button four text equals four button press four column actually let's set this to row one column zero and i need to change that too okay let's just double check this okay button five so button five text equals five button press five and let's set column equal to one okay number six i told you all this is going to be tedious okay so row one column two button seven okay so row two column two actually let's change that to column zero much better okay button eight eight eight eight eight row two column one number nine row two column two and lastly zero so button zero text equals zero button press pass in zero and this will be row three column zero okay not too bad now let's fill in some of the symbols so we need plus i'm just going to rename this as plus the text will equal the plus sign put that within quotes and button press will be plus oh and we should probably put this in a row and column so let's say row 0 column three so it should be on the right hand side here okay we need minus let's change plus to minus and place this at row one column three we need multiply that is an asterisk row two column three and divide that is a forward slash row three column three i promise we're near the end of creating these buttons we'll need an equal sign let's say equal equal text is the equal sign and our command is going to be equals the function and this will be row 3 column 2. we need a decimal let's change the text to a decimal row three column one okay and lastly we just need a clear button let's put this at the bottom so clear clear let's set the text equal to the word clear and the command will be our clear function and i think i'm going to pack this at the end but let's change frame to window okay let's check out all these buttons okay not too bad i think i'm going to change the width on our clear button so it's a little bit wider let's change the width to 12. that's a little bit better okay let's fill in some of these functions let's start with button press we're going to state global equation text then our equation text is equal to equation text plus we're converting whatever number or symbol that we receive to a string and our equation label which is a string var will be set to our equation text and let's test this so we can type in any combination of numbers or symbols okay let's work on our equals function next so let's say global equation text total equals eval now eval will parse the expression that we pass in equation text and our equation label will be set to whatever our total is and if we want to reuse our total let's set our equation text equal to total 2 plus 2 equals four minus three equals one times five equals five divided by two equals two point five now what if we divide by zero well we'll run into that ugly zero division error so let's write our code within a try and accept block so i'm going to indent some of this and let's write try all of this code and we will catch a zero division error exception so accept zero division error and i will set our equation label set let's say arithmetic error equation text equals a set of quotes okay so we should be able to catch this exception now five divided by zero equals arithmetic error now what if we have a syntax here like we type in just a bunch of symbols and hit equals we'll probably want to catch the syntax error as well so let's write an additional accept block before zero division error or after i guess it doesn't matter accept syntax error let's change arithmetic to syntax and we can keep equation text the same so now our program won't crash if we type in a bunch of symbols syntax error now let's work on the clear button so that is within the clear function so we will set global equation text equation label dot set to a set of quotes to effectively clear it and our equation text equal to a set of quotes as well and that should be it for this program let's run this one last time let's say 3.14 times 2.1 equals 6.594 divided by 2.1 equals 3.14 minus one i'm just making up numbers here plus ten equals twelve point one four and let's clear this and start again one plus two plus three plus four equals ten i think that's good enough all right everybody so that's how to create a basic calculator in python i will post all of my code in the comments section down below if you would like a copy for yourself but yeah that's how to create a basic calculator using python hey what's going on everybody it's your bro hope you're doing well and in this video i'm going to explain how we can build a basic text editor program in python so sit back relax and enjoy the show okay people let's create a text editor here's all the different imports that you'll need and we'll begin by defining all of the different functions that we'll need so let's say we have a change color function to change the color of our font and for all of these functions i'm going to write pass as a placeholder so we have change font and this function will accept a varying amount of arguments so we'll use that args keyword we will need to open a file new file open file save file cut copy paste yeah there's a lot of functions here about this is for an about section and lastly quit so how many do we have one two three four five six seven eight nine ten ten functions let's create the main window that we're gonna work with window equals tk and at the very end window.main loop okay so let's create a title for this window window title notepad program i guess or maybe text editor program would be more appropriate text editor program okay and we will need a file to work with and i'll declare that now file equals none we'll need a window width and height window with equals 500 is good and a height okay so let's attempt to center this window because right now it just appears to the side so our next step is to get the screen width equals window dot w info screen width and i'll copy this for screen height okay so we need to figure out how much we're going to move our window on the x and y axis so let's say x equals screen width divided by 2 minus window width divided by two and we're going to cast all of this to an end so add an inch cast around this let's copy this do the same thing for y except this will be screen height and window height okay let's set the geometry for the window window geometry i'm going to use a string format method so let's say these will be placeholders for our values so we have window width for the first value window height x and y so this should be near the middle cool we're going to create a string var variable to hold the font name font name equals string var and pass in your window and you can set this to what do you want your default font to be so let's say font name dot set and then pick a font i'll use ariel i think let's create a font size string bar as well we're going to add this to the window and we can set a default size perhaps 25. okay let's create a text area text area equals text we're adding this to the window i'm going to set a font equal to font name dot get the name of the font that we want to use will be the font that we set within our font name string var so now we'll use a size of font size dot get font size dot get okay now we need a scroll bar scroll bar equals scroll bar writing this to our text area so pass that in and i'm going to configure my window using grid row configure this will allow our text area to expand but we're going to set a weight equal to 1 so that it doesn't back expand and then we need column configure okay and text area dot grid i'm going to use the sticky keyword and this will stick north plus east plus south plus west so my text area should take most of the window this is some sample text hooray so it goes down to the next line once it runs out of room on one line unless you resize the window which is exactly what we wanted let's create a scroll bar while we already created it we just have to add a few details to it so that will be near the bottom and why don't we say scroll bar dot pack side equals right fill equals y and then we just have to configure our text area with the scroll bar so text area dot config y scroll command equals scroll bar dot set so that should work but let's test it to be sure okay i'm just going to type a bunch of f's okay look at that our scroll bar works cool okay let's head to this portion and we'll create a bunch of buttons well a button an option menu and a spin box for the font color the size and the font style so i'm going to place all of these different widgets within a frame frame equals frame add it to the window and then i'm going to use frame dot grid okay let's create a color button to change the fonts color color button equals button i'll add my button to my frame i'll set the text of the button equal to color and i will associate a command of change color which we have already defined at the top where is it at the top here change color and then actually that's it for this portion so then we need to add this button color button dot grid i'll set the row equal to zero and the column equal to zero so let's be sure that this appears make sure you spell grid right okay and we have a color button but this button doesn't do anything so let's head to the change color function within the change color function we're going to say color equals color chooser dot ask color and you can set a title to pick a color or else you don't technically need a title and then text area dot config oh i should probably print this color so let me do that um i'm just gonna explain something here so this color is going to be i believe a tuple so let's print it so let's say that i would like white okay so we have a tuple we just need one of these values not both of them so i'm going to say text area dot config foreground equals our color but we do not want to assign a tuple to our color we just need one of these values so let's say i would like this hex value so i'm going to say at index 1 and let's try it color perhaps i would like my text pink for some reason so we're going with pink this is some text i suppose and we can change this back too by using this color button now i would like blue and we have blue text okay so that is the change color function i'm going to minimize this because we do not need it anymore okay we're going to change the font next so head to the portion of our code right after the color button and we'll create an option menu to list all of the different fonts available to us so let's say font box equals option menu we're adding this to our frame we need to set a variable a string var so that will be our font name that we declared up here now here's a trick to add all of the fonts as options to our option menu we can use the unpacking operator which is an asterisk followed by font dot families and then call this function so this will return all of the different fonts available to us and we just need to set a command and when we use our option menu we'll call change font and we need to add our font box to our grid row equals zero and column equals one so this should be on the right hand side of our color button yeah it's going to look something like that and you can see the default is arial that we set and we can change it to something else like comic sans or whatever uh however it's not going to change it quite yet so that'll be the change font function before we fill in the change font function there's another widget that's going to share the same command of change font so we should create that next so our next widget is a spin box which i will name sizebox this will be in charge of increasing or decreasing the font so size box equals spin box we're adding the spin box to our frame and we'll set a range so from underscore you have to add that underscore it's kind of weird this is the range of our spin box for the font size from 1 to let's say 100 the text variable will be font size and our command equals change font so when we use our spin box and call this command of change font it's going to pass in our font size as an argument whereas with option menu it doesn't pass any arguments that's why with our change font function we're accepting a varying amount of arguments because one's going to pass in an argument and the other isn't and we just need to add our spin box so that would be size box dot grid row equals zero and column equals two so we should have a spin box right on the bottom and it's set to 25 that was our default for our font size string var which we set as the text variable okay so we can fill in this function of change font now which will apply both to our option menu and our spin box so that is all the way at the top within the change font function we're going to take our text area dot config set the font equal to font name dot get and the size will be size box dot get and that's it for this function i'll minimize it for now and let's test it this is some sample text hey how you doing good looking okay so let's change the font uh let's pick comic sans or whatever you want and we can increase or decrease the size and we can change the color how about red this time all right nice now let's add a menu bar at the top so we can save this file or open a file or create a new file and some other stuff on second thought i'm going to move these two last lines of code to this section here where we create our scroll bar just so that it's more organized okay so at the bottom let's create various drop-down menus so we'll need a menu bar to begin with so let's say menu bar equals menu we're adding this to our window make sure that's capital by the way and window dot config menu equals menu bar so we'll create a file menu edit menu and a help menu so let's begin with the file menu to add to the menu bar file menu equals menu we're adding this to our menu bar and set a tear off equal to zero we'll need a cascade for it to actually be a drop down menu so that will be menu bar dot add cascade label equals file comma menu equals file menu let's see if anything appears yet yep so we have a file menu but there's nothing to drop down yet so we need some options well commands technically file menu dot add command label equals new and the command will equal our new file function actually i'll put these together okay so let's copy this and paste it we have open the command will be open file we have save the command will be save file and i'll add a separator file menu dot add separator and lastly we will have exit command quit okay let me show you what this looks like so here's our drop down menu that separator is this bold line going across so if i was to remove this then we wouldn't have that bolt line you can keep it in or get rid of it do whatever you want and this is the tear off so i'm going to remove the tear off and you get this like tear off line at the top i guess it's the default i usually don't like it so i set tear off equal to zero so that is our file menu let's work on a edit menu edit menu equals menu menu bar make sure that's capital two tare off equals zero we'll need a cascade menu bar dot add cascade label equals edit menu equals edit menu edit menu dot add command label equals cut to cut some text command equals copy actually that's cut my bad okay next is copy so let's copy this and paste it cut copy we have paste command paste all right let's take a look oh make sure you spell label right okay there we go okay so we can cut copy and paste and lastly we should have a help menu help menu equals menu menu bar tear off equals zero i think i'll copy this for my cascade so menu bar dot add cascade help menu equals help menu what we'll be doing for a command is that we'll be creating an about section that will bring up a pop-up window if you need to display any like help information or anything uh so let's say about and the command will be about okay let's take a look so we have help and we'll have an about section that will tell you more about this program but we need to work on some of these functions let's head to the quit function this one's fairly easy this is found within the file menu window dot destroy that will close out of the window so go to file then exit to exit the program we don't need it anymore so let's minimize this okay let's go to the about function let's bring up a message box show info this first argument is the title so let's say about this program and the text will be whatever you want to tell the user about this program this is a program written by you okay so we should have a pop-up window when you go to help then about about this program this is a program written by you the next function is the paste function so we can paste some text text area dot event generate and the event is going to be within quotes and double angle brackets paste let's copy this and change paste to copy and then cut okay so we should be able to cut copy and paste hey how's it hanging okay let's highlight this edit copy let's move down to the next line and paste and we should be able to cut as well edit cut nice head to the new file function and we'll set the title of our window to maybe untitled until we save something so untitled and i need to delete any text within our text area text area dot delete and we need to set a range so this has to be a floating point number the first character until the end let's try it so i'll write some sample text and we are going to go to file new that changed the title and it deleted our text so that is the new file function let's work on open file we are now within the open file function and we'll say file equals ask open file name so we have a default extension if you would like one default i think i spelled that wrong extension equals let's say a txt file comma what are the accepted file types i'll set this equal to all files comma and then we need asterisk dot asterisk for all file types as well as text documents so these are what is accepted when we look for a file so we have either all files or all text documents text documents comma asterisk dot txt okay so then let's try some code we'll set our window title equal to os dot path dot base name of our file so that we will change the title of the window to match whatever the file is that we opened then let's take our text area delete what's currently here from one until the end take our file use the open function open our file and read it so pass in our text area dot insert beginning at index of 1.0 file dot read that you can catch any exceptions to i'll just write accept exception but it's better to name specific exceptions i'll just print couldn't read file and we should close our file at the end within a finally block finally file dot close we'll need a sample file to read so i'm going to create a new file on my desktop i'll call this test.txt and let's write something whoa you can actually read this awesome okay let's save close out of it add run our program file open test.txt open whoa you can actually read this awesome nice so we know that the open function is working if we need to create a new file just go to file new and that will delete our old text so lastly we have save file underneath the save file function file equals file dialog dot ask save as file name so this will be the default name for the file but you can change that initial file equals let's say untitled dot you txt set a default extension default extension equals let's say txt file types equals all files comma then asterisk dot asterisk for all file types and any text documents text documents asterisk dot txt okay if file is none that's if they close out of our file dialog we'll just return else so we'll set the window title first window title os dot path dot base name file file equals open open our file and write file dot right take our text area and get the text from index one through the end catch any exceptions it's better to name them instead of just doing a general accept exception but i'm just going to print couldn't save file and finally close our file file dot close all right so let's test it so i'm going to change the font i wonder if impact is in here yes it is i'll change the font size maybe 30 and i'll pick a color how about this swamp green color okay so write something perhaps some lyrics to a song you like i should probably test copying and pasting edit copy edit paste nice all right let's actually try and save this now i'll go to file save the default file name is untitled because we set it to that i'll say all star lyrics and save now i should be able to open this so i'm going to go to my desktop here's that text file i'm going to open it and here are the lyrics that i wrote within my text editor and let's try and read this so let's go to file open find your text document open and would you look at that my lyrics are still here however this program doesn't save the font so i thought of a fun last minute project that we can do we can actually use our text editor to write a python file much like what we do with pycharm so let's write a program using our text editor program it'll be just a simple program let's print hello world and ask for some user input let's say name equals input what's your name and we will print hello plus our name variable and you can change the font and everything too if you want okay so let's save this file save i'll save this to my desktop but make sure you save it as a py file a python file i'll name this as hello dot py and save now to run a file using command prompt we need to find the directory that contains our python file mine is hello.py and it's located on my desktop so i need the location right click go to properties you can copy the location then within command prompt or terminal you can change directory by typing cd space and then paste your new directory the new location enter then to run a python program type python space and then the name of the program the python file mine is hello dot py hit enter hello world what is your name bro hello bro i just thought that would be a fun last minute project that we can do you don't even technically need an ide to write a python program screw you pycharm well everyone that is a basic text editor program i will post the code for this program in the comment section down below and well yeah that's a basic text editor program using python all right ladies and gentlemen let's create a game of tic-tac-toe to begin we'll need to import tkinter as well as random and let's begin by defining all of the different functions that we'll need let's define a function named next turn for the time being we'll just write pass we'll fill this in later on we'll need a function named check winner a function named empty spaces to check if there are any empty spaces left and lastly a function named new game that will launch a new game for us okay we have our four functions now let's create a window let's create a window window equals tk and at the end of our program we need to use window dot main loop and when we run this we should have just a small basic window let's set the title window dot title let's set this to tick tack toe we'll need a list of players players equals x comma o and with the way that we're writing this program we can swap these symbols with a different character for example we could say dollar sign is playing against the at symbol too but i'll demonstrate that later let's keep it as x and o for now now we need to select a random player to begin player equals random dot choice and pass in our list of players now we'll need nine buttons i'm going to create a 2d list of buttons named buttons and this will be the first row this will be the second row for the time being i'm just going to initialize these with 0 for everything and put these all within a list so we have a 2d list named buttons and to better visualize this i'm going to place each row on a new line so that's what our board is going to look like we have a 2d list named buttons we'll need a label to display whose turn it is label equals label i'll set the text equal to player plus the word turn and i'll set the font to font equals pick whatever font that you want and i am going to pack this label label dot pack and set the side equal to top and let's run this just to test it okay looks like it's x's turn let's try it again oh stern okay that's fine for now let's create a reset button reset underscore button equals button i'll set the text equal to restart it's going to be a restart button or reset button pick a font maybe i'll set the size to 20 and we'll need a command command equals new game when we click on this button it's going to call this new game function for us and we need to pack this button reset button dot pack and i will set the side equal to top okay let's see if that appears alright so we have our turn order a label that will display whose turn it is as well as our reset button now we'll need to create all of the buttons to add to our 2d list named buttons but i'm going to place these all within a frame frame equals frame we're adding our frame to our window and i'm going to pack this frame frame dot pack now we'll take our 2d list of buttons and add a button to each spot and i think the best way to do this would be to use nested for loops we'll have an outer for loop in charge of the rows four row in range three remember we only have three rows and three columns the inner for loop will be in charge of the columns four column and range three and inside the inner for loop we're going to create a new button we'll say buttons at index row and column we have two indexes because we have a 2d list so buttons at row whatever column whatever depending on what iteration we are within our for loops we'll create a new button and we'll set the text oh first add this to the frame almost forgot about that we're adding our buttons to our frame and adding the frame to the window now we'll set the text equal to a blank set of quotes because we don't want any text we'll set the font i'll just copy what we have here for label for a width let's say five and a height let's say two i'm going to hit enter just to move down to the next line because we still have a few more things to fill in okay we'll need a command command equals and i'm going to set this equal to a lambda function so we need some arguments actually i think i'll pass in some keyword arguments row equals row and column equals column then our expression is next turn and we will pass in row and column now we also need to add our buttons to our frame buttons at index of row and column we'll use the grid function for this grid row equals and column equals column and it's always a good idea to test your program after making any major changes so we should have our label our reset button and our grid of buttons now that the main body of our program is complete let's head to the next turn function and remember that we're passing in row and column as arguments so we need to set up those parameters within the next turn function row and column and the first line within here we would like access to our player so let's say global player so that we have access to it and we're first going to check to see if the button that we click on is empty so buttons at index of row and index of column to access the text of a button just add a third index operator and type in text if the text of our button that we click is equal to a set of quotes that means it's empty and when we call check winner winner winner chicken dinner and it's false there is no winner then we will fill in that button with our player our player's character whatever it is x or o or whatever we decide so within here let's check to see if player is equal to players at index zero that is our first player and remember that we created a list of players and we're planning on swapping these later we could say like if player is equal to x but that would make our program less flexible if we want to pick like a different character instead of an x so if player is equal to player at index zero whatever symbol is there then we are going to take buttons at index of row index of column take our text and set it equal to our player and we should check to see if there's a winner after filling in this button if check winner and we still need to fill in this function returns false then we will switch players player equals players at index of one and label dot config text equals players at index 1 plus the word turn so what we did here is that we're checking to see if after placing our text of our player on that button that we click if there is no winner then we're going to swap players player equals our next player and we're configuring our label so that it displays the next player's turn players at index 1 turn now what if there is a winner let's say else if check winner is true then we will take our label dot config and set the text equal to players at index 0 plus the word wins now let's add another else if statement else if there's a tie let's say check winner is equal to the word tie because we are already using false and true then let's change our label and i'm just going to copy this text equals the word tie okay so let's create an else block so that goes right here so if it's not player one's turn player at index zero then it's our other player's turn player at index of one so oh then so we just need to mostly just copy this text and change a few things around so i'm going to copy all this and within here let's set player equals players at index zero then players at index zero's turn players at index one wins and that is it now our next turn function is now complete let's head down to the check winner function and we need to check all of the different win conditions and return it true if somebody won false if there is yet no winner and the word tie if it's a tie so let's check all of the horizontal win conditions so we can do this using a for loop for row in range three we need to check the text of each button in each row if buttons at index of row and column index of 0 we'll use the index operator to check the text is equal to the next button in our row so i will copy this and change zero to one check to see if that is equal to buttons at index of row index of two and i'm going to check to see if this is all not equal let me move this a little bit to a space so if that is the case that means somebody won so if all of these buttons are the same and they are not equal to an empty space that means they're all the same so let's return true that means that somebody won no we need to check the vertical win conditions if anybody has the same character all the way down a single column this next for loop is going to be four column in range three for the first button this will be button at index of zero and column then one and column let me just paste that and two and column now we need to check the diagonal win conditions so if buttons at index 0 0 that's the top left corner if the text of that button is equal to buttons at indexes of one one is equal to the indexes of button two two and if all of this does not equal an empty space then return true so there is a winner and we have one last win condition to check that is the other diagonal win condition so we just need to change some of these indexes around so we have zero two one one and two zero i'm going to change this statement to an else if statement no we need to check to see if there's any spaces remaining else if we will call the empty spaces function which we have yet to fill in if this returns false then we will return the word tie and lastly else else there is no winner and no tie so we will return false and that is it for the check winner function let's test this so this doesn't account for a tie quite yet but we can fill in some of these spaces looks like x wins and we can no longer fill in buttons and we cannot start a new game quite yet either within the empty spaces function let's create a local variable named spaces and set this equal to nine whenever we call this function four row in range three and we'll create a nested for loop for column in range three we will check the text of each button if buttons at indexes of row and column and we will check the text to see if it's not equal to an empty space if that is the case spaces minus equals one then we'll write an if statement if spaces as in spaces remaining is equal to zero that means we will return false and there are no spaces left else we will return true okay let's test it so this time i'm trying to get a tie yep looks like it's a tie this next part's optional but i would like to change the color of each button for the winning combination so within our check winner function underneath the first win condition i'm going to take buttons at index of row and index of zero use the config method and set the background color equal to let's say green and i'm going to repeat this process for the other buttons within this win condition so that is row zero row one and row two i'll copy all of this paste it and switch some of these around so these should all be matching so zero and column one and column and two in column okay so we have zero zero one one and two two and one more zero two one one and two zero now when we have a winning combination the color of the buttons involved in that combination are going to change to green now if there is a tie let's change all of the buttons to let's say yellow so i'm going to write nested for loops for this four row in range three for column in range three take our buttons at row and column and change the background color to yellow or some other color of your choosing so if there's a tie they should all be yellow i'm trying not to win here it's actually more complex than what i thought yep it looks like it's all a tie and the last thing that we need to do is to fill in the new game function so that we can begin a new game so let's say global player we would like access to our player from inside this function and set player equal to a new random choice random dot choice and pass in our list of players and we will change our label label dot config and set the text equal to player plus the word turn and we also need to reset all of our buttons for row in range three for column in range three buttons at index of row and index of column dot config text equals a set of quotes so it's empty and we'll change the background color factors previously so the default color for buttons is actually hexadecimal f 0 f 0 f 0 so this function will begin a new game for us and let's test it to be sure i'm going to start a new game reset reset i'll actually try and win this time and reset okay so it looks like the new game function is working now another thing that you can do too is that you can change the players around let's say we would like to play as dollar sign and at sign so this program is flexible enough so that you can change the icons of the players all right everybody so that's a basic game of tic-tac-toe for python if you would like a copy of this code i will post all of this to the comments section down below but yeah that's how to code a basic game of tic-tac-toe for python hey what's going on everybody it's your bro hope you're doing well and in this video we're going to create a game of snake using python so sit back relax and enjoy the show first thing we should do is import from tkinter as well as the random module and let's define all of the different classes and functions that we'll need so let's create a class for our snake object as well as our food object so for the time being i'm just going to write pass for my classes we'll fill these in later so we have class snake and class food and let's define all of the different functions that we'll need so let's say we have a function named next turn change direction check collisions and lastly game over okay for change direction i'm going to have one parameter a new direction now when i create a game i like to place a bunch of constants at the top of my game constants are variables that you do not want to change later they're kind of like the settings however in python there are no constants compared to other programming languages so we're just going to create a bunch of variables that will behave like them so constants are values we do not want to change and they're kind of like the game settings and i placed them at the top for convenience and the naming convention for a constant is that all the letters are uppercase so these will be settings like the game width the speed etc so let's say the width of our game will be 700 but feel free to take the liberty to pick whatever size you want so we have game width game height i'll set this to 700 as well so it's a square let's say we have a speed the speed of the snake how often will our canvas update so let's say 50 but the lower the number the faster the game and a space size how large are the items in our game like the food and body parts of the snake so i'm going to pick 50 but you can change this and body parts how many body parts does our snake have when we begin a game let's say three how about a snake color you can pick a color name you can use rgb values or you can use a hexadecimal value so i'm going to pick green 0 0 ff00 but you can pick any color you want how about food color equals red and that is ff000 and what about a background color for the canvas background color i'll pick black so that is six zeros feel free to mess with some of these colors too so we have a green snake our food is going to be red and our background is going to be black so that is all of the constants for our game but you can feel free to adjust them if you like let's head down to the bottom and make our window so we have window equals tk and at the very end we should have window dot main loop let's set a title for this window window dot title snack game okay fine i'll spell it right snake game and if you do not want your window to be resizable you can use resizable and then you have to pass in false twice it's kind of strange but it's how it is okay we should have a small window and we cannot resize this even if we tried okay let's create a score label but we probably need a score first so let's say score equals zero and an initial direction direction equals let's say down now let's create a score label so let's say label equals label we're adding our label to our window let's set the text equal to score colon then i'm going to use the format method and we will pass in our score whatever it is and i'll set a font pick whatever font you prefer and 40 is a decent size and then i'm going to pack this label let's test it okay we're getting somewhere we'll need to create a canvas canvas equals canvas we're adding it to our window i'm going to set the background color equal to our background constant i'm going to set our height equal to the game height and the width equal to the game width that we set and we need to pack this canvas dot pack and we should have a game board i'm going to try and center this window when it appears so we can do that using a few lines of code the first thing we'll do is update our window so that it renders and then we need to find some dimensions so let's say the window width equals window dot w info width and window height equals window dot w info height we'll need our screen width equals window dot screen width and screen height equals window dot w info screen height where is it there it is okay then we need to see how much we're going to adjust the position of our window so let's say x equals screen width divided by 2 minus window width divided by two and do the same thing for y except this will be screen height and window height and that will be why okay then we need to set the geometry window dot geometry we're going to use an f string so let's set the window width times window height and then add plus x plus y so when we pass in x and y these cannot be floats they have to be whole integers so let's add a cast around x and y okay now this should be fairly close to the center yeah that's not too bad now when we begin a new game we should create a snake object as well as a food object snake equals snake and called the snake constructor and food equals food okay let's fill in our food class first because i think that'll be easier than our snake class so let's head to the food class now let's create an init method so def init this will construct a food object for us and we need to place our food object randomly so for the x coordinate let's say x equals random dot rand int and we need a range the range is going to be zero comma now with our game board i view it like a chess board there's a given amount of spaces so 700 divided by our space size is 14 possible spots on the x-axis and then 14 possible spots on the y-axis so i need to pick one of these spots randomly so let's say game width divided by our space size so we'll get a random number between 0 and 14 however this should be exclusive so let's say -1 and for good measure i'm just going to add a set of parentheses around this okay and then we'll convert this to pixels so let's multiply all of this by our space size the size of each item in the game and we'll do the same thing for y but change game width to height okay we should be good all right now let's set the coordinates let's say self dot coordinates equals a list of x and y and that's it but make sure you spell coordinates right now we need to draw our food object on our canvas canvas dot create oval you can pick a square two if you like we need a starting corner that will be where x and y is and an ending coordinator so that will be x and y plus our space size the size of an object in that game so x plus space size y plus space size and you can set a fill color too fill will be our food color that we declared and i recommend adding a tag as well that'll make it easy to delete this object so tag will equal the string food now let's just test this so we should have a random circle or a square if you picked a square appear someplace at some spot on my game board cool seems like it's working let's work on the snake class next our snake class we'll need a constructor and we will set a body size equal to our body parts we'll need a list of coordinates fill this in later and a list of square graphics so that will be a list okay so we need to create a list of coordinates we can use a for loop for that so let's say for i in range zero through body parts we will take self dot coordinates and append a new list and the coordinates for each body part at the start of the game will be 0 0 so that our snake will appear in the top left corner now we'll need to create some squares okay so for x y in self dot coordinates and remember that we have a list of lists so that's why we're using x y in self coordinates we'll create a square equals canvas dot create rectangle so we need a starting corner that will be x and y then x plus our space size the size of each object in the game let me use the constant though space size y plus space size and let's set a fill color equal to our snake color all right and let's set a tag for convenience tag equals a string of snake okay so we have a list of squares and we can append each square into our list self dot squares dot append and pass in whatever square that you create so we have a snake that has a body size a list of coordinates and a list of square graphics now after testing this we should have the head of our snake in the top left corner and now we just need the snake to move in a given direction every turn so the initial direction is down but we'll be able to change that later so let's head to the next turn function and there's actually two things we'll need as parameters that i forgot to fill in snake as well as food and we will call this function when we begin our game so let's unpack the head of the snake so that's x comma y equals snake dot coordinates at index of zero so that's the head of the snake the coordinates will be stored in x and y so let's check to see if our direction our initial direction equals up and we'll need some else if statements we'll fill this in just a moment else if our direction equals down then left and then right okay if our direction is up then let's take our y coordinate for the head of our snake minus equals our space size so that we move one space up and then down is plus equals space size left is x minus equals space size and lastly right is x plus equals space size okay then we need to call the next turn function again for the next turn so we can use window dot after we need the time so let's say our game speed we're going to call the next turn function and we need to pass in our arguments of snake and food snake food oh and make sure you're not actually calling the next turn function inside of the after method you just have to write the function name of next turn without the parentheses okay so let's update the coordinates for the height for the snake and write that before we move on to the next turn so snake dot coordinates and we will insert a new set of coordinates after updating one of them so zero will be the index the head of the snake and we will insert x and y coordinates at this new location now we're going to create a new graphic for the head of the snake square equals canvas dot create rectangle pass in x and y for the starting corner of our rectangle and the ending corner will be x plus our space size y plus our space size then i will add a fill color of snake color and then we need to update our snakes list of squares so that will be snake dot squares and insert at index 0 a new square that we create okay let's test this one last thing that we'll need to get this program to run is that after you create your snake and food object we should call it the next turn function and pass in our snake and food object so we should be able to test this so our snake is going to move but we need to delete the last body part in our snake within the next turn function but before we update to the next turn let's delete the last body part of our snake so delete snake dot coordinates at negative index of one that is the last set of coordinates we will update our canvas canvas dot delete snake dot squares an index of negative one and lastly delete snake the list of squares at index of negative one so it should appear that our snake is moving cool we need some controls for our snake so at the bottom of our program let's bind some keys let's do that here so window dot bind let's find the left arrow key and we will use a lambda the argument is event and we will call the change direction function and pass in the word left okay then we have to do the same thing for the other directions so we have right pass in right up pass in up down pass in down let's head to the change direction function we need to access our direction global direction this is the old direction if our new direction that is passed in is equal to left and if our old direction this direction does not equal right because we do not want to go backwards and do a 180 degree turn then we will set our direction equal to our new direction and we just need to repeat this for the other directions for new direction and i'm going to change this to else if else if new direction is right and our direction is not already left then we have up if our direction is not down and down if our direction is not up okay so we should be able to change the direction of our snake sweet okay we need to eat that pesky apple next so let's work on that there's nothing else that we need to change within the change direction function so i'm going to minimize this function and head to the next turn function we'll place an if statement here if x remember that we unpacked the coordinates for the head of the snake if x the x coordinate for the head of the snake is equal to our food objects coordinates at index of zero that's the x-coordinate for our food object and y is equal to food coordinates at index of one that means they're overlapping let's take our score and increment it by one and change our label label.config the text will equal score and then i'm going to use the format method and pass in my new score let's delete our food object and we gave our food object a tag so we can just use the name of the tag to delete it and create a new food object then i'm going to write this part of our program within an else statement we will only delete the last body part of our snake if we did not eat a food object okay let's test it again so i have three body parts now i have four five six seven eight nine ten you can see that the score is going up too okay let's work on collisions next because i should not be able to go off screen like this there's one thing that we're going to change so let's add an if statement that will check collisions this will return true or false if we detect a collision and pass in our snake object if there is a collision we'll call the game over function else we will update to the next turn okay let's fill in the check collisions function and we no longer need our function of next turn actually we don't need these classes either so i'll minimize them okay check collisions so it looks like we will need a parameter of snake so be sure to set that let's unpack the head of the snake x y equals snake dot coordinates at index of zero and let's check to see if we cross the left or right border of the game if x is less than zero or x is greater than or equal to our game width then return true i think for testing purposes i'm going to print something to the console window game over let's test it okay i'm going to go over to the right border game over and our game stopped let's go over the left game over cool so we know that it's working okay let's do the same thing for y we can use else if here if y is less than zero or y is greater than or equal to our game height let's print game over and return true and we should probably test it okay i'm going up game over and let's go down game over so what if our snake touches its tail or another body part so let's say four i actually i isn't too descriptive let's say for every body part in snake dot coordinates we're going to set this to everything after the head of the snake we're going to check to see if any of the coordinates are matching if x is equal to body part at index 0 and y is equal to body part at index 1 then return true and i'll print game over to test it print game over otherwise we can return false there are no collisions i think i'm going to change the size of the snake to 10. okay let's run into each other cool game over and the last thing that we need to do is to fill in the game over function because it looks like everything else is fine so head to the game over function take your canvas and delete all and we'll create some game over text canvas create text i would like this in the center of my canvas i'll take canvas w info width divided by two comma canvas w info height divided by two i'm going to put some of this on the next line for readability i'll set a font pick whatever font that you want we'll need some text text equals game over pick a color red's decent i'll add a tag too for convenience game over and that should be it for the game over function i'm going to change the body parts of the snake back to what it was originally and we should probably test that game over screen all right it appeared okay so let's change some of these settings around you can create a larger game board let's say 1000 by 700 that still works you can slow down the speed or speed it up so 100 will be about half as fast it's going pretty slow now but what if we set it to 20. you can change the space size so everything is a lot smaller now including the food object you can change the body parts what about 20 to begin with that's fairly excessive i'll change that back to three you can change the snake color let's say we would like a blue snake so that is for a hex color four zeros and then two f's you can change the food color so let's say we would like a yellow food object so that would be four f's and then two zeros kind of resembles the python logo that color scheme you can change the background color too so let's say all white that would be six apps i do not like that go back delete delete delete alright well that should be everything let's run this game one last time [Music] [Music] well everybody that is a very basic game of snake for beginners i will post all of this code to the comment section down below but yeah that's a basic game of snake using python hey you yeah i'm talking to you if you learned something new then help me help you in three easy steps by smashing that like button drop a comment down below and subscribe if you'd like to become a fellow bro [Music] you


This course from Harvard University explores the concepts and algorithms at the foundation of modern artificial intelligence, diving into the ideas that give rise to technologies like game-playing engines, handwriting recognition, and machine translation. You'll gain exposure to the theory behind graph search algorithms, classification, optimization, reinforcement learning, and other topics in artificial intelligence and machine learning. Brian Yu teaches this course. Hello, world. This is CS50, and this is an introduction to artificial intelligence with Python with CS50's own Brian Yu. This course picks up where CS50 itself leaves off and explores the concepts and algorithms at the foundation of modern AI. We'll start with a look at how AI can search for solutions to problems, whether those problems are learning how to play a game or trying to find driving directions to a destination. We'll then look at how AI can represent information, both knowledge that our AI is certain about, but also information and events about which our AI might be uncertain, learning how to represent that information, but more importantly, how to use that information to draw inferences and new conclusions as well. We'll explore how AI can solve various types of optimization problems, trying to maximize profits or minimize costs or satisfy some other constraints before turning our attention to the fast-growing field of machine learning, where we won't tell our AI exactly how to solve a problem, but instead, give our AI access to data and experiences so that our AI can learn on its own how to perform these tasks. In particular, we'll look at neural networks, one of the most popular tools in modern machine learning, inspired by the way that human brains learn and reason as well before finally taking a look at the world of natural language processing so that it's not just us humans learning to learn how artificial intelligence is able to speak, but also AI learning how to understand and interpret human language as well. We'll explore these ideas and algorithms, and along the way, give you the opportunity to build your own AI programs to implement all of this and more. This is CS50. All right. Welcome, everyone, to an introduction to artificial intelligence with Python. My name is Brian Yu, and in this class, we'll explore some of the ideas and techniques and algorithms that are at the foundation of artificial intelligence. Now, artificial intelligence covers a wide variety of types of techniques. Anytime you see a computer do something that appears to be intelligent or rational in some way, like recognizing someone's face in a photo, or being able to play a game better than people can, or being able to understand human language when we talk to our phones and they understand what we mean and are able to respond back to us, these are all examples of AI, or artificial intelligence. And in this class, we'll explore some of the ideas that make that AI possible. So we'll begin our conversations with search, the problem of we have an AI, and we would like the AI to be able to search for solutions to some kind of problem, no matter what that problem might be. Whether it's trying to get driving directions from point A to point B, or trying to figure out how to play a game, given a tic-tac-toe game, for example, figuring out what move it ought to make. After that, we'll take a look at knowledge. Ideally, we want our AI to be able to know information, to be able to represent that information, and more importantly, to be able to draw inferences from that information, to be able to use the information it knows and draw additional conclusions. So we'll talk about how AI can be programmed in order to do just that. Then we'll explore the topic of uncertainty, talking about ideas of what happens if a computer isn't sure about a fact, but maybe is only sure with a certain probability. So we'll talk about some of the ideas behind probability, and how computers can begin to deal with uncertain events in order to be a little bit more intelligent in that sense as well. After that, we'll turn our attention to optimization, problems of when the computer is trying to optimize for some sort of goal, especially in a situation where there might be multiple ways that a computer might solve a problem, but we're looking for a better way, or potentially the best way, if that's at all possible. Then we'll take a look at machine learning, or learning more generally, and looking at how, when we have access to data, our computers can be programmed to be quite intelligent by learning from data and learning from experience, being able to perform a task better and better based on greater access to data. So your email, for example, where your email inbox somehow knows which of your emails are good emails and which of your emails are spam. These are all examples of computers being able to learn from past experiences and past data. We'll take a look, too, at how computers are able to draw inspiration from human intelligence, looking at the structure of the human brain, and how neural networks can be a computer analog to that sort of idea, and how, by taking advantage of a certain type of structure of a computer program, we can write neural networks that are able to perform tasks very, very effectively. And then finally, we'll turn our attention to language, not programming languages, but human languages that we speak every day. And taking a look at the challenges that come about as a computer tries to understand natural language, and how it is some of the natural language processing that occurs in modern artificial intelligence can actually work. But today, we'll begin our conversation with search, this problem of trying to figure out what to do when we have some sort of situation that the computer is in, some sort of environment that an agent is in, so to speak, and we would like for that agent to be able to somehow look for a solution to that problem. Now, these problems can come in any number of different types of formats. One example, for instance, might be something like this classic 15 puzzle with the sliding tiles that you might have seen. Where you're trying to slide the tiles in order to make sure that all the numbers line up in order. This is an example of what you might call a search problem. The 15 puzzle begins in an initially mixed up state, and we need some way of finding moves to make in order to return the puzzle to its solved state. But there are similar problems that you can frame in other ways. Trying to find your way through a maze, for example, is another example of a search problem. You begin in one place, you have some goal of where you're trying to get to, and you need to figure out the correct sequence of actions that will take you from that initial state to the goal. And while this is a little bit abstract, any time we talk about maze solving in this class, you can translate it to something a little more real world. Something like driving directions. If you ever wonder how Google Maps is able to figure out what is the best way for you to get from point A to point B, and what turns to make at what time, depending on traffic, for example, it's often some sort of search algorithm. You have an AI that is trying to get from an initial position to some sort of goal by taking some sequence of actions. So we'll start our conversations today by thinking about these types of search problems and what goes in to solving a search problem like this in order for an AI to be able to find a good solution. In order to do so, though, we're going to need to introduce a little bit of terminology, some of which I've already used. But the first term we'll need to think about is an agent. An agent is just some entity that perceives its environment. It somehow is able to perceive the things around it and act on that environment in some way. So in the case of the driving directions, your agent might be some representation of a car that is trying to figure out what actions to take in order to arrive at a destination. In the case of the 15 puzzle with the sliding tiles, the agent might be the AI or the person that is trying to solve that puzzle to try and figure out what tiles to move in order to get to that solution. Next, we introduce the idea of a state. A state is just some configuration of the agent in its environment. So in the 15 puzzle, for example, any state might be any one of these three, for example. A state is just some configuration of the tiles. And each of these states is different and is going to require a slightly different solution. A different sequence of actions will be needed in each one of these in order to get from this initial state to the goal, which is where we're trying to get. So the initial state, then, what is that? The initial state is just the state where the agent begins. It is one such state where we're going to start from. And this is going to be the starting point for our search algorithm, so to speak. We're going to begin with this initial state and then start to reason about it, to think about what actions might we apply to that initial state in order to figure out how to get from the beginning to the end, from the initial position to whatever our goal happens to be. And how do we make our way from that initial position to the goal? Well, ultimately, it's via taking actions. Actions are just choices that we can make in any given state. And in AI, we're always going to try to formalize these ideas a little bit more precisely, such that we could program them a little bit more mathematically, so to speak. So this will be a recurring theme. And we can more precisely define actions as a function. We're going to effectively define a function called actions that takes an input, s, where s is going to be some state that exists inside of our environment. And actions of s is going to take the state as input and return as output the set of all actions that can be executed in that state. And so it's possible that some actions are only valid in certain states and not in other states. And we'll see examples of that soon, too. So in the case of the 15 puzzle, for example, there are generally going to be four possible actions that we can do most of the time. We can slide a tile to the right, slide a tile to the left, slide a tile up, or slide a tile down, for example. And those are going to be the actions that are available to us. So somehow our AI, our program, needs some encoding of the state, which is often going to be in some numerical format, and some encoding of these actions. But it also needs some encoding of the relationship between these things. How do the states and actions relate to one another? And in order to do that, we'll introduce to our AI a transition model, which will be a description of what state we get after we perform some available action in some other state. And again, we can be a little bit more precise about this, define this transition model a little bit more formally, again, as a function. The function is going to be a function called result that this time takes two inputs. Input number one is s, some state. And input number two is a, some action. And the output of this function result is it is going to give us the state that we get after we perform action a in state s. So let's take a look at an example to see more precisely what this actually means. Here is an example of a state, of the 15 puzzle, for example. And here is an example of an action, sliding a tile to the right. What happens if we pass these as inputs to the result function? Again, the result function takes this board, this state, as its first input. And it takes an action as a second input. And of course, here, I'm describing things visually so that you can see visually what the state is and what the action is. In a computer, you might represent one of these actions as just some number that represents the action. Or if you're familiar with enums that allow you to enumerate multiple possibilities, it might be something like that. And this state might just be represented as an array or two-dimensional array of all of these numbers that exist. But here, we're going to show it visually just so you can see it. But when we take this state and this action, pass it into the result function, the output is a new state. The state we get after we take a tile and slide it to the right, and this is the state we get as a result. If we had a different action and a different state, for example, and pass that into the result function, we'd get a different answer altogether. So the result function needs to take care of figuring out how to take a state and take an action and get what results. And this is going to be our transition model that describes how it is that states and actions are related to each other. If we take this transition model and think about it more generally and across the entire problem, we can form what we might call a state space. The set of all of the states we can get from the initial state via any sequence of actions, by taking 0 or 1 or 2 or more actions in addition to that, so we could draw a diagram that looks something like this, where every state is represented here by a game board, and there are arrows that connect every state to every other state we can get to from that state. And the state space is much larger than what you see just here. This is just a sample of what the state space might actually look like. And in general, across many search problems, whether they're this particular 15 puzzle or driving directions or something else, the state space is going to look something like this. We have individual states and arrows that are connecting them. And oftentimes, just for simplicity, we'll simplify our representation of this entire thing as a graph, some sequence of nodes and edges that connect nodes. But you can think of this more abstract representation as the exact same idea. Each of these little circles or nodes is going to represent one of the states inside of our problem. And the arrows here represent the actions that we can take in any particular state, taking us from one particular state to another state, for example. All right. So now we have this idea of nodes that are representing these states, actions that can take us from one state to another, and a transition model that defines what happens after we take a particular action. So the next step we need to figure out is how we know when the AI is done solving the problem. The AI needs some way to know when it gets to the goal that it's found the goal. So the next thing we'll need to encode into our artificial intelligence is a goal test, some way to determine whether a given state is a goal state. In the case of something like driving directions, it might be pretty easy. If you're in a state that corresponds to whatever the user typed in as their intended destination, well, then you know you're in a goal state. In the 15 puzzle, it might be checking the numbers to make sure they're all in ascending order. But the AI needs some way to encode whether or not any state they happen to be in is a goal. And some problems might have one goal, like a maze where you have one initial position and one ending position, and that's the goal. In other more complex problems, you might imagine that there are multiple possible goals. That there are multiple ways to solve a problem, and we might not care which one the computer finds, as long as it does find a particular goal. However, sometimes the computer doesn't just care about finding a goal, but finding a goal well, or one with a low cost. And it's for that reason that the last piece of terminology that we'll use to define these search problems is something called a path cost. You might imagine that in the case of driving directions, it would be pretty annoying if I said I wanted directions from point A to point B, and the route that Google Maps gave me was a long route with lots of detours that were unnecessary that took longer than it should have for me to get to that destination. And it's for that reason that when we're formulating search problems, we'll often give every path some sort of numerical cost, some number telling us how expensive it is to take this particular option, and then tell our AI that instead of just finding a solution, some way of getting from the initial state to the goal, we'd really like to find one that minimizes this path cost. That is, less expensive, or takes less time, or minimizes some other numerical value. We can represent this graphically if we take a look at this graph again, and imagine that each of these arrows, each of these actions that we can take from one state to another state, has some sort of number associated with it. That number being the path cost of this particular action, where some of the costs for any particular action might be more expensive than the cost for some other action, for example. Although this will only happen in some sorts of problems. In other problems, we can simplify the diagram and just assume that the cost of any particular action is the same. And this is probably the case in something like the 15 puzzle, for example, where it doesn't really make a difference whether I'm moving right or moving left. The only thing that matters is the total number of steps that I have to take to get from point A to point B. And each of those steps is of equal cost. We can just assume it's of some constant cost like one. And so this now forms the basis for what we might consider to be a search problem. A search problem has some sort of initial state, some place where we begin, some sort of action that we can take or multiple actions that we can take in any given state. And it has a transition model. Some way of defining what happens when we go from one state and take one action, what state do we end up with as a result. In addition to that, we need some goal test to know whether or not we've reached a goal. And then we need a path cost function that tells us for any particular path, by following some sequence of actions, how expensive is that path. What does its cost in terms of money or time or some other resource that we are trying to minimize our usage of. And the goal ultimately is to find a solution. Where a solution in this case is just some sequence of actions that will take us from the initial state to the goal state. And ideally, we'd like to find not just any solution but the optimal solution, which is a solution that has the lowest path cost among all of the possible solutions. And in some cases, there might be multiple optimal solutions. But an optimal solution just means that there is no way that we could have done better in terms of finding that solution. So now we've defined the problem. And now we need to begin to figure out how it is that we're going to solve this kind of search problem. And in order to do so, you'll probably imagine that our computer is going to need to represent a whole bunch of data about this particular problem. We need to represent data about where we are in the problem. And we might need to be considering multiple different options at once. And oftentimes, when we're trying to package a whole bunch of data related to a state together, we'll do so using a data structure that we're going to call a node. A node is a data structure that is just going to keep track of a variety of different values. And specifically, in the case of a search problem, it's going to keep track of these four values in particular. Every node is going to keep track of a state, the state we're currently on. And every node is also going to keep track of a parent. A parent being the state before us or the node that we used in order to get to this current state. And this is going to be relevant because eventually, once we reach the goal node, once we get to the end, we want to know what sequence of actions we use in order to get to that goal. And the way we'll know that is by looking at these parents to keep track of what led us to the goal and what led us to that state and what led us to the state before that, so on and so forth, backtracking our way to the beginning so that we know the entire sequence of actions we needed in order to get from the beginning to the end. The node is also going to keep track of what action we took in order to get from the parent to the current state. And the node is also going to keep track of a path cost. In other words, it's going to keep track of the number that represents how long it took to get from the initial state to the state that we currently happen to be at. And we'll see why this is relevant as we start to talk about some of the optimizations that we can make in terms of these search problems more generally. So this is the data structure that we're going to use in order to solve the problem. And now let's talk about the approach. How might we actually begin to solve the problem? Well, as you might imagine, what we're going to do is we're going to start at one particular state, and we're just going to explore from there. The intuition is that from a given state, we have multiple options that we could take, and we're going to explore those options. And once we explore those options, we'll find that more options than that are going to make themselves available. And we're going to consider all of the available options to be stored inside of a single data structure that we'll call the frontier. The frontier is going to represent all of the things that we could explore next that we haven't yet explored or visited. So in our approach, we're going to begin the search algorithm by starting with a frontier that just contains one state. The frontier is going to contain the initial state, because at the beginning, that's the only state we know about. That is the only state that exists. And then our search algorithm is effectively going to follow a loop. We're going to repeat some process again and again and again. The first thing we're going to do is if the frontier is empty, then there's no solution. And we can report that there is no way to get to the goal. And that's certainly possible. There are certain types of problems that an AI might try to explore and realize that there is no way to solve that problem. And that's useful information for humans to know as well. So if ever the frontier is empty, that means there's nothing left to explore. And we haven't yet found a solution, so there is no solution. There's nothing left to explore. Otherwise, what we'll do is we'll remove a node from the frontier. So right now at the beginning, the frontier just contains one node representing the initial state. But over time, the frontier might grow. It might contain multiple states. And so here, we're just going to remove a single node from that frontier. If that node happens to be a goal, then we found a solution. So we remove a node from the frontier and ask ourselves, is this the goal? And we do that by applying the goal test that we talked about earlier, asking if we're at the destination. Or asking if all the numbers of the 15 puzzle happen to be in order. So if the node contains the goal, we found a solution. Great. We're done. And otherwise, what we'll need to do is we'll need to expand the node. And this is a term of art in artificial intelligence. To expand the node just means to look at all of the neighbors of that node. In other words, consider all of the possible actions that I could take from the state that this node is representing and what nodes could I get to from there. We're going to take all of those nodes, the next nodes that I can get to from this current one I'm looking at, and add those to the frontier. And then we'll repeat this process. So at a very high level, the idea is we start with a frontier that contains the initial state. And we're constantly removing a node from the frontier, looking at where we can get to next and adding those nodes to the frontier, repeating this process over and over until either we remove a node from the frontier and it contains a goal, meaning we've solved the problem, or we run into a situation where the frontier is empty, at which point we're left with no solution. So let's actually try and take the pseudocode, put it into practice by taking a look at an example of a sample search problem. So right here, I have a sample graph. A is connected to B via this action. B is connected to nodes C and D. C is connected to E. D is connected to F. And what I'd like to do is have my AI find a path from A to E. We want to get from this initial state to this goal state. So how are we going to do that? Well, we're going to start with a frontier that contains the initial state. This is going to represent our frontier. So our frontier initially will just contain A, that initial state where we're going to begin. And now we'll repeat this process. If the frontier is empty, no solution. That's not a problem, because the frontier is not empty. So we'll remove a node from the frontier as the one to consider next. There's only one node in the frontier. So we'll go ahead and remove it from the frontier. But now A, this initial node, this is the node we're currently considering. We follow the next step. We ask ourselves, is this node the goal? No, it's not. A is not the goal. E is the goal. So we don't return the solution. So instead, we go to this last step, expand the node, and add the resulting nodes to the frontier. What does that mean? Well, it means take this state A and consider where we could get to next. And after A, what we could get to next is only B. So that's what we get when we expand A. We find B. And we add B to the frontier. And now B is in the frontier. And we repeat the process again. We say, all right, the frontier is not empty. So let's remove B from the frontier. B is now the node that we're considering. We ask ourselves, is B the goal? No, it's not. So we go ahead and expand B and add its resulting nodes to the frontier. What happens when we expand B? In other words, what nodes can we get to from B? Well, we can get to C and D. So we'll go ahead and add C and D from the frontier. And now we have two nodes in the frontier, C and D. And we repeat the process again. We remove a node from the frontier. For now, I'll do so arbitrarily just by picking C. We'll see why later, how choosing which node you remove from the frontier is actually quite an important part of the algorithm. But for now, I'll arbitrarily remove C, say it's not the goal. So we'll add E, the next one, to the frontier. Then let's say I remove E from the frontier. And now I check I'm currently looking at state E. Is it a goal state? It is, because I'm trying to find a path from A to E. So I would return the goal. And that now would be the solution, that I'm now able to return the solution. And I have found a path from A to E. So this is the general idea, the general approach of this search algorithm, to follow these steps, constantly removing nodes from the frontier, until we're able to find a solution. So the next question you might reasonably ask is, what could go wrong here? What are the potential problems with an approach like this? And here's one example of a problem that could arise from this sort of approach. Imagine this same graph, same as before, with one change. The change being now, instead of just an arrow from A to B, we also have an arrow from B to A, meaning we can go in both directions. And this is true in something like the 15 puzzle, where when I slide a tile to the right, I could then slide a tile to the left to get back to the original position. I could go back and forth between A and B. And that's what these double arrows symbolize, the idea that from one state, I can get to another, and then I can get back. And that's true in many search problems. What's going to happen if I try to apply the same approach now? Well, I'll begin with A, same as before. And I'll remove A from the frontier. And then I'll consider where I can get to from A. And after A, the only place I can get to is B. So B goes into the frontier. Then I'll say, all right, let's take a look at B. That's the only thing left in the frontier. Where can I get to from B? Before, it was just C and D. But now, because of that reverse arrow, I can get to A or C or D. So all three, A, C, and D, all of those now go into the frontier. They are places I can get to from B. And now I remove one from the frontier. And maybe I'm unlucky, and maybe I pick A. And now I'm looking at A again. And I consider, where can I get to from A? And from A, well, I can get to B. And now we start to see the problem. But if I'm not careful, I go from A to B, and then back to A, and then to B again. And I could be going in this infinite loop, where I never make any progress, because I'm constantly just going back and forth between two states that I've already seen. So what is the solution to this? We need some way to deal with this problem. And the way that we can deal with this problem is by somehow keeping track of what we've already explored. And the logic is going to be, well, if we've already explored the state, there's no reason to go back to it. Once we've explored a state, don't go back to it. Don't bother adding it to the frontier. There's no need to. So here's going to be our revised approach, a better way to approach this sort of search problem. And it's going to look very similar, just with a couple of modifications. We'll start with a frontier that contains the initial state, same as before. But now we'll start with another data structure, which will just be a set of nodes that we've already explored. So what are the states we've explored? Initially, it's empty. We have an empty explored set. And now we repeat. If the frontier is empty, no solution, same as before. We remove a node from the frontier. We check to see if it's a goal state, return the solution. None of this is any different so far. But now what we're going to do is we're going to add the node to the explored state. So if it happens to be the case that we remove a node from the frontier and it's not the goal, we'll add it to the explored set so that we know we've already explored it. We don't need to go back to it again if it happens to come up later. And then the final step, we expand the node and we add the resulting nodes to the frontier. But before, we just always added the resulting nodes to the frontier. We're going to be a little clever about it this time. We're only going to add the nodes to the frontier if they aren't already in the frontier and if they aren't already in the explored set. So we'll check both the frontier and the explored set, make sure that the node isn't already in one of those two. And so long as it isn't, then we'll go ahead and add it to the frontier, but not otherwise. And so that revised approach is ultimately what's going to help make sure that we don't go back and forth between two nodes. Now, the one point that I've kind of glossed over here so far is this step here, removing a node from the frontier. Before, I just chose arbitrarily. Like, let's just remove a node and that's it. But it turns out it's actually quite important how we decide to structure our frontier, how we add and how we remove our nodes. The frontier is a data structure and we need to make a choice about in what order are we going to be removing elements. And one of the simplest data structures for adding and removing elements is something called a stack. And a stack is a data structure that is a last in, first out data type, which means the last thing that I add to the frontier is going to be the first thing that I remove from the frontier. So the most recent thing to go into the stack or the frontier in this case is going to be the node that I explore. So let's see what happens if I apply this stack-based approach to something like this problem, finding a path from A to E. What's going to happen? Well, again, we'll start with A and we'll say, all right, let's go ahead and look at A first. And then notice this time, we've added A to the explored set. A is something we've now explored. We have this data structure that's keeping track. We then say from A, we can get to B. And all right, from B, what can we do? Well, from B, we can explore B and get to both C and D. So we added C and then D. So now, when we explore a node, we're going to treat the frontier as a stack, last in, first out. D was the last one to come in. So we'll go ahead and explore that next and say, all right, where can we get to from D? Well, we can get to F. And so all right, we'll put F into the frontier. And now, because the frontier is a stack, F is the most recent thing that's gone in the stack. So F is what we'll explore next. We'll explore F and say, all right, where can we get to from F? Well, we can't get anywhere, so nothing gets added to the frontier. So now, what was the new most recent thing added to the frontier? Well, it's now C, the only thing left in the frontier. We'll explore that from which we can see, all right, from C, we can get to E. So E goes into the frontier. And then we say, all right, let's look at E. And E is now the solution. And now, we've solved the problem. So when we treat the frontier like a stack, a last in, first out data structure, that's the result we get. We go from A to B to D to F. And then we sort of backed up and went down to C and then E. And it's important to get a visual sense for how this algorithm is working. We went very deep in this search tree, so to speak, all the way until the bottom where we hit a dead end. And then we effectively backed up and explored this other route that we didn't try before. And it's this going very deep in the search tree idea, this way the algorithm ends up working when we use a stack that we call this version of the algorithm depth first search. Depth first search is the search algorithm where we always explore the deepest node in the frontier. We keep going deeper and deeper through our search tree. And then if we hit a dead end, we back up and we try something else instead. But depth first search is just one of the possible search options that we could use. It turns out that there's another algorithm called breadth first search, which behaves very similarly to depth first search with one difference. Instead of always exploring the deepest node in the search tree, the way the depth first search does, breadth first search is always going to explore the shallowest node in the frontier. So what does that mean? Well, it means that instead of using a stack which depth first search or DFS used, where the most recent item added to the frontier is the one we'll explore next, in breadth first search or BFS, we'll instead use a queue, where a queue is a first in first out data type, where the very first thing we add to the frontier is the first one we'll explore and they effectively form a line or a queue, where the earlier you arrive in the frontier, the earlier you get explored. So what would that mean for the same exact problem, finding a path from A to E? Well, we start with A, same as before, then we'll go ahead and have explored A and say, where can we get to from A? Well, from A, we can get to B, same as before. From B, same as before, we can get to C and D. So C and D get added to the frontier. This time, though, we added C to the frontier before D. So we'll explore C first. So C gets explored. And from C, where can we get to? Well, we can get to E. So E gets added to the frontier. But because D was explored before E, we'll look at D next. So we'll explore D and say, where can we get to from D? We can get to F. And only then will we say, all right, now we can get to E. And so what breadth first search or BFS did is we started here, we looked at both C and D, and then we looked at E. Effectively, we're looking at things one away from the initial state, then two away from the initial state, and only then, things that are three away from the initial state, unlike depth first search, which just went as deep as possible into the search tree until it hit a dead end and then ultimately had to back up. So these now are two different search algorithms that we could apply in order to try and solve a problem. And let's take a look at how these would actually work in practice with something like maze solving, for example. So here's an example of a maze. These empty cells represent places where our agent can move. These darkened gray cells represent walls that the agent can't pass through. And ultimately, our agent, our AI, is going to try to find a way to get from position A to position B via some sequence of actions, where those actions are left, right, up, and down. What will depth first search do in this case? Well, depth first search will just follow one path. If it reaches a fork in the road where it has multiple different options, depth first search is just, in this case, going to choose one. That doesn't a real preference. But it's going to keep following one until it hits a dead end. And when it hits a dead end, depth first search effectively goes back to the last decision point and tries the other path, fully exhausting this entire path. And when it realizes that, OK, the goal is not here, then it turns its attention to this path. It goes as deep as possible. When it hits a dead end, it backs up and then tries this other path, keeps going as deep as possible down one particular path. And when it realizes that that's a dead end, then it'll back up, and then ultimately find its way to the goal. And maybe you got lucky, and maybe you made a different choice earlier on. But ultimately, this is how depth first search is going to work. It's going to keep following until it hits a dead end. And when it hits a dead end, it backs up and looks for a different solution. And so one thing you might reasonably ask is, is this algorithm always going to work? Will it always actually find a way to get from the initial state? To the goal. And it turns out that as long as our maze is finite, as long as there are only finitely many spaces where we can travel, then, yes, depth first search is going to find a solution. Because eventually, it'll just explore everything. If the maze happens to be infinite and there's an infinite state space, which does exist in certain types of problems, then it's a slightly different story. But as long as our maze has finitely many squares, we're going to find a solution. The next question, though, that we want to ask is, is it going to be a good solution? Is it the optimal solution that we can find? And the answer there is not necessarily. And let's take a look at an example of that. In this maze, for example, we're again trying to find our way from A to B. And you notice here there are multiple possible solutions. We could go this way or we could go up in order to make our way from A to B. Now, if we're lucky, depth first search will choose this way and get to B. But there's no reason necessarily why depth first search would choose between going up or going to the right. It's sort of an arbitrary decision point because both are going to be added to the frontier. And ultimately, if we get unlucky, depth first search might choose to explore this path first because it's just a random choice at this point. It'll explore, explore, explore. And it'll eventually find the goal, this particular path, when in actuality there was a better path. There was a more optimal solution that used fewer steps, assuming we're measuring the cost of a solution based on the number of steps that we need to take. So depth first search, if we're unlucky, might end up not finding the best solution when a better solution is available. So that's DFS, depth first search. How does BFS, or breadth first search, compare? How would it work in this particular situation? Well, the algorithm is going to look very different visually in terms of how BFS explores. Because BFS looks at shallower nodes first, the idea is going to be, BFS will first look at all of the nodes that are one away from the initial state. Look here and look here, for example, just at the two nodes that are immediately next to this initial state. Then it'll explore nodes that are two away, looking at this state and that state, for example. Then it'll explore nodes that are three away, this state and that state. Whereas depth first search just picked one path and kept following it, breadth first search, on the other hand, is taking the option of exploring all of the possible paths as kind of at the same time bouncing back between them, looking deeper and deeper at each one, but making sure to explore the shallower ones or the ones that are closer to the initial state earlier. So we'll keep following this pattern, looking at things that are four away, looking at things that are five away, looking at things that are six away, until eventually we make our way to the goal. And in this case, it's true we had to explore some states that ultimately didn't lead us anywhere, but the path that we found to the goal was the optimal path. This is the shortest way that we could get to the goal. And so what might happen then in a larger maze? Well, let's take a look at something like this and how breadth first search is going to behave. Well, breadth first search, again, we'll just keep following the states until it receives a decision point. It could go either left or right. And while DFS just picked one and kept following that until it hit a dead end, BFS, on the other hand, will explore both. It'll say look at this node, then this node, and it'll look at this node, then that node. So on and so forth. And when it hits a decision point here, rather than pick one left or two right and explore that path, it'll again explore both, alternating between them, going deeper and deeper. We'll explore here, and then maybe here and here, and then keep going. Explore here and slowly make our way, you can visually see, further and further out. Once we get to this decision point, we'll explore both up and down until ultimately we make our way to the goal. And what you'll notice is, yes, breadth first search did find our way from A to B by following this particular path, but it needed to explore a lot of states in order to do so. And so we see some trade offs here between DFS and BFS, that in DFS, there may be some cases where there is some memory savings as compared to a breadth first approach, where breadth first search in this case had to explore a lot of states. But maybe that won't always be the case. So now let's actually turn our attention to some code and look at the code that we could actually write in order to implement something like depth first search or breadth first search in the context of solving a maze, for example. So I'll go ahead and go into my terminal. And what I have here inside of maze.py is an implementation of this same idea of maze solving. I've defined a class called node that in this case is keeping track of the state, the parent, in other words, the state before the state, and the action. In this case, we're not keeping track of the path cost because we can calculate the cost of the path at the end after we found our way from the initial state to the goal. In addition to this, I've defined a class called a stack frontier. And if unfamiliar with a class, a class is a way for me to define a way to generate objects in Python. It refers to an idea of object oriented programming, where the idea here is that I would like to create an object that is able to store all of my frontier data. And I would like to have functions, otherwise known as methods, on that object that I can use to manipulate the object. And so what's going on here, if unfamiliar with the syntax, is I have a function that initially creates a frontier that I'm going to represent using a list. And initially, my frontier is represented by the empty list. There's nothing in my frontier to begin with. I have an add function that adds something to the frontier as by appending it to the end of the list. I have a function that checks if the frontier contains a particular state. I have an empty function that checks if the frontier is empty. If the frontier is empty, that just means the length of the frontier is 0. And then I have a function for removing something from the frontier. I can't remove something from the frontier if the frontier is empty, so I check for that first. But otherwise, if the frontier isn't empty, recall that I'm implementing this frontier as a stack, a last in first out data structure, which means the last thing I add to the frontier, in other words, the last thing in the list, is the item that I should remove from this frontier. So what you'll see here is I have removed the last item of a list. And if you index into a Python list with negative 1, that gets you the last item in the list. Since 0 is the first item, negative 1 kind of wraps around and gets you to the last item in the list. So we give that the node. We call that node. We update the frontier here on line 28 to say, go ahead and remove that node that you just removed from the frontier. And then we return the node as a result. So this class here effectively implements the idea of a frontier. It gives me a way to add something to a frontier and a way to remove something from the frontier as a stack. I've also, just for good measure, implemented an alternative version of the same thing called a queue frontier, which in parentheses you'll see here, it inherits from a stack frontier, meaning it's going to do all the same things that the stack frontier did, except the way we remove a node from the frontier is going to be slightly different. Instead of removing from the end of the list the way we would in a stack, we're instead going to remove from the beginning of the list. Self.frontier 0 will get me the first node in the frontier, the first one that was added, and that is going to be the one that we return in the case of a queue. Then under here, I have a definition of a class called maze. This is going to handle the process of taking a sequence, a maze-like text file, and figuring out how to solve it. So it will take as input a text file that looks something like this, for example, where we see hash marks that are here representing walls, and I have the character A representing the starting position and the character B representing the ending position. And you can take a look at the code for parsing this text file right now. That's the less interesting part. The more interesting part is this solve function here, the solve function is going to figure out how to actually get from point A to point B. And here we see an implementation of the exact same idea we saw from a moment ago. We're going to keep track of how many states we've explored, just so we can report that data later. But I start with a node that represents just the start state. And I start with a frontier that, in this case, is a stack frontier. And given that I'm treating my frontier as a stack, you might imagine that the algorithm I'm using here is now depth-first search, because depth-first search, or DFS, uses a stack as its data structure. And initially, this frontier is just going to contain the start state. We initialize an explored set that initially is empty. There's nothing we've explored so far. And now here's our loop, that notion of repeating something again and again. First, we check if the frontier is empty by calling that empty function that we saw the implementation of a moment ago. And if the frontier is indeed empty, we'll go ahead and raise an exception, or a Python error, to say, sorry, there is no solution to this problem. Otherwise, we'll go ahead and remove a node from the frontier as by calling frontier.remove and update the number of states we've explored, because now we've explored one additional state. So we say self.numexplored plus equals 1, adding 1 to the number of states we've explored. Once we remove a node from the frontier, recall that the next step is to see whether or not it's the goal, the goal test. And in the case of the maze, the goal is pretty easy. I check to see whether the state of the node is equal to the goal. Initially, when I set up the maze, I set up this value called goal, which is a property of the maze, so I can just check to see if the node is actually the goal. And if it is the goal, then what I want to do is backtrack my way towards figuring out what actions I took in order to get to this goal. And how do I do that? We'll recall that every node stores its parent, the node that came before it that we used to get to this node, and also the action used in order to get there. So I can create this loop where I'm constantly just looking at the parent of every node and keeping track for all of the parents what action I took to get from the parent to this current node. So this loop is going to keep repeating this process of looking through all of the parent nodes until we get back to the initial state, which has no parent, where node.parent is going to be equal to none. As I do so, I'm going to be building up the list of all of the actions that I'm following and the list of all the cells that are part of the solution. But I'll reverse them because when I build it up, going from the goal back to the initial state and building the sequence of actions from the goal to the initial state, but I want to reverse them in order to get the sequence of actions from the initial state to the goal. And that is ultimately going to be the solution. So all of that happens if the current state is equal to the goal. And otherwise, if it's not the goal, well, then I'll go ahead and add this state to the explored set to say, I've explored this state now. No need to go back to it if I come across it in the future. And then this logic here implements the idea of adding neighbors to the frontier. I'm saying, look at all of my neighbors, and I implemented a function called neighbors that you can take a look at. And for each of those neighbors, I'm going to check, is the state already in the frontier? Is the state already in the explored set? And if it's not in either of those, then I'll go ahead and add this new child node, this new node, to the frontier. So there's a fair amount of syntax here, but the key here is not to understand all the nuances of the syntax. So feel free to take a closer look at this file on your own to get a sense for how it is working. But the key is to see how this is an implementation of the same pseudocode, the same idea that we were describing a moment ago on the screen when we were looking at the steps that we might follow in order to solve this kind of search problem. So now let's actually see this in action. I'll go ahead and run maze.py on maze1.txt, for example. And what we'll see is here, we have a printout of what the maze initially looked like. And then here down below is after we've solved it. We had to explore 11 states in order to do it, and we found a path from A to B. And in this program, I just happened to generate a graphical representation of this as well. So I can open up maze.png, which is generated by this program, that shows you where in the darker color here are the walls, red is the initial state, green is the goal, and yellow is the path that was followed. We found a path from the initial state to the goal. But now let's take a look at a more sophisticated maze to see what might happen instead. Let's look now at maze2.txt. We're now here. We have a much larger maze. Again, we're trying to find our way from point A to point B. But now you'll imagine that depth-first search might not be so lucky. It might not get the goal on the first try. It might have to follow one path, then backtrack and explore something else a little bit later. So let's try this. We'll run python maze.py of maze2.txt, this time trying on this other maze. And now, depth-first search is able to find a solution. Here, as indicated by the stars, is a way to get from A to B. And we can represent this visually by opening up this maze. Here's what that maze looks like, and highlighted in yellow is the path that was found from the initial state to the goal. But how many states did we have to explore before we found that path? Well, recall that in my program, I was keeping track of the number of states that we've explored so far. And so I can go back to the terminal and see that, all right, in order to solve this problem, we had to explore 399 different states. And in fact, if I make one small modification of the program and tell the program at the end when we output this image, I added an argument called show explored. And if I set show explored equal to true and rerun this program, python maze.py, running it on maze2, and then I open the maze, what you'll see here is highlighted in red are all of the states that had to be explored to get from the initial state to the goal. Depth-first search, or DFS, didn't find its way to the goal right away. It made a choice to first explore this direction. And when it explored this direction, it had to follow every conceivable path all the way to the very end, even this long and winding one, in order to realize that, you know what? That's a dead end. And instead, the program needed to backtrack. After going this direction, it must have gone this direction. It got lucky here by just not choosing this path, but it got unlucky here, exploring this direction, exploring a bunch of states it didn't need to, and then likewise exploring all of this top part of the graph when it probably didn't need to do that either. So all in all, depth-first search here really not performing optimally, or probably exploring more states than it needs to. It finds an optimal solution, the best path to the goal, but the number of states needed to explore in order to do so, the number of steps I had to take, that was much higher. So let's compare. How would breadth-first search, or BFS, do on this exact same maze instead? And in order to do so, it's a very easy change. The algorithm for DFS and BFS is identical with the exception of what data structure we use to represent the frontier, that in DFS, I used a stack frontier, last in, first out, whereas in BFS, I'm going to use a queue frontier, first in, first out, where the first thing I add to the frontier is the first thing that I remove. So I'll go back to the terminal, rerun this program on the same maze, and now you'll see that the number of states we had to explore was only 77 as compared to almost 400 when we used depth-first search. And we can see exactly why. We can see what happened if we open up maze.png now and take a look. Again, yellow highlight is the solution that breadth-first search found, which incidentally is the same solution that depth-first search found. They're both finding the best solution. But notice all the white unexplored cells. There was much fewer states that needed to be explored in order to make our way to the goal because breadth-first search operates a little more shallowly. It's exploring things that are close to the initial state without exploring things that are further away. So if the goal is not too far away, then breadth-first search can actually behave quite effectively on a maze that looks a little something like this. Now, in this case, both BFS and DFS ended up finding the same solution, but that won't always be the case. And in fact, let's take a look at one more example. For instance, maze3.txt. In maze3.txt, notice that here there are multiple ways that you could get from A to B. It's a relatively small maze, but let's look at what happens. If I use, and I'll go ahead and turn off show explored so we just see the solution. If I use BFS, breadth-first search, to solve maze3.txt, well, then we find a solution, and if I open up the maze, here is the solution that we found. It is the optimal one. With just four steps, we can get from the initial state to what the goal happens to be. But what happens if we tried to use depth-first search or DFS instead? Well, again, I'll go back up to my Q frontier, where Q frontier means that we're using breadth-first search, and I'll change it to a stack frontier, which means that now we'll be using depth-first search. I'll rerun pythonmaze.py, and now you'll see that we find the solution, but it is not the optimal solution. This instead is what our algorithm finds, and maybe depth-first search would have found the solution. It's possible, but it's not guaranteed that if we just happen to be unlucky, if we choose this state instead of that state, then depth-first search might find a longer route to get from the initial state to the goal. So we do see some trade-offs here, where depth-first search might not find the optimal solution. So at that point, it seems like breadth-first search is pretty good. Is that the best we can do, where it's going to find us the optimal solution, and we don't have to worry about situations where we might end up finding a longer path to the solution than what actually exists? Where the goal is far away from the initial state, and we might have to take lots of steps in order to get from the initial state to the goal, what ended up happening is that this algorithm, BFS, ended up exploring basically the entire graph, having to go through the entire maze in order to find its way from the initial state to the goal state. What we'd ultimately like is for our algorithm to be a little bit more intelligent. And now what would it mean for our algorithm to be a little bit more intelligent in this case? Well, let's look back to where breadth-first search might have been able to make a different decision and consider human intuition in this process as well. What might a human do when solving this maze that is different than what BFS ultimately chose to do? Well, the very first decision point that BFS made was right here, when it made five steps and ended up in a position where it had a fork in the row. It could either go left or it could go right. In these initial couple steps, there was no choice. There was only one action that could be taken from each of those states. And so the search algorithm did the only thing that any search algorithm could do, which is keep following that state after the next state. But this decision point is where things get a little bit interesting. Depth-first search, that very first search algorithm we looked at, chose to say, let's pick one path and exhaust that path. See if anything that way has the goal. And if not, then let's try the other way. Depth-first search took the alternative approach of saying, you know what, let's explore things that are shallow, close to us first. Look left and right, then back left and back right, so on and so forth, alternating between our options in the hopes of finding something nearby. But ultimately, what might a human do if confronted with a situation like this of go left or go right? Well, a human might visually see that, all right, I'm trying to get to state b, which is way up there, and going right just feels like it's closer to the goal. It feels like going right should be better than going left because I'm making progress towards getting to that goal. Now, of course, there are a couple of assumptions that I'm making here. I'm making the assumption that we can represent this grid as like a two-dimensional grid where I know the coordinates of everything. I know that a is in coordinate 0, 0, and b is in some other coordinate pair, and I know what coordinate I'm at now. So I can calculate that, yeah, going this way, that is closer to the goal. And that might be a reasonable assumption for some types of search problems, but maybe not in others. But for now, we'll go ahead and assume that, that I know what my current coordinate pair is, and I know the coordinate, x, y, of the goal that I'm trying to get to. And in this situation, I'd like an algorithm that is a little bit more intelligent, that somehow knows that I should be making progress towards the goal, and this is probably the way to do that because in a maze, moving in the coordinate direction of the goal is usually, though not always, a good thing. And so here we draw a distinction between two different types of search algorithms, uninformed search and informed search. Uninformed search algorithms are algorithms like DFS and BFS, the two algorithms that we just looked at, which are search strategies that don't use any problem-specific knowledge to be able to solve the problem. DFS and BFS didn't really care about the structure of the maze or anything about the way that a maze is in order to solve the problem. They just look at the actions available and choose from those actions, and it doesn't matter whether it's a maze or some other problem, the solution or the way that it tries to solve the problem is really fundamentally going to be the same. What we're going to take a look at now is an improvement upon uninformed search. We're going to take a look at informed search. Informed search are going to be search strategies that use knowledge specific to the problem to be able to better find a solution. And in the case of a maze, this problem-specific knowledge is something like if I'm in a square that is geographically closer to the goal, that is better than being in a square that is geographically further away. And this is something we can only know by thinking about this problem and reasoning about what knowledge might be helpful for our AI agent to know a little something about. There are a number of different types of informed search. Specifically, first, we're going to look at a particular type of search algorithm called greedy best-first search. Greedy best-first search, often abbreviated G-BFS, is a search algorithm that instead of expanding the deepest node like DFS or the shallowest node like BFS, this algorithm is always going to expand the node that it thinks is closest to the goal. Now, the search algorithm isn't going to know for sure whether it is the closest thing to the goal. Because if we knew what was closest to the goal all the time, then we would already have a solution. The knowledge of what is close to the goal, we could just follow those steps in order to get from the initial position to the solution. But if we don't know the solution, meaning we don't know exactly what's closest to the goal, instead we can use an estimate of what's closest to the goal, otherwise known as a heuristic, just some way of estimating whether or not we're close to the goal. And we'll do so using a heuristic function conventionally called h of n that takes a status input and returns our estimate of how close we are to the goal. So what might this heuristic function actually look like in the case of a maze solving algorithm? Where we're trying to solve a maze, what does the heuristic look like? Well, the heuristic needs to answer a question between these two cells, C and D, which one is better? Which one would I rather be in if I'm trying to find my way to the goal? Well, any human could probably look at this and tell you, you know what, D looks like it's better. Even if the maze is convoluted and you haven't thought about all the walls, D is probably better. And why is D better? Well, because if you ignore the wall, so let's just pretend the walls don't exist for a moment and relax the problem, so to speak, D, just in terms of coordinate pairs, is closer to this goal. It's fewer steps that I wouldn't take to get to the goal as compared to C, even if you ignore the walls. If you just know the xy-coordinate of C and the xy-coordinate of the goal, and likewise you know the xy-coordinate of D, you can calculate the D just geographically. Ignoring the walls looks like it's better. And so this is the heuristic function that we're going to use. And it's something called the Manhattan distance, one specific type of heuristic, where the heuristic is how many squares vertically and horizontally and then left to right, so not allowing myself to go diagonally, just either up or right or left or down. How many steps do I need to take to get from each of these cells to the goal? Well, as it turns out, D is much closer. There are fewer steps. It only needs to take six steps in order to get to that goal. Again, here, ignoring the walls. We've relaxed the problem a little bit. We're just concerned with if you do the math to subtract the x values from each other and the y values from each other, what is our estimate of how far we are away? We can estimate the D is closer to the goal than C is. And so now we have an approach. We have a way of picking which node to remove from the frontier. And at each stage in our algorithm, we're going to remove a node from the frontier. We're going to explore the node if it has the smallest value for this heuristic function, if it has the smallest Manhattan distance to the goal. And so what would this actually look like? Well, let me first label this graph, label this maze, with a number representing the value of this heuristic function, the value of the Manhattan distance from any of these cells. So from this cell, for example, we're one away from the goal. From this cell, we're two away from the goal, three away, four away. Here, we're five away because we have to go one to the right and then four up. From somewhere like here, the Manhattan distance is two. We're only two squares away from the goal geographically, even though in practice, we're going to have to take a longer path. But we don't know that yet. The heuristic is just some easy way to estimate how far we are away from the goal. And maybe our heuristic is overly optimistic. It thinks that, yeah, we're only two steps away. When in practice, when you consider the walls, it might be more steps. So the important thing here is that the heuristic isn't a guarantee of how many steps it's going to take. It is estimating. It's an attempt at trying to approximate. And it does seem generally the case that the squares that look closer to the goal have smaller values for the heuristic function than squares that are further away. So now, using greedy best-first search, what might this algorithm actually do? Well, again, for these first five steps, there's not much of a choice. We start at this initial state a, and we say, all right, we have to explore these five states. But now we have a decision point. Now we have a choice between going left and going right. And before, when DFS and BFS would just pick arbitrarily, because it just depends on the order you throw these two nodes into the frontier, and we didn't specify what order you put them into the frontier, only the order you take them out, here we can look at 13 and 11 and say that, all right, this square is a distance of 11 away from the goal according to our heuristic, according to our estimate. And this one, we estimate to be 13 away from the goal. So between those two options, between these two choices, I'd rather have the 11. I'd rather be 11 steps away from the goal, so I'll go to the right. We're able to make an informed decision, because we know a little something more about this problem. So then we keep following, 10, 9, 8. Between the two 7s, we don't really have much of a way to know between those. So then we do just have to make an arbitrary choice. And you know what, maybe we choose wrong. But that's OK, because now we can still say, all right, let's try this 7. We say 7, 6, we have to make this choice, even though it increases the value of the heuristic function. But now we have another decision point, between 6 and 8, and between those two. And really, we're also considering this 13, but that's much higher. Between 6, 8, and 13, well, the 6 is the smallest value, so we'd rather take the 6. We're able to make an informed decision that going this way to the right is probably better than going down. So we turn this way, we go to 5. And now we find a decision point where we'll actually make a decision that we might not want to make, but there's unfortunately not too much of a way around this. We see 4 and 6. 4 looks closer to the goal, right? It's going up, and the goal is further up. So we end up taking that route, which ultimately leads us to a dead end. But that's OK, because we can still say, all right, now let's try the 6. And now follow this route that will ultimately lead us to the goal. And so this now is how greedy best-for-search might try to approach this problem by saying, whenever we have a decision between multiple nodes that we could explore, let's explore the node that has the smallest value of h of n, this heuristic function that is estimating how far I have to go. And it just so happens that in this case, we end up doing better in terms of the number of states we needed to explore than BFS needed to. BFS explored all of this section and all of that section, but we were able to eliminate that by taking advantage of this heuristic, this knowledge about how close we are to the goal or some estimate of that idea. So this seems much better. So wouldn't we always prefer an algorithm like this over an algorithm like breadth-first search? Well, maybe one thing to take into consideration is that we need to come up with a good heuristic, how good the heuristic is, is going to affect how good this algorithm is. And coming up with a good heuristic can oftentimes be challenging. But the other thing to consider is to ask the question, just as we did with the prior two algorithms, is this algorithm optimal? Will it always find the shortest path from the initial state to the goal? And to answer that question, let's take a look at this example for a moment. Take a look at this example. Again, we're trying to get from A to B. And again, I've labeled each of the cells with their Manhattan distance from the goal. The number of squares up and to the right, you would need to travel in order to get from that square to the goal. And let's think about, would greedy best-first search that always picks the smallest number end up finding the optimal solution? What is the shortest solution? And would this algorithm find it? And the important thing to realize is that right here is the decision point. We're estimated to be 12 away from the goal. And we have two choices. We can go to the left, which we estimate to be 13 away from the goal. Or we can go up, where we estimate it to be 11 away from the goal. And between those two, greedy best-first search is going to say the 11 looks better than the 13. And in doing so, greedy best-first search will end up finding this path to the goal. But it turns out this path is not optimal. There is a way to get to the goal using fewer steps. And it's actually this way, this way that ultimately involved fewer steps, even though it meant at this moment choosing the worst option between the two or what we estimated to be the worst option based on the heuristics. And so this is what we mean by this is a greedy algorithm. It's making the best decision locally. At this decision point, it looks like it's better to go here than it is to go to the 13. But in the big picture, it's not necessarily optimal. That it might find a solution when in actuality, there was a better solution available. So we would like some way to solve this problem. We like the idea of this heuristic, of being able to estimate the path, the distance between us and the goal. And that helps us to be able to make better decisions and to eliminate having to search through entire parts of this state space. But we would like to modify the algorithm so that we can achieve optimality, so that it can be optimal. And what is the way to do this? What is the intuition here? Well, let's take a look at this problem. In this initial problem, greedy best research found us this solution here, this long path. And the reason why it wasn't great is because, yes, the heuristic numbers went down pretty low. But later on, they started to build back up. They built back 8, 9, 10, 11, all the way up to 12 in this case. And so how might we go about trying to improve this algorithm? Well, one thing that we might realize is that if we go all the way through this algorithm, through this path, and we end up going to the 12, and we've had to take this many steps, who knows how many steps that is, just to get to this 12, we could have also, as an alternative, taken much fewer steps, just six steps, and ended up at this 13 here. And yes, 13 is more than 12, so it looks like it's not as good. But it required far fewer steps. It only took six steps to get to this 13 versus many more steps to get to this 12. And while greedy best research says, oh, well, 12 is better than 13, so pick the 12, we might more intelligently say, I'd rather be somewhere that heuristically looks like it takes slightly longer if I can get there much more quickly. And we're going to encode that idea, this general idea, into a more formal algorithm known as A star search. A star search is going to solve this problem by instead of just considering the heuristic, also considering how long it took us to get to any particular state. So the distinction is greedy best for search. If I am in a state right now, the only thing I care about is, what is the estimated distance, the heuristic value, between me and the goal? Whereas A star search will take into consideration two pieces of information. It'll take into consideration, how far do I estimate I am from the goal? But also, how far did I have to travel in order to get here? Because that is relevant, too. So we'll search algorithms by expanding the node with the lowest value of g of n plus h of n. h of n is that same heuristic that we were talking about a moment ago that's going to vary based on the problem. But g of n is going to be the cost to reach the node, how many steps I had to take, in this case, to get to my current position. So what does that search algorithm look like in practice? Well, let's take a look. Again, we've got the same maze. And again, I've labeled them with their Manhattan distance. This value is the h of n value, the heuristic estimate of how far each of these squares is away from the goal. But now, as we begin to explore states, we care not just about this heuristic value, but also about g of n, the number of steps I had to take in order to get there. And I care about summing those two numbers together. So what does that look like? On this very first step, I have taken one step. And now I am estimated to be 16 steps away from the goal. So the total value here is 17. Then I take one more step. I've now taken two steps. And I estimate myself to be 15 away from the goal, again, a total value of 17. Now I've taken three steps. And I'm estimated to be 14 away from the goal, so on and so forth. Four steps, an estimate of 13. Five steps, estimate of 12. And now here's a decision point. I could either be six steps away from the goal with a heuristic of 13 for a total of 19, or I could be six steps away from the goal with a heuristic of 11 with an estimate of 17 for the total. So between 19 and 17, I'd rather take the 17, the 6 plus 11. So so far, no different than what we saw before. We're still taking this option because it appears to be better. And I keep taking this option because it appears to be better. But it's right about here that things get a little bit different. Now I could be 15 steps away from the goal with an estimated distance of 6. So 15 plus 6, total value of 21. Alternatively, I could be six steps away from the goal, because this is five steps away, so this is six steps away, with a total value of 13 as my estimate. So 6 plus 13, that's 19. So here, we would evaluate g of n plus h of n to be 19, 6 plus 13. Whereas here, we would be 15 plus 6, or 21. And so the intuition is 19 less than 21, pick here. But the idea is ultimately I'd rather be having taken fewer steps, get to a 13, than having taken 15 steps and be at a 6, because it means I've had to take more steps in order to get there. Maybe there's a better path this way. So instead, we'll explore this route. Now if we go one more, this is seven steps plus 14 is 21. So between those two, it's sort of a toss-up. We might end up exploring that one anyways. But after that, as these numbers start to get bigger in the heuristic values, and these heuristic values start to get smaller, you'll find that we'll actually keep exploring down this path. And you can do the math to see that at every decision point, A star search is going to make a choice based on the sum of how many steps it took me to get to my current position, and then how far I estimate I am from the goal. So while we did have to explore some of these states, the ultimate solution we found was, in fact, an optimal solution. It did find us the quickest possible way to get from the initial state to the goal. And it turns out that A star is an optimal search algorithm under certain conditions. So the conditions are H of n, my heuristic, needs to be admissible. What does it mean for a heuristic to be admissible? Well, a heuristic is admissible if it never overestimates the true cost. H of n always needs to either get it exactly right in terms of how far away I am, or it needs to underestimate. So we saw an example from before where the heuristic value was much smaller than the actual cost it would take. That's totally fine, but the heuristic value should never overestimate. It should never think that I'm further away from the goal than I actually am. And meanwhile, to make a stronger statement, H of n also needs to be consistent. And what does it mean for it to be consistent? Mathematically, it means that for every node, which we'll call n, and successor, the node after me, that I'll call n prime, where it takes a cost of C to make that step, the heuristic value of n needs to be less than or equal to the heuristic value of n prime plus the cost. So it's a lot of math, but in words what that ultimately means is that if I am here at this state right now, the heuristic value from me to the goal shouldn't be more than the heuristic value of my successor, the next place I could go to, plus however much it would cost me to just make that step from one step to the next step. And so this is just making sure that my heuristic is consistent between all of these steps that I might take. So as long as this is true, then A star search is going to find me an optimal solution. And this is where much of the challenge of solving these search problems can sometimes come in, that A star search is an algorithm that is known and you could write the code fairly easily, but it's choosing the heuristic. It can be the interesting challenge. The better the heuristic is, the better I'll be able to solve the problem in the fewer states that I'll have to explore. And I need to make sure that the heuristic satisfies these particular constraints. So all in all, these are some of the examples of search algorithms that might work, and certainly there are many more than just this. A star, for example, does have a tendency to use quite a bit of memory. So there are alternative approaches to A star that ultimately use less memory than this version of A star happens to use, and there are other search algorithms that are optimized for other cases as well. But now so far, we've only been looking at search algorithms where there is one agent. I am trying to find a solution to a problem. I am trying to navigate my way through a maze. I am trying to solve a 15 puzzle. I am trying to find driving directions from point A to point B. Sometimes in search situations, though, we'll enter an adversarial situation, where I am an agent trying to make intelligent decisions. And there's someone else who is fighting against me, so to speak, that has opposite objectives, someone where I am trying to succeed, someone else that wants me to fail. And this is most popular in something like a game, a game like Tic Tac Toe, where we've got this 3 by 3 grid, and x and o take turns, either writing an x or an o in any one of these squares. And the goal is to get three x's in a row if you're the x player, or three o's in a row if you're the o player. And computers have gotten quite good at playing games, Tic Tac Toe very easily, but even more complex games. And so you might imagine, what does an intelligent decision in a game look like? So maybe x makes an initial move in the middle, and o plays up here. What does an intelligent move for x now become? Where should you move if you were x? And it turns out there are a couple of possibilities. But if an AI is playing this game optimally, then the AI might play somewhere like the upper right, where in this situation, o has the opposite objective of x. x is trying to win the game to get three in a row diagonally here. And o is trying to stop that objective, opposite of the objective. And so o is going to place here to try to block. But now, x has a pretty clever move. x can make a move like this, where now x has two possible ways that x can win the game. x could win the game by getting three in a row across here. Or x could win the game by getting three in a row vertically this way. So it doesn't matter where o makes their next move. o could play here, for example, blocking the three in a row horizontally. But then x is going to win the game by getting a three in a row vertically. And so there's a fair amount of reasoning that's going on here in order for the computer to be able to solve a problem. And it's similar in spirit to the problems we've looked at so far. There are actions. There's some sort of state of the board and some transition from one action to the next. But it's different in the sense that this is now not just a classical search problem, but an adversarial search problem. That I am at the x player trying to find the best moves to make, but I know that there is some adversary that is trying to stop me. So we need some sort of algorithm to deal with these adversarial type of search situations. And the algorithm we're going to take a look at is an algorithm called Minimax, which works very well for these deterministic games where there are two players. It can work for other types of games as well. But we'll look right now at games where I make a move, then my opponent makes a move. And I am trying to win, and my opponent is trying to win also. Or in other words, my opponent is trying to get me to lose. And so what do we need in order to make this algorithm work? Well, any time we try and translate this human concept of playing a game, winning and losing to a computer, we want to translate it in terms that the computer can understand. And ultimately, the computer really just understands the numbers. And so we want some way of translating a game of x's and o's on a grid to something numerical, something the computer can understand. The computer doesn't normally understand notions of win or lose. But it does understand the concept of bigger and smaller. And so what we might do is we might take each of the possible ways that a tic-tac-toe game can unfold and assign a value or a utility to each one of those possible ways. And in a tic-tac-toe game, and in many types of games, there are three possible outcomes. The outcomes are o wins, x wins, or nobody wins. So player one wins, player two wins, or nobody wins. And for now, let's go ahead and assign each of these possible outcomes a different value. We'll say o winning, that'll have a value of negative 1. Nobody winning, that'll have a value of 0. And x winning, that will have a value of 1. So we've just assigned numbers to each of these three possible outcomes. And now we have two players, we have the x player and the o player. And we're going to go ahead and call the x player the max player. And we'll call the o player the min player. And the reason why is because in the min and max algorithm, the max player, which in this case is x, is aiming to maximize the score. These are the possible options for the score, negative 1, 0, and 1. x wants to maximize the score, meaning if at all possible, x would like this situation, where x wins the game, and we give it a score of 1. But if this isn't possible, if x needs to choose between these two options, negative 1, meaning o winning, or 0, meaning nobody winning, x would rather that nobody wins, score of 0, than a score of negative 1, o winning. So this notion of winning and losing and tying has been reduced mathematically to just this idea of try and maximize the score. The x player always wants the score to be bigger. And on the flip side, the min player, in this case o, is aiming to minimize the score. The o player wants the score to be as small as possible. So now we've taken this game of x's and o's and winning and losing and turned it into something mathematical, something where x is trying to maximize the score, o is trying to minimize the score. Let's now look at all of the parts of the game that we need in order to encode it in an AI so that an AI can play a game like tic-tac-toe. So the game is going to need a couple of things. We'll need some sort of initial state that will, in this case, call s0, which is how the game begins, like an empty tic-tac-toe board, for example. We'll also need a function called player, where the player function is going to take as input a state here represented by s. And the output of the player function is going to be which player's turn is it. We need to be able to give a tic-tac-toe board to the computer, run it through a function, and that function tells us whose turn it is. We'll need some notion of actions that we can take. We'll see examples of that in just a moment. We need some notion of a transition model, same as before. If I have a state and I take an action, I need to know what results as a consequence of it. I need some way of knowing when the game is over. So this is equivalent to kind of like a goal test, but I need some terminal test, some way to check to see if a state is a terminal state, where a terminal state means the game is over. In a classic game of tic-tac-toe, a terminal state means either someone has gotten three in a row or all of the squares of the tic-tac-toe board are filled. Either of those conditions make it a terminal state. In a game of chess, it might be something like when there is checkmate or if checkmate is no longer possible, that that becomes a terminal state. And then finally, we'll need a utility function, a function that takes a state and gives us a numerical value for that terminal state, some way of saying if x wins the game, that has a value of 1. If o is won the game, that has a value of negative 1. If nobody has won the game, that has a value of 0. So let's take a look at each of these in turn. The initial state, we can just represent in tic-tac-toe as the empty game board. This is where we begin. It's the place from which we begin this search. And again, I'll be representing these things visually, but you can imagine this really just being like an array or a two-dimensional array of all of these possible squares. Then we need the player function that, again, takes a state and tells us whose turn it is. Assuming x makes the first move, if I have an empty game board, then my player function is going to return x. And if I have a game board where x has made a move, then my player function is going to return o. The player function takes a tic-tac-toe game board and tells us whose turn it is. Next up, we'll consider the actions function. The actions function, much like it did in classical search, takes a state and gives us the set of all of the possible actions we can take in that state. So let's imagine it's o is turned to move in a game board that looks like this. What happens when we pass it into the actions function? So the actions function takes this state of the game as input, and the output is a set of possible actions. It's a set of I could move in the upper left or I could move in the bottom middle. So those are the two possible action choices that I have when I begin in this particular state. Now, just as before, when we had states and actions, we need some sort of transition model to tell us when we take this action in the state, what is the new state that we get. And here, we define that using the result function that takes a state as input as well as an action. And when we apply the result function to this state, saying that let's let o move in this upper left corner, the new state we get is this resulting state where o is in the upper left corner. And now, this seems obvious to someone who knows how to play tic-tac-toe. Of course, you play in the upper left corner. That's the board you get. But all of this information needs to be encoded into the AI. The AI doesn't know how to play tic-tac-toe until you tell the AI how the rules of tic-tac-toe work. And this function, defining this function here, allows us to tell the AI how this game actually works and how actions actually affect the outcome of the game. So the AI needs to know how the game works. The AI also needs to know when the game is over, as by defining a function called terminal that takes as input a state s, such that if we take a game that is not yet over, pass it into the terminal function, the output is false. The game is not over. But if we take a game that is over because x has gotten three in a row along that diagonal, pass that into the terminal function, then the output is going to be true because the game now is, in fact, over. And finally, we've told the AI how the game works in terms of what moves can be made and what happens when you make those moves. We've told the AI when the game is over. Now we need to tell the AI what the value of each of those states is. And we do that by defining this utility function that takes a state s and tells us the score or the utility of that state. So again, we said that if x wins the game, that utility is a value of 1, whereas if o wins the game, then the utility of that is negative 1. And the AI needs to know, for each of these terminal states where the game is over, what is the utility of that state? So if I give you a game board like this where the game is, in fact, over, and I ask the AI to tell me what the value of that state is, it could do so. The value of the state is 1. Where things get interesting, though, is if the game is not yet over. Let's imagine a game board like this, where in the middle of the game, it's o's turn to make a move. So how do we know it's o's turn to make a move? We can calculate that using the player function. We can say player of s, pass in the state, o is the answer. So we know it's o's turn to move. And now, what is the value of this board and what action should o take? Well, that's going to depend. We have to do some calculation here. And this is where the minimax algorithm really comes in. Recall that x is trying to maximize the score, which means that o is trying to minimize the score. So o would like to minimize the total value that we get at the end of the game. And because this game isn't over yet, we don't really know just yet what the value of this game board is. We have to do some calculation in order to figure that out. And so how do we do that kind of calculation? Well, in order to do so, we're going to consider, just as we might in a classical search situation, what actions could happen next and what states will that take us to. And it turns out that in this position, there are only two open squares, which means there are only two open places where o can make a move. o could either make a move in the upper left or o can make a move in the bottom middle. And minimax doesn't know right out of the box which of those moves is going to be better. So it's going to consider both. But now, we sort of run into the same situation. Now, I have two more game boards, neither of which is over. What happens next? And now, it's in this sense that minimax is what we'll call a recursive algorithm. It's going to now repeat the exact same process, although now considering it from the opposite perspective. It's as if I am now going to put myself, if I am the o player, I'm going to put myself in my opponent's shoes, my opponent as the x player, and consider what would my opponent do if they were in this position? What would my opponent do, the x player, if they were in that position? And what would then happen? Well, the other player, my opponent, the x player, is trying to maximize the score, whereas I am trying to minimize the score as the o player. So x is trying to find the maximum possible value that they can get. And so what's going to happen? Well, from this board position, x only has one choice. x is going to play here, and they're going to get three in a row. And we know that that board, x winning, that has a value of 1. If x wins the game, the value of that game board is 1. And so from this position, if this state can only ever lead to this state, it's the only possible option, and this state has a value of 1, then the maximum possible value that the x player can get from this game board is also 1. From here, the only place we can get is to a game with a value of 1, so this game board also has a value of 1. Now we consider this one over here. What's going to happen now? Well, x needs to make a move. The only move x can make is in the upper left, so x will go there. And in this game, no one wins the game. Nobody has three in a row. And so the value of that game board is 0. Nobody is 1. And so again, by the same logic, if from this board position the only place we can get to is a board where the value is 0, then this state must also have a value of 0. And now here comes the choice part, the idea of trying to minimize. I, as the o player, now know that if I make this choice moving in the upper left, that is going to result in a game with a value of 1, assuming everyone plays optimally. And if I instead play in the lower middle, choose this fork in the road, that is going to result in a game board with a value of 0. I have two options. I have a 1 and a 0 to choose from, and I need to pick. And as the min player, I would rather choose the option with the minimum value. So whenever a player has multiple choices, the min player will choose the option with the smallest value. The max player will choose the option with the largest value. Between the 1 and the 0, the 0 is smaller, meaning I'd rather tie the game than lose the game. And so this game board will say also has a value of 0, because if I am playing optimally, I will pick this fork in the road. I'll place my o here to block x's 3 in a row, x will move in the upper left, and the game will be over, and no one will have won the game. So this is now the logic of minimax, to consider all of the possible options that I can take, all of the actions that I can take, and then to put myself in my opponent's shoes. I decide what move I'm going to make now by considering what move my opponent will make on the next turn. And to do that, I consider what move I would make on the turn after that, so on and so forth, until I get all the way down to the end of the game, to one of these so-called terminal states. In fact, this very decision point, where I am trying to decide as the o player what to make a decision about, might have just been a part of the logic that the x player, my opponent, was using, the move before me. This might be part of some larger tree, where x is trying to make a move in this situation, and needs to pick between three different options in order to make a decision about what to happen. And the further and further away we are from the end of the game, the deeper this tree has to go. Because every level in this tree is going to correspond to one move, one move or action that I take, one move or action that my opponent takes, in order to decide what happens. And in fact, it turns out that if I am the x player in this position, and I recursively do the logic, and see I have a choice, three choices, in fact, one of which leads to a value of 0. If I play here, and if everyone plays optimally, the game will be a tie. If I play here, then o is going to win, and I'll lose playing optimally. Or here, where I, the x player, can win, well between a score of 0, and negative 1, and 1, I'd rather pick the board with a value of 1, because that's the maximum value I can get. And so this board would also have a maximum value of 1. And so this tree can get very, very deep, especially as the game starts to have more and more moves. And this logic works not just for tic-tac-toe, but any of these sorts of games, where I make a move, my opponent makes a move, and ultimately, we have these adversarial objectives. And we can simplify the diagram into a diagram that looks like this. This is a more abstract version of the minimax tree, where these are each states, but I'm no longer representing them as exactly like tic-tac-toe boards. This is just representing some generic game that might be tic-tac-toe, might be some other game altogether. Any of these green arrows that are pointing up, that represents a maximizing state. I would like the score to be as big as possible. And any of these red arrows pointing down, those are minimizing states, where the player is the min player, and they are trying to make the score as small as possible. So if you imagine in this situation, I am the maximizing player, this player here, and I have three choices. One choice gives me a score of 5, one choice gives me a score of 3, and one choice gives me a score of 9. Well, then between those three choices, my best option is to choose this 9 over here, the score that maximizes my options out of all the three options. And so I can give this state a value of 9, because among my three options, that is the best choice that I have available to me. So that's my decision now. You imagine it's like one move away from the end of the game. But then you could also ask a reasonable question, what might my opponent do two moves away from the end of the game? My opponent is the minimizing player. They are trying to make the score as small as possible. Imagine what would have happened if they had to pick which choice to make. One choice leads us to this state, where I, the maximizing player, am going to opt for 9, the biggest score that I can get. And 1 leads to this state, where I, the maximizing player, would choose 8, which is then the largest score that I can get. Now the minimizing player, forced to choose between a 9 or an 8, is going to choose the smallest possible score, which in this case is an 8. And that is then how this process would unfold, that the minimizing player in this case considers both of their options, and then all of the options that would happen as a result of that. So this now is a general picture of what the minimax algorithm looks like. Let's now try to formalize it using a little bit of pseudocode. So what exactly is happening in the minimax algorithm? Well, given a state s, we need to decide what to happen. The max player, if it's max's player's turn, then max is going to pick an action a in actions of s. Recall that actions is a function that takes a state and gives me back all of the possible actions that I can take. It tells me all of the moves that are possible. The max player is going to specifically pick an action a in this set of actions that gives me the highest value of min value of result of s and a. So what does that mean? Well, it means that I want to make the option that gives me the highest score of all of the actions a. But what score is that going to have? To calculate that, I need to know what my opponent, the min player, is going to do if they try to minimize the value of the state that results. So we say, what state results after I take this action? And what happens when the min player tries to minimize the value of that state? I consider that for all of my possible options. And after I've considered that for all of my possible options, I pick the action a that has the highest value. Likewise, the min player is going to do the same thing but backwards. They're also going to consider what are all of the possible actions they can take if it's their turn. And they're going to pick the action a that has the smallest possible value of all the options. And the way they know what the smallest possible value of all the options is is by considering what the max player is going to do by saying, what's the result of applying this action to the current state? And then what would the max player try to do? What value would the max player calculate for that particular state? So everyone makes their decision based on trying to estimate what the other person would do. And now we need to turn our attention to these two functions, max value and min value. How do you actually calculate the value of a state if you're trying to maximize its value? And how do you calculate the value of a state if you're trying to minimize the value? If you can do that, then we have an entire implementation of this min and max algorithm. So let's try it. Let's try and implement this max value function that takes a state and returns as output the value of that state if I'm trying to maximize the value of the state. Well, the first thing I can check for is to see if the game is over. Because if the game is over, in other words, if the state is a terminal state, then this is easy. I already have this utility function that tells me what the value of the board is. If the game is over, I just check, did x win, did o win, is it a tie? And this utility function just knows what the value of the state is. What's trickier is if the game isn't over. Because then I need to do this recursive reasoning about thinking, what is my opponent going to do on the next move? And I want to calculate the value of this state. And I want the value of the state to be as high as possible. And I'll keep track of that value in a variable called v. And if I want the value to be as high as possible, I need to give v an initial value. And initially, I'll just go ahead and set it to be as low as possible. Because I don't know what options are available to me yet. So initially, I'll set v equal to negative infinity, which seems a little bit strange. But the idea here is I want the value initially to be as low as possible. Because as I consider my actions, I'm always going to try and do better than v. And if I set v to negative infinity, I know I can always do better than that. So now I consider my actions. And this is going to be some kind of loop where for every action in actions of state, recall actions as a function that takes my state and gives me all the possible actions that I can use in that state. So for each one of those actions, I want to compare it to v and say, all right, v is going to be equal to the maximum of v and this expression. So what is this expression? Well, first it is get the result of taking the action in the state and then get the min value of that. In other words, let's say I want to find out from that state what is the best that the min player can do because they're going to try and minimize the score. So whatever the resulting score is of the min value of that state, compare it to my current best value and just pick the maximum of those two because I am trying to maximize the value. In short, what these three lines of code are doing are going through all of my possible actions and asking the question, how do I maximize the score given what my opponent is going to try to do? After this entire loop, I can just return v and that is now the value of that particular state. And for the min player, it's the exact opposite of this, the same logic just backwards. To calculate the minimum value of a state, first we check if it's a terminal state. If it is, we return its utility. Otherwise, we're going to now try to minimize the value of the state given all of my possible actions. So I need an initial value for v, the value of the state. And initially, I'll set it to infinity because I know I can always get something less than infinity. So by starting with v equals infinity, I make sure that the very first action I find, that will be less than this value of v. And then I do the same thing, loop over all of my possible actions. And for each of the results that we could get when the max player makes their decision, let's take the minimum of that and the current value of v. So after all is said and done, I get the smallest possible value of v that I then return back to the user. So that, in effect, is the pseudocode for Minimax. That is how we take a gain and figure out what the best move to make is by recursively using these max value and min value functions, where max value calls min value, min value calls max value back and forth, all the way until we reach a terminal state, at which point our algorithm can simply return the utility of that particular state. So what you might imagine is that this is going to start to be a long process, especially as games start to get more complex, as we start to add more moves and more possible options and games that might last quite a bit longer. So the next question to ask is, what sort of optimizations can we make here? How can we do better in order to use less space or take less time to be able to solve this kind of problem? And we'll take a look at a couple of possible optimizations. But for one, we'll take a look at this example. Again, returning to these up arrows and down arrows, let's imagine that I now am the max player, this green arrow. I am trying to make this score as high as possible. And this is an easy game where there are just two moves. I make a move, one of these three options. And then my opponent makes a move, one of these three options, based on what move I make. And as a result, we get some value. Let's look at the order in which I do these calculations and figure out if there are any optimizations I might be able to make to this calculation process. I'm going to have to look at these states one at a time. So let's say I start here on the left and say, all right, now I'm going to consider, what will the min player, my opponent, try to do here? Well, the min player is going to look at all three of their possible actions and look at their value, because these are terminal states. They're the end of the game. And so they'll see, all right, this node is a value of four, value of eight, value of five. And the min player is going to say, well, all right, between these three options, four, eight, and five, I'll take the smallest one. I'll take the four. So this state now has a value of four. Then I, as the max player, say, all right, if I take this action, it will have a value of four. That's the best that I can do, because min player is going to try and minimize my score. So now what if I take this option? We'll explore this next. And now explore what the min player would do if I choose this action. And the min player is going to say, all right, what are the three options? The min player has options between nine, three, and seven. And so three is the smallest among nine, three, and seven. So we'll go ahead and say this state has a value of three. So now I, as the max player, I have now explored two of my three options. I know that one of my options will guarantee me a score of four, at least. And one of my options will guarantee me a score of three. And now I consider my third option and say, all right, what happens here? Same exact logic. The min player is going to look at these three states, two, four, and six. I'll say the minimum possible option is two. So the min player wants the two. Now I, as the max player, have calculated all of the information by looking two layers deep, by looking at all of these nodes. And I can now say, between the four, the three, and the two, you know what? I'd rather take the four. Because if I choose this option, if my opponent plays optimally, they will try and get me to the four. But that's the best I can do. I can't guarantee a higher score. Because if I pick either of these two options, I might get a three or I might get a two. And it's true that down here is a nine. And that's the highest score out of any of the scores. So I might be tempted to say, you know what? Maybe I should take this option because I might get the nine. But if the min player is playing intelligently, if they're making the best moves at each possible option they have when they get to make a choice, I'll be left with a three. Whereas I could better, playing optimally, have guaranteed that I would get the four. So that is, in effect, the logic that I would use as a min and max player trying to maximize my score from that node there. But it turns out they took quite a bit of computation for me to figure that out. I had to reason through all of these nodes in order to draw this conclusion. And this is for a pretty simple game where I have three choices, my opponent has three choices, and then the game's over. So what I'd like to do is come up with some way to optimize this. Maybe I don't need to do all of this calculation to still reach the conclusion that, you know what, this action to the left, that's the best that I could do. Let's go ahead and try again and try to be a little more intelligent about how I go about doing this. So first, I start the exact same way. I don't know what to do initially, so I just have to consider one of the options and consider what the min player might do. Min has three options, four, eight, and five. And between those three options, min says four is the best they can do because they want to try to minimize the score. Now I, the max player, will consider my second option, making this move here, and considering what my opponent would do in response. What will the min player do? Well, the min player is going to, from that state, look at their options. And I would say, all right, nine is an option, three is an option. And if I am doing the math from this initial state, doing all this calculation, when I see a three, that should immediately be a red flag for me. Because when I see a three down here at this state, I know that the value of this state is going to be at most three. It's going to be three or something less than three, even though I haven't yet looked at this last action or even further actions if there were more actions that could be taken here. How do I know that? Well, I know that the min player is going to try to minimize my score. And if they see a three, the only way this could be something other than a three is if this remaining thing that I haven't yet looked at is less than three, which means there is no way for this value to be anything more than three because the min player can already guarantee a three and they are trying to minimize my score. So what does that tell me? Well, it tells me that if I choose this action, my score is going to be three or maybe even less than three if I'm unlucky. But I already know that this action will guarantee me a four. And so given that I know that this action guarantees me a score of four and this action means I can't do better than three, if I'm trying to maximize my options, there is no need for me to consider this triangle here. There is no value, no number that could go here that would change my mind between these two options. I'm always going to opt for this path that gets me a four as opposed to this path where the best I can do is a three if my opponent plays optimally. And this is going to be true for all the future states that I look at too. That if I look over here at what min player might do over here, if I see that this state is a two, I know that this state is at most a two because the only way this value could be something other than two is if one of these remaining states is less than a two and so the min player would opt for that instead. So even without looking at these remaining states, I as the maximizing player can know that choosing this path to the left is going to be better than choosing either of those two paths to the right because this one can't be better than three. This one can't be better than two. And so four in this case is the best that I can do. So in order to do this cut, and I can say now that this state has a value of four. So in order to do this type of calculation, I was doing a little bit more bookkeeping, keeping track of things, keeping track all the time of what is the best that I can do, what is the worst that I can do, and for each of these states saying, all right, well, if I already know that I can get a four, then if the best I can do at this state is a three, no reason for me to consider it, I can effectively prune this leaf and anything below it from the tree. And it's for that reason this approach, this optimization to minimax, is called alpha, beta pruning. Alpha and beta stand for these two values that you'll have to keep track of of the best you can do so far and the worst you can do so far. And pruning is the idea of if I have a big, long, deep search tree, I might be able to search it more efficiently if I don't need to search through everything, if I can remove some of the nodes to try and optimize the way that I look through this entire search space. So alpha, beta pruning can definitely save us a lot of time as we go about the search process by making our searches more efficient. But even then, it's still not great as games get more complex. Tic-tac-toe, fortunately, is a relatively simple game. And we might reasonably ask a question like, how many total possible tic-tac-toe games are there? You can think about it. You can try and estimate how many moves are there at any given point, how many moves long can the game last. It turns out there are about 255,000 possible tic-tac-toe games that can be played. But compare that to a more complex game, something like a game of chess, for example. Far more pieces, far more moves, games that last much longer. How many total possible chess games could there be? It turns out that after just four moves each, four moves by the white player, four moves by the black player, that there are 288 billion possible chess games that can result from that situation, after just four moves each. And going even further, if you look at entire chess games and how many possible chess games there could be as a result there, there are more than 10 to the 29,000 possible chess games, far more chess games than could ever be considered. And this is a pretty big problem for the Minimax algorithm, because the Minimax algorithm starts with an initial state, considers all the possible actions, and all the possible actions after that, all the way until we get to the end of the game. And that's going to be a problem if the computer is going to need to look through this many states, which is far more than any computer could ever do in any reasonable amount of time. So what do we do in order to solve this problem? Instead of looking through all these states which is totally intractable for a computer, we need some better approach. And it turns out that better approach generally takes the form of something called depth-limited Minimax, where normally Minimax is depth-unlimited. We just keep going layer after layer, move after move, until we get to the end of the game. Depth-limited Minimax is instead going to say, you know what, after a certain number of moves, maybe I'll look 10 moves ahead, maybe I'll look 12 moves ahead, but after that point, I'm going to stop and not consider additional moves that might come after that, just because it would be computationally intractable to consider all of those possible options. But what do we do after we get 10 or 12 moves deep when we arrive at a situation where the game's not over? Minimax still needs a way to assign a score to that game board or game state to figure out what its current value is, which is easy to do if the game is over, but not so easy to do if the game is not yet over. So in order to do that, we need to add one additional feature to depth-limited Minimax called an evaluation function, which is just some function that is going to estimate the expected utility of a game from a given state. So in a game like chess, if you imagine that a game value of 1 means white wins, negative 1 means black wins, 0 means it's a draw, then you might imagine that a score of 0.8 means white is very likely to win, though certainly not guaranteed. And you would have an evaluation function that estimates how good the game state happens to be. And depending on how good that evaluation function is, that is ultimately what's going to constrain how good the AI is. The better the AI is at estimating how good or how bad any particular game state is, the better the AI is going to be able to play that game. If the evaluation function is worse and not as good as it estimating what the expected utility is, then it's going to be a whole lot harder. And you can imagine trying to come up with these evaluation functions. In chess, for example, you might write an evaluation function based on how many pieces you have as compared to how many pieces your opponent has, because each one has a value. And your evaluation function probably needs to be a little bit more complicated than that to consider other possible situations that might arise as well. And there are many other variants on Minimax that add additional features in order to help it perform better under these larger, more computationally untractable situations where we couldn't possibly explore all of the possible moves. So we need to figure out how to use evaluation functions and other techniques to be able to play these games ultimately better. But this now was a look at this kind of adversarial search, these search problems where we have situations where I am trying to play against some sort of opponent. And these search problems show up all over the place throughout artificial intelligence. We've been talking a lot today about more classical search problems, like trying to find directions from one location to another. But any time an AI is faced with trying to make a decision, like what do I do now in order to do something that is rational, or do something that is intelligent, or trying to play a game, like figuring out what move to make, these sort of algorithms can really come in handy. It turns out that for tic-tac-toe, the solution is pretty simple because it's a small game. XKCD has famously put together a web comic where he will tell you exactly what move to make as the optimal move to make no matter what your opponent happens to do. This type of thing is not quite as possible for a much larger game like Checkers or Chess, for example, where chess is totally computationally untractable for most computers to be able to explore all the possible states. So we really need our AI to be far more intelligent about how they go about trying to deal with these problems and how they go about taking this environment that they find themselves in and ultimately searching for one of these solutions. So this, then, was a look at search in artificial intelligence. Next time, we'll take a look at knowledge, thinking about how it is that our AIs are able to know information, reason about that information, and draw conclusions, all in our look at AI and the principles behind it. We'll see you next time. ["AIMS INTRO MUSIC"] All right, welcome back, everyone, to an introduction to artificial intelligence with Python. Last time, we took a look at search problems, in particular, where we have AI agents that are trying to solve some sort of problem by taking actions in some sort of environment, whether that environment is trying to take actions by playing moves in a game or whether those actions are something like trying to figure out where to make turns in order to get driving directions from point A to point B. This time, we're going to turn our attention more generally to just this idea of knowledge, the idea that a lot of intelligence is based on knowledge, especially if we think about human intelligence. People know information. We know facts about the world. And using that information that we know, we're able to draw conclusions, reason about the information that we know in order to figure out how to do something or figure out some other piece of information that we conclude based on the information we already have available to us. What we'd like to focus on now is the ability to take this idea of knowledge and being able to reason based on knowledge and apply those ideas to artificial intelligence. In particular, we're going to be building what are known as knowledge-based agents, agents that are able to reason and act by representing knowledge internally. Somehow inside of our AI, they have some understanding of what it means to know something. And ideally, they have some algorithms or some techniques they can use based on that knowledge that they know in order to figure out the solution to a problem or figure out some additional piece of information that can be helpful in some sense. So what do we mean by reasoning based on knowledge to be able to draw conclusions? Well, let's look at a simple example drawn from the world of Harry Potter. We take one sentence that we know to be true. Imagine if it didn't rain, then Harry visited Hagrid today. So one fact that we might know about the world. And then we take another fact. Harry visited Hagrid or Dumbledore today, but not both. So it tells us something about the world, that Harry either visited Hagrid but not Dumbledore, or Harry visited Dumbledore but not Hagrid. And now we have a third piece of information about the world that Harry visited Dumbledore today. So we now have three pieces of information now, three facts. Inside of a knowledge base, so to speak, information that we know. And now we, as humans, can try and reason about this and figure out, based on this information, what additional information can we begin to conclude? And well, looking at these last two statements, Harry either visited Hagrid or Dumbledore but not both, and we know that Harry visited Dumbledore today, well, then it's pretty reasonable that we could draw the conclusion that, you know what, Harry must not have visited Hagrid today. Because based on a combination of these two statements, we can draw this inference, so to speak, a conclusion that Harry did not visit Hagrid today. But it turns out we can even do a little bit better than that, get some more information by taking a look at this first statement and reasoning about that. This first statement says, if it didn't rain, then Harry visited Hagrid today. So what does that mean? In all cases where it didn't rain, then we know that Harry visited Hagrid. But if we also know now that Harry did not visit Hagrid, then that tells us something about our initial premise that we were thinking about. In particular, it tells us that it did rain today, because we can reason, if it didn't rain, that Harry would have visited Hagrid. But we know for a fact that Harry did not visit Hagrid today. So it's this kind of reason, this sort of logical reasoning, where we use logic based on the information that we know in order to take information and reach conclusions that is going to be the focus of what we're going to be talking about today. How can we make our artificial intelligence logical so that they can perform the same kinds of deduction, the same kinds of reasoning that we've been doing so far? Of course, humans reason about logic generally in terms of human language. That I just now was speaking in English, talking in English about these sentences and trying to reason through how it is that they relate to one another. We're going to need to be a little bit more formal when we turn our attention to computers and being able to encode this notion of logic and truthhood and falsehood inside of a machine. So we're going to need to introduce a few more terms and a few symbols that will help us reason through this idea of logic inside of an artificial intelligence. And we'll begin with the idea of a sentence. Now, a sentence in a natural language like English is just something that I'm saying, like what I'm saying right now. In the context of AI, though, a sentence is just an assertion about the world in what we're going to call a knowledge representation language, some way of representing knowledge inside of our computers. And the way that we're going to spend most of today reasoning about knowledge is through a type of logic known as propositional logic. There are a number of different types of logic, some of which we'll touch on. But propositional logic is based on a logic of propositions, or just statements about the world. And so we begin in propositional logic with a notion of propositional symbols. We will have certain symbols that are oftentimes just letters, something like P or Q or R, where each of those symbols is going to represent some fact or sentence about the world. So P, for example, might represent the fact that it is raining. And so P is going to be a symbol that represents that idea. And Q, for example, might represent Harry visited Hagrid today. Each of these propositional symbols represents some sentence or some fact about the world. But in addition to just having individual facts about the world, we want some way to connect these propositional symbols together in order to reason more complexly about other facts that might exist inside of the world in which we're reasoning. So in order to do that, we'll need to introduce some additional symbols that are known as logical connectives. Now, there are a number of these logical connectives. But five of the most important, and the ones we're going to focus on today, are these five up here, each represented by a logical symbol. Not is represented by this symbol here, and is represented as sort of an upside down V, or is represented by a V shape. Implication, and we'll talk about what that means in just a moment, is represented by an arrow. And biconditional, again, we'll talk about what that means in a moment, is represented by these double arrows. But these five logical connectives are the main ones we're going to be focusing on in terms of thinking about how it is that a computer can reason about facts and draw conclusions based on the facts that it knows. But in order to get there, we need to take a look at each of these logical connectives and build up an understanding for what it is that they actually mean. So let's go ahead and begin with the not symbol, so this not symbol here. And what we're going to show for each of these logical connectives is what we're going to call a truth table, a table that demonstrates what this word not means when we attach it to a propositional symbol or any sentence inside of our logical language. And so the truth table for not is shown right here. If P, some propositional symbol, or some other sentence even, is false, then not P is true. And if P is true, then not P is false. So you can imagine that placing this not symbol in front of some sentence of propositional logic just says the opposite of that. So if, for example, P represented it is raining, then not P would represent the idea that it is not raining. And as you might expect, if P is false, meaning if the sentence, it is raining, is false, well then the sentence not P must be true. The sentence that it is not raining is therefore true. So not, you can imagine, just takes whatever is in P and it inverts it. It turns false into true and true into false, much analogously to what the English word not means, just taking whatever comes after it and inverting it to mean the opposite. Next up, and also very English-like, is this idea of and represented by this upside-down V shape or this point shape. And as opposed to just taking a single argument the way not does, we have P and we have not P. And is going to combine two different sentences in propositional logic together. So I might have one sentence P and another sentence Q, and I want to combine them together to say P and Q. And the general logic for what P and Q means is it means that both of its operands are true. P is true and also Q is true. And so here's what that truth table looks like. This time we have two variables, P and Q. And when we have two variables, each of which can be in two possible states, true or false, that leads to two squared or four possible combinations of truth and falsehood. So we have P is false and Q is false. We have P is false and Q is true. P is true and Q is false. And then P and Q both are true. And those are the only four possibilities for what P and Q could mean. And in each of those situations, this third column here, P and Q, is telling us a little bit about what it actually means for P and Q to be true. And we see that the only case where P and Q is true is in this fourth row here, where P happens to be true, Q also happens to be true. And in all other situations, P and Q is going to evaluate to false. So this, again, is much in line with what our intuition of and might mean. If I say P and Q, I probably mean that I expect both P and Q to be true. Next up, also potentially consistent with what we mean, is this word or, represented by this V shape, sort of an upside down and symbol. And or, as the name might suggest, is true if either of its arguments are true, as long as P is true or Q is true, then P or Q is going to be true. Which means the only time that P or Q is false is if both of its operands are false. If P is false and Q is false, then P or Q is going to be false. But in all other cases, at least one of the operands is true. Maybe they're both true, in which case P or Q is going to evaluate to true. Now, this is mostly consistent with the way that most people might use the word or, in the sense of speaking the word or in normal English, though there is sometimes when we might say or, where we mean P or Q, but not both, where we mean, sort of, it can only be one or the other. It's important to note that this symbol here, this or, means P or Q or both, that those are totally OK. As long as either or both of them are true, then the or is going to evaluate to be true, as well. It's only in the case where all of the operands are false that P or Q ultimately evaluates to false, as well. In logic, there's another symbol known as the exclusive or, which encodes this idea of exclusivity of one or the other, but not both. But we're not going to be focusing on that today. Whenever we talk about or, we're always talking about either or both, in this case, as represented by this truth table here. So that now is not an and an or. And next up is what we might call implication, as denoted by this arrow symbol. So we have P and Q. And this sentence here will generally read as P implies Q. And what P implies Q means is that if P is true, then Q is also true. So I might say something like, if it is raining, then I will be indoors. Meaning, it is raining implies I will be indoors, as the logical sentence that I'm saying there. And the truth table for this can sometimes be a little bit tricky. So obviously, if P is true and Q is true, then P implies Q. That's true. That definitely makes sense. And it should also stand to reason that when P is true and Q is false, then P implies Q is false. Because if I said to you, if it is raining, then I will be out indoors. And it is raining, but I'm not indoors? Well, then it would seem to be that my original statement was not true. P implies Q means that if P is true, then Q also needs to be true. And if it's not, well, then the statement is false. What's also worth noting, though, is what happens when P is false. When P is false, the implication makes no claim at all. If I say something like, if it is raining, then I will be indoors. And it turns out it's not raining. Then in that case, I am not making any statement as to whether or not I will be indoors or not. P implies Q just means that if P is true, Q must be true. But if P is not true, then we make no claim about whether or not Q is true at all. So in either case, if P is false, it doesn't matter what Q is. Whether it's false or true, we're not making any claim about Q whatsoever. We can still evaluate the implication to true. The only way that the implication is ever false is if our premise, P, is true, but the conclusion that we're drawing Q happens to be false. So in that case, we would say P does not imply Q in that case. Finally, the last connective that we'll discuss is this bi-conditional. You can think of a bi-conditional as a condition that goes in both directions. So originally, when I said something like, if it is raining, then I will be indoors. I didn't say what would happen if it wasn't raining. Maybe I'll be indoors, maybe I'll be outdoors. This bi-conditional, you can read as an if and only if. So I can say, I will be indoors if and only if it is raining, meaning if it is raining, then I will be indoors. And if I am indoors, it's reasonable to conclude that it is also raining. So this bi-conditional is only true when P and Q are the same. So if P is true and Q is true, then this bi-conditional is also true. P implies Q, but also the reverse is true. Q also implies P. So if P and Q both happen to be false, we would still say it's true. But in any of these other two situations, this P if and only if Q is going to ultimately evaluate to false. So a lot of trues and falses going on there, but these five basic logical connectives are going to form the core of the language of propositional logic, the language that we're going to use in order to describe ideas, and the language that we're going to use in order to reason about those ideas in order to draw conclusions. So let's now take a look at some of the additional terms that we'll need to know about in order to go about trying to form this language of propositional logic and writing AI that's actually able to understand this sort of logic. The next thing we're going to need is the notion of what is actually true about the world. We have a whole bunch of propositional symbols, P and Q and R and maybe others, but we need some way of knowing what actually is true in the world. Is P true or false? Is Q true or false? So on and so forth. And to do that, we'll introduce the notion of a model. A model just assigns a truth value, where a truth value is either true or false, to every propositional symbol. In other words, it's creating what we might call a possible world. So let me give an example. If, for example, I have two propositional symbols, P is it is raining and Q is it is a Tuesday, a model just takes each of these two symbols and assigns a truth value to them, either true or false. So here's a sample model. In this model, in other words, in this possible world, it is possible that P is true, meaning it is raining, and Q is false, meaning it is not a Tuesday. But there are other possible worlds or other models as well. There is some model where both of these variables are true, some model where both of these variables are false. In fact, if there are n variables that are propositional symbols like this that are either true or false, then the number of possible models is 2 to the n, because each of these possible models, possible variables within my model, could be set to either true or false if I don't know any information about it. So now that I have the symbols and the connectives that I'm going to need in order to construct these parts of knowledge, we need some way to represent that knowledge. And to do so, we're going to allow our AI access to what we'll call a knowledge base. And a knowledge base is really just a set of sentences that our AI knows to be true. Some set of sentences in propositional logic that are things that our AI knows about the world. And so we might tell our AI some information, information about a situation that it finds itself in, or a situation about a problem that it happens to be trying to solve. And we would give that information to the AI that the AI would store inside of its knowledge base. And what happens next is the AI would like to use that information in the knowledge base to be able to draw conclusions about the rest of the world. And what do those conclusions look like? Well, to understand those conclusions, we'll need to introduce one more idea, one more symbol. And that is the notion of entailment. So this sentence here, with this double turnstile in these Greek letters, this is the Greek letter alpha and the Greek letter beta. And we read this as alpha entails beta. And alpha and beta here are just sentences in propositional logic. And what this means is that alpha entails beta means that in every model, in other words, in every possible world in which sentence alpha is true, then sentence beta is also true. So if something entails something else, if alpha entails beta, it means that if I know alpha to be true, then beta must therefore also be true. So if my alpha is something like I know that it is a Tuesday in January, then a reasonable beta might be something like I know that it is January. Because in all worlds where it is a Tuesday in January, I know for sure that it must be January, just by definition. This first statement or sentence about the world entails the second statement. And we can reasonably use deduction based on that first sentence to figure out that the second sentence is, in fact, true as well. And ultimately, it's this idea of entailment that we're going to try and encode into our computer. We want our AI agent to be able to figure out what the possible entailments are. We want our AI to be able to take these three sentences, sentences like, if it didn't rain, Harry visited Hagrid. That Harry visited Hagrid or Dumbledore, but not both. And that Harry visited Dumbledore. And just using that information, we'd like our AI to be able to infer or figure out that using these three sentences inside of a knowledge base, we can draw some conclusions. In particular, we can draw the conclusions here that, one, Harry did not visit Hagrid today. And we can draw the entailment, too, that it did, in fact, rain today. And this process is known as inference. And that's what we're going to be focusing on today, this process of deriving new sentences from old ones, that I give you these three sentences, you put them in the knowledge base in, say, the AI. And the AI is able to use some sort of inference algorithm to figure out that these two sentences must also be true. And that is how we define inference. So let's take a look at an inference example to see how we might actually go about inferring things in a human sense before we take a more algorithmic approach to see how we could encode this idea of inference in AI. And we'll see there are a number of ways that we can actually achieve this. So again, we'll deal with a couple of propositional symbols. We'll deal with P, Q, and R. P is it is a Tuesday. Q is it is raining. And R is Harry will go for a run, three propositional symbols that we are just defining to mean this. We're not saying anything yet about whether they're true or false. We're just defining what they are. Now, we'll give ourselves or an AI access to a knowledge base, abbreviated to KB, the knowledge that we know about the world. We know this statement. All right. So let's try to parse it. The parentheses here are just used for precedent, so we can see what associates with what. But you would read this as P and not Q implies R. All right. So what does that mean? Let's put it piece by piece. P is it is a Tuesday. Q is it is raining, so not Q is it is not raining, and implies R is Harry will go for a run. So the way to read this entire sentence in human natural language at least is if it is a Tuesday and it is not raining, then Harry will go for a run. So if it is a Tuesday and it is not raining, then Harry will go for a run. And that is now inside of our knowledge base. And let's now imagine that our knowledge base has two other pieces of information as well. It has information that P is true, that it is a Tuesday. And we also have the information not Q, that it is not raining, that this sentence Q, it is raining, happens to be false. And those are the three sentences that we have access to. P and not Q implies R, P and not Q. Using that information, we should be able to draw some inferences. P and not Q is only true if both P and not Q are true. All right, we know that P is true and we know that not Q is true. So we know that this whole expression is true. And the definition of implication is if this whole thing on the left is true, then this thing on the right must also be true. So if we know that P and not Q is true, then R must be true as well. So the inference we should be able to draw from all of this is that R is true and we know that Harry will go for a run by taking this knowledge inside of our knowledge base and being able to reason based on that idea. And so this ultimately is the beginning of what we might consider to be some sort of inference algorithm, some process that we can use to try and figure out whether or not we can draw some conclusion. And ultimately, what these inference algorithms are going to answer is the central question about entailment. Given some query about the world, something we're wondering about the world, and we'll call that query alpha, the question we want to ask using these inference algorithms is does KB, our knowledge base, entail alpha? In other words, using only the information we know inside of our knowledge base, the knowledge that we have access to, can we conclude that this sentence alpha is true? And that's ultimately what we would like to do. So how can we do that? How can we go about writing an algorithm that can look at this knowledge base and figure out whether or not this query alpha is actually true? Well, it turns out there are a couple of different algorithms for doing so. And one of the simplest, perhaps, is known as model checking. Now, remember that a model is just some assignment of all of the propositional symbols inside of our language to a truth value, true or false. And you can think of a model as a possible world, that there are many possible worlds where different things might be true or false, and we can enumerate all of them. And the model checking algorithm does exactly that. So what does our model checking algorithm do? Well, if we wanted to determine if our knowledge base entails some query alpha, then we are going to enumerate all possible models. In other words, consider all possible values of true and false for our variables, all possible states in which our world can be in. And if in every model where our knowledge base is true, alpha is also true, then we know that the knowledge base entails alpha. So let's take a closer look at that sentence and try and figure out what it actually means. If we know that in every model, in other words, in every possible world, no matter what assignment of true and false to variables you give, if we know that whenever our knowledge is true, what we know to be true is true, that this query alpha is also true, well, then it stands to reason that as long as our knowledge base is true, then alpha must also be true. And so this is going to form the foundation of our model checking algorithm. We're going to enumerate all of the possible worlds and ask ourselves whenever the knowledge base is true, is alpha true? And if that's the case, then we know alpha to be true. And otherwise, there is no entailment. Our knowledge base does not entail alpha. All right. So this is a little bit abstract, but let's take a look at an example to try and put real propositional symbols to this idea. So again, we'll work with the same example. P is it is a Tuesday, Q is it is raining, R as Harry will go for a run. Our knowledge base contains these pieces of information. P and not Q implies R. We also know P. It is a Tuesday and not Q. It is not raining. And our query, our alpha in this case, the thing we want to ask is R. We want to know, is it guaranteed? Is it entailed that Harry will go for a run? So the first step is to enumerate all of the possible models. We have three propositional symbols here, P, Q, and R, which means we have 2 to the third power, or eight possible models. All false, false, false true, false true, false, false true, true, et cetera. Eight possible ways you could assign true and false to all of these models. And we might ask in each one of them, is the knowledge base true? Here are the set of things that we know. In which of these worlds could this knowledge base possibly apply to? In which world is this knowledge base true? Well, in the knowledge base, for example, we know P. We know it is a Tuesday, which means we know that these four first four rows where P is false, none of those are going to be true or are going to work for this particular knowledge base. Our knowledge base is not true in those worlds. Likewise, we also know not Q. We know that it is not raining. So any of these models where Q is true, like these two and these two here, those aren't going to work either because we know that Q is not true. And finally, we also know that P and not Q implies R, which means that when P is true or P is true here and Q is false, Q is false in these two, then R must be true. And if ever P is true, Q is false, but R is also false, well, that doesn't satisfy this implication here. That implication does not hold true under those situations. So we could say that for our knowledge base, we can conclude under which of these possible worlds is our knowledge base true and under which of the possible worlds is our knowledge base false. And it turns out there is only one possible world where our knowledge base is actually true. In some cases, there might be multiple possible worlds where the knowledge base is true. But in this case, it just so happens that there's only one, one possible world where we can definitively say something about our knowledge base. And in this case, we would look at the query. The query of R is R true, R is true, and so as a result, we can draw that conclusion. And so this is this idea of model check-in. Enumerate all the possible models and look in those possible models to see whether or not, if our knowledge base is true, is the query in question true as well. So let's now take a look at how we might actually go about writing this in a programming language like Python. Take a look at some actual code that would encode this notion of propositional symbols and logic and these connectives like and and or and not and implication and so forth and see what that code might actually look like. So I've written in advance a logic library that's more detailed than we need to worry about entirely today. But the important thing is that we have one class for every type of logical symbol or connective that we might have. So we just have one class for logical symbols, for example, where every symbol is going to represent and store some name for that particular symbol. And we also have a class for not that takes an operand. So we might say not one symbol to say something is not true or some other sentence is not true. We have one for and, one for or, so on and so forth. And I'll just demonstrate how this works. And you can take a look at the actual logic.py later on. But I'll go ahead and call this file harry.py. We're going to store information about this world of Harry Potter, for example. So I'll go ahead and import from my logic module. I'll import everything. And in this library, in order to create a symbol, you use capital S symbol. And I'll create a symbol for rain, to mean it is raining, for example. And I'll create a symbol for Hagrid, to mean Harry visited Hagrid, is what this symbol is going to mean. So this symbol means it is raining. This symbol means Harry visited Hagrid. And I'll add another symbol called Dumbledore for Harry visited Dumbledore. Now, I'd like to save these symbols so that I can use them later as I do some logical analysis. So I'll go ahead and save each one of them inside of a variable. So like rain, Hagrid, and Dumbledore, so you could call the variables anything. And now that I have these logical symbols, I can use logical connectives to combine them together. So for example, if I have a sentence like and rain and Hagrid, for example, which is not necessarily true, but just for demonstration, I can now try and print out sentence.formula, which is a function I wrote that takes a sentence in propositional logic and just prints it out so that we, the programmers, can now see this in order to get an understanding for how it actually works. So if I run python harry.py, what we'll see is this sentence in propositional logic, rain and Hagrid. This is the logical representation of what we have here in our Python program of saying and whose arguments are rain and Hagrid. So we're saying rain and Hagrid by encoding that idea. And this is quite common in Python object-oriented programming, where you have a number of different classes, and you pass arguments into them in order to create a new and object, for example, in order to represent this idea. But now what I'd like to do is somehow encode the knowledge that I have about the world in order to solve that problem from the beginning of class, where we talked about trying to figure out who Harry visited and trying to figure out if it's raining or if it's not raining. And so what knowledge do I have? I'll go ahead and create a new variable called knowledge. And what do I know? Well, I know the very first sentence that we talked about was the idea that if it is not raining, then Harry will visit Hagrid. So all right, how do I encode the idea that it is not raining? Well, I can use not and then the rain symbol. So here's me saying that it is not raining. And now the implication is that if it is not raining, then Harry visited Hagrid. So I'll wrap this inside of an implication to say, if it is not raining, this first argument to the implication will then Harry visited Hagrid. So I'm saying implication, the premise is that it's not raining. And if it is not raining, then Harry visited Hagrid. And I can print out knowledge.formula to see the logical formula equivalent of that same idea. So I run Python of harry.py. And this is the logical formula that we see as a result, which is a text-based version of what we were looking at before, that if it is not raining, then that implies that Harry visited Hagrid. But there was additional information that we had access to as well. In this case, we had access to the fact that Harry visited either Hagrid or Dumbledore. So how do I encode that? Well, this means that in my knowledge, I've really got multiple pieces of knowledge going on. I know one thing and another thing and another thing. So I'll go ahead and wrap all of my knowledge inside of an and. And I'll move things on to new lines just for good measure. But I know multiple things. So I'm saying knowledge is an and of multiple different sentences. I know multiple different sentences to be true. One such sentence that I know to be true is this implication, that if it is not raining, then Harry visited Hagrid. Another such sentence that I know to be true is or Hagrid Dumbledore. In other words, Hagrid or Dumbledore is true, because I know that Harry visited Hagrid or Dumbledore. But I know more than that, actually. That initial sentence from before said that Harry visited Hagrid or Dumbledore, but not both. So now I want a sentence that will encode the idea that Harry didn't visit both Hagrid and Dumbledore. Well, the notion of Harry visiting Hagrid and Dumbledore would be represented like this, and of Hagrid and Dumbledore. And if that is not true, if I want to say not that, then I'll just wrap this whole thing inside of a not. So now these three lines, line 8 says that if it is not raining, then Harry visited Hagrid. Line 9 says Harry visited Hagrid or Dumbledore. And line 10 says Harry didn't visit both Hagrid and Dumbledore, that it is not true that both the Hagrid symbol and the Dumbledore symbol are true. Only one of them can be true. And finally, the last piece of information that I knew was the fact that Harry visited Dumbledore. So these now are the pieces of knowledge that I know, one sentence and another sentence and another and another. And I can print out what I know just to see it a little bit more visually. And here now is a logical representation of the information that my computer is now internally representing using these various different Python objects. And again, take a look at logic.py if you want to take a look at how exactly it's implementing this, but no need to worry too much about all of the details there. We're here saying that if it is not raining, then Harry visited Hagrid. We're saying that Hagrid or Dumbledore is true. And we're saying it is not the case that Hagrid and Dumbledore is true, that they're not both true. And we also know that Dumbledore is true. So this long logical sentence represents our knowledge base. It is the thing that we know. And now what we'd like to do is we'd like to use model checking to ask a query, to ask a question like, based on this information, do I know whether or not it's raining? And we as humans were able to logic our way through it and figure out that, all right, based on these sentences, we can conclude this and that to figure out that, yes, it must have been raining. But now we'd like for the computer to do that as well. So let's take a look at the model checking algorithm that is going to follow that same pattern that we drew out in pseudocode a moment ago. So I've defined a function here in logic.py that you can take a look at called model check. Model check takes two arguments, the knowledge that I already know, and the query. And the idea is, in order to do model checking, I need to enumerate all of the possible models. And for each of the possible models, I need to ask myself, is the knowledge base true? And is the query true? So the first thing I need to do is somehow enumerate all of the possible models, meaning for all possible symbols that exist, I need to assign true and false to each one of them and see whether or not it's still true. And so here is the way we're going to do that. We're going to start. So I've defined another helper function internally that we'll get to in just a moment. But this function starts by getting all of the symbols in both the knowledge and the query, by figuring out what symbols am I dealing with. In this case, the symbols I'm dealing with are rain and Hagrid and Dumbledore, but there might be other symbols depending on the problem. And we'll take a look soon at some examples of situations where ultimately we're going to need some additional symbols in order to represent the problem. And then we're going to run this check all function, which is a helper function that's basically going to recursively call itself checking every possible configuration of propositional symbols. So we start out by looking at this check all function. And what do we do? So if not symbols means if we finish assigning all of the symbols. We've assigned every symbol a value. So far we haven't done that, but if we ever do, then we check. In this model, is the knowledge true? That's what this line is saying. If we evaluate the knowledge propositional logic formula using the model's assignment of truth values, is the knowledge true? If the knowledge is true, then we should return true only if the query is true. Because if the knowledge is true, we want the query to be true as well in order for there to be entailment. Otherwise, we don't know that there otherwise there won't be an entailment if there's ever a situation where what we know in our knowledge is true, but the query, the thing we're asking, happens to be false. So this line here is checking that same idea that in all worlds where the knowledge is true, the query must also be true. Otherwise, we can just return true because if the knowledge isn't true, then we don't care. This is equivalent to when we were enumerating this table from a moment ago. In all situations where the knowledge base wasn't true, all of these seven rows here, we didn't care whether or not our query was true or not. We only care to check whether the query is true when the knowledge base is actually true, which was just this green highlighted row right there. So that logic is encoded using that statement there. And otherwise, if we haven't assigned symbols yet, which we haven't seen anything yet, then the first thing we do is pop one of the symbols. I make a copy of the symbols first just to save an existing copy. But I pop one symbol off of the remaining symbols so that I just pick one symbol at random. And I create one copy of the model where that symbol is true. And I create a second copy of the model where that symbol is false. So I now have two copies of the model, one where the symbol is true and one where the symbol is false. And I need to make sure that this entailment holds in both of those models. So I recursively check all on the model where the statement is true and check all on the model where the statement is false. So again, you can take a look at that function to try to get a sense for how exactly this logic is working. But in effect, what it's doing is recursively calling this check all function again and again and again. And on every level of the recursion, we're saying let's pick a new symbol that we haven't yet assigned, assign it to true and assign it to false, and then check to make sure that the entailment holds in both cases. Because ultimately, I need to check every possible world. I need to take every combination of symbols and try every combination of true and false in order to figure out whether the entailment relation actually holds. So that function we've written for you. But in order to use that function inside of harry.py, what I'll write is something like this. I would like to model check based on the knowledge. And then I provide as a second argument what the query is, what the thing I want to ask is. And what I want to ask in this case is, is it raining? So model check again takes two arguments. The first argument is the information that I know, this knowledge, which in this case is this information that was given to me at the beginning. And the second argument, rain, is encoding the idea of the query. What am I asking? I would like to ask, based on this knowledge, do I know for sure that it is raining? And I can try and print out the result of that. And when I run this program, I see that the answer is true. That based on this information, I can conclusively say that it is raining, because using this model checking algorithm, we were able to check that in every world where this knowledge is true, it is raining. In other words, there is no world where this knowledge is true, and it is not raining. So you can conclude that it is, in fact, raining. And this sort of logic can be applied to a number of different types of problems, that if confronted with a problem where some sort of logical deduction can be used in order to try to solve it, you might try thinking about what propositional symbols you might need in order to represent that information, and what statements and propositional logic you might use in order to encode that information which you know. And this process of trying to take a problem and figure out what propositional symbols to use in order to encode that idea, or how to represent it logically, is known as knowledge engineering. That software engineers and AI engineers will take a problem and try and figure out how to distill it down into knowledge that is representable by a computer. And if we can take any general purpose problem, some problem that we find in the human world, and turn it into a problem that computers know how to solve as by using any number of different variables, well, then we can take a computer that is able to do something like model checking or some other inference algorithm and actually figure out how to solve that problem. So now we'll take a look at two or three examples of knowledge engineering and practice, of taking some problem and figuring out how we can apply logical symbols and use logical formulas to be able to encode that idea. And we'll start with a very popular board game in the US and the UK known as Clue. Now, in the game of Clue, there's a number of different factors that are going on. But the basic premise of the game, if you've never played it before, is that there are a number of different people. For now, we'll just use three, Colonel Mustard, Professor Plumb, and Miss Scarlet. There are a number of different rooms, like a ballroom, a kitchen, and a library. And there are a number of different weapons, a knife, a revolver, and a wrench. And three of these, one person, one room, and one weapon, is the solution to the mystery, the murderer and what room they were in and what weapon they happened to use. And what happens at the beginning of the game is that all these cards are randomly shuffled together. And three of them, one person, one room, and one weapon, are placed into a sealed envelope that we don't know. And we would like to figure out, using some sort of logical process, what's inside the envelope, which person, which room, and which weapon. And we do so by looking at some, but not all, of these cards here, by looking at these cards to try and figure out what might be going on. And so this is a very popular game. But let's now try and formalize it and see if we could train a computer to be able to play this game by reasoning through it logically. So in order to do this, we'll begin by thinking about what propositional symbols we're ultimately going to need. Remember, again, that propositional symbols are just some symbol, some variable, that can be either true or false in the world. And so in this case, the propositional symbols are really just going to correspond to each of the possible things that could be inside the envelope. Mustard is a propositional symbol that, in this case, will just be true if Colonel Mustard is inside the envelope, if he is the murderer, and false otherwise. And likewise for Plum, for Professor Plum, and Scarlet, for Miss Scarlet. And likewise for each of the rooms and for each of the weapons. We have one propositional symbol for each of these ideas. Then using those propositional symbols, we can begin to create logical sentences, create knowledge that we know about the world. So for example, we know that someone is the murderer, that one of the three people is, in fact, the murderer. And how would we encode that? Well, we don't know for sure who the murderer is. But we know it is one person or the second person or the third person. So I could say something like this. Mustard or Plum or Scarlet. And this piece of knowledge encodes that one of these three people is the murderer. We don't know which, but one of these three things must be true. What other information do we know? Well, we know that, for example, one of the rooms must have been the room in the envelope. The crime was committed either in the ballroom or the kitchen or the library. Again, right now, we don't know which. But this is knowledge we know at the outset, knowledge that one of these three must be inside the envelope. And likewise, we can say the same thing about the weapon, that it was either the knife or the revolver or the wrench, that one of those weapons must have been the weapon of choice and therefore the weapon in the envelope. And then as the game progresses, the gameplay works by people get various different cards. And using those cards, you can deduce information. That if someone gives you a card, for example, I have the Professor Plum card in my hand, then I know the Professor Plum card can't be inside the envelope. I know that Professor Plum is not the criminal, so I know a piece of information like not Plum, for example. I know that Professor Plum has to be false. This propositional symbol is not true. And sometimes I might not know for sure that a particular card is not in the middle, but sometimes someone will make a guess and I'll know that one of three possibilities is not true. Someone will guess Colonel Mustard in the library with the revolver or something to that effect. And in that case, a card might be revealed that I don't see. But if it is a card and it is either Colonel Mustard or the revolver or the library, then I know that at least one of them can't be in the middle. So I know something like it is either not Mustard or it is not the library or it is not the revolver. Now maybe multiple of these are not true, but I know that at least one of Mustard, Library, and Revolver must, in fact, be false. And so this now is a propositional logic representation of this game of Clue, a way of encoding the knowledge that we know inside this game using propositional logic that a computer algorithm, something like model checking that we saw a moment ago, can actually look at and understand. So let's now take a look at some code to see how this algorithm might actually work in practice. All right, so I'm now going to open up a file called Clue.py, which I've started already. And what we'll see here is I've defined a couple of things. To find some symbols initially, notice I have a symbol for Colonel Mustard, a symbol for Professor Plum, a symbol for Miss Scarlett, all of which I've put inside of this list of characters. I have a symbol for Ballroom and Kitchen and Library inside of a list of rooms. And then I have symbols for Knife and Revolver and Wrench. These are my weapons. And so all of these characters and rooms and weapons altogether, those are my symbols. And now I also have this check knowledge function. And what the check knowledge function does is it takes my knowledge and it's going to try and draw conclusions about what I know. So for example, we'll loop over all of the possible symbols and we'll check, do I know that that symbol is true? And a symbol is going to be something like Professor Plum or the Knife or the Library. And if I know that it is true, in other words, I know that it must be the card in the envelope, then I'm going to print out using a function called cprint, which prints things in color. I'm going to print out the word yes, and I'm going to print that in green, just to make it very clear to us. If we're not sure that the symbol is true, maybe I can check to see if I'm sure that the symbol is not true. Like if I know for sure that it is not Professor Plum, for example. And I do that by running model check again, this time checking if my knowledge is not the symbol, if I know for sure that the symbol is not true. And if I don't know for sure that the symbol is not true, because I say if not model check, meaning I'm not sure that the symbol is false, well, then I'll go ahead and print out maybe next to the symbol. Because maybe the symbol is true, maybe it's not, I don't actually know. So what knowledge do I actually have? Well, let's try and represent my knowledge now. So my knowledge is, I know a couple of things, so I'll put them in an and. And I know that one of the three people must be the criminal. So I know or mustard, plum, scarlet. This is my way of encoding that it is either Colonel Mustard or Professor Plum or Miss Scarlet. I know that it must have happened in one of the rooms. So I know or ballroom, kitchen, library, for example. And I know that one of the weapons must have been used as well. So I know or knife, revolver, wrench. So that might be my initial knowledge, that I know that it must have been one of the people, I know it must have been in one of the rooms, and I know that it must have been one of the weapons. And I can see what that knowledge looks like as a formula by printing out knowledge.formula. So I'll run python clue.py. And here now is the information that I know in logical format. I know that it is Colonel Mustard or Professor Plum or Miss Scarlet. And I know that it is the ballroom, the kitchen, or the library. And I know that it is the knife, the revolver, or the wrench. But I don't know much more than that. I can't really draw any firm conclusions. And in fact, we can see that if I try and do, let me go ahead and run my knowledge check function on my knowledge. Knowledge check is this function that I, or check knowledge rather, is this function that I just wrote that looks over all of the symbols and tries to see what conclusions I can actually draw about any of the symbols. So I'll go ahead and run clue.py and see what it is that I know. And it seems that I don't really know anything for sure. I have all three people are maybes, all three of the rooms are maybes, all three of the weapons are maybes. I don't really know anything for certain just yet. But now let me try and add some additional information and see if additional information, additional knowledge, can help us to logically reason our way through this process. And we are just going to provide the information. Our AI is going to take care of doing the inference and figuring out what conclusions it's able to draw. So I start with some cards. And those cards tell me something. So if I have the kernel mustard card, for example, I know that the mustard symbol must be false. In other words, mustard is not the one in the envelope, is not the criminal. So I can say, knowledge supports something called, every and in this library supports dot add, which is a way of adding knowledge or adding an additional logical sentence to an and clause. So I can say, knowledge dot add, not mustard. I happen to know, because I have the mustard card, that kernel mustard is not the suspect. And maybe I have a couple of other cards too. Maybe I also have a card for the kitchen. So I know it's not the kitchen. And maybe I have another card that says that it is not the revolver. So I have three cards, kernel mustard, the kitchen, and the revolver. And I encode that into my AI this way by saying, it's not kernel mustard, it's not the kitchen, and it's not the revolver. And I know those to be true. So now, when I rerun clue.py, we'll see that I've been able to eliminate some possibilities. Before, I wasn't sure if it was the knife or the revolver or the wrench. If a knife was maybe, a revolver was maybe, wrench is maybe. Now I'm down to just the knife and the wrench. Between those two, I don't know which one it is. They're both maybes. But I've been able to eliminate the revolver, which is one that I know to be false, because I have the revolver card. And so additional information might be acquired over the course of this game. And we would represent that just by adding knowledge to our knowledge set or knowledge base that we've been building here. So if, for example, we additionally got the information that someone made a guess, someone guessed like Miss Scarlet in the library with the wrench. And we know that a card was revealed, which means that one of those three cards, either Miss Scarlet or the library or the wrench, one of those at minimum must not be inside of the envelope. So I could add some knowledge, say knowledge.add. And I'm going to add an or clause, because I don't know for sure which one it's not, but I know one of them is not in the envelope. So it's either not Scarlet, or it's not the library, and or supports multiple arguments. I can say it's also or not the wrench. So at least one of those needs a Scarlet library and wrench. At least one of those needs to be false. I don't know which, though. Maybe it's multiple. Maybe it's just one, but at least one I know needs to hold. And so now if I rerun clue.py, I don't actually have any additional information just yet. Nothing I can say conclusively. I still know that maybe it's Professor Plum, maybe it's Miss Scarlet. I haven't eliminated any options. But let's imagine that I get some more information, that someone shows me the Professor Plum card, for example. So I say, all right, let's go back here, knowledge.add, not Plum. So I have the Professor Plum card. I know the Professor Plum is not in the middle. I rerun clue.py. And right now, I'm able to draw some conclusions. Now I've been able to eliminate Professor Plum, and the only person it could left remaining be is Miss Scarlet. So I know, yes, Miss Scarlet, this variable must be true. And I've been able to infer that based on the information I already had. Now between the ballroom and the library and the knife and the wrench, for those two, I'm still not sure. So let's add one more piece of information. Let's say that I know that it's not the ballroom. Someone has shown me the ballroom card, so I know it's not the ballroom. Which means at this point, I should be able to conclude that it's the library. Let's see. I'll say knowledge.add, not the ballroom. And we'll go ahead and run that. And it turns out that after all of this, not only can I conclude that I know that it's the library, but I also know that the weapon was the knife. And that might have been an inference that was a little bit trickier, something I wouldn't have realized immediately, but the AI, via this model checking algorithm, is able to draw that conclusion, that we know for sure that it must be Miss Scarlet in the library with the knife. And how did we know that? Well, we know it from this or clause up here, that we know that it's either not Scarlet, or it's not the library, or it's not the wrench. And given that we know that it is Miss Scarlet, and we know that it is the library, then the only remaining option for the weapon is that it is not the wrench, which means that it must be the knife. So we as humans now can go back and reason through that, even though it might not have been immediately clear. And that's one of the advantages of using an AI or some sort of algorithm in order to do this, is that the computer can exhaust all of these possibilities and try and figure out what the solution actually should be. And so for that reason, it's often helpful to be able to represent knowledge in this way. Knowledge engineering, some situation where we can use a computer to be able to represent knowledge and draw conclusions based on that knowledge. And any time we can translate something into propositional logic symbols like this, this type of approach can be useful. So you might be familiar with logic puzzles, where you have to puzzle your way through trying to figure something out. This is what a classic logic puzzle might look like. Something like Gilderoy, Minerva, Pomona, and Horace each belong to a different one of the four houses, Gryffindor, Hufflepuff, Ravenclaw, and Slytherin. And then we have some information. The Gilderoy belongs to Gryffindor or Ravenclaw, Pomona does not belong in Slytherin, and Minerva does belong to Gryffindor. So we have a couple pieces of information. And using that information, we need to be able to draw some conclusions about which person should be assigned to which house. And again, we can use the exact same idea to try and implement this notion. So we need some propositional symbols. And in this case, the propositional symbols are going to get a little more complex, although we'll see ways to make this a little bit cleaner later on. But we'll need 16 propositional symbols, one for each person and house. So we need to say, remember, every propositional symbol is either true or false. So Gilderoy Gryffindor is either true or false. Either he's in Gryffindor or he is not. Likewise, Gilderoy Hufflepuff also true or false. Either it is true or it's false. And that's true for every combination of person and house that we could come up with. We have some sort of propositional symbol for each one of those. Using this type of knowledge, we can then begin to think about what types of logical sentences we can say about the puzzle. That if we know what will before even think about the information we were given, we can think about the premise of the problem, that every person is assigned to a different house. So what does that tell us? Well, it tells us sentences like this. It tells us like Pomona Slytherin implies not Pomona Hufflepuff. Something like if Pomona is in Slytherin, then we know that Pomona is not in Hufflepuff. And we know this for all four people and for all combinations of houses, that no matter what person you pick, if they're in one house, then they're not in some other house. So I'll probably have a whole bunch of knowledge statements that are of this form, that if we know Pomona is in Slytherin, then we know Pomona is not in Hufflepuff. We were also given the information that each person is in a different house. So I also have pieces of knowledge that look something like this. Minerva Ravenclaw implies not Gilderoy Ravenclaw. If they're all in different houses, then if Minerva is in Ravenclaw, then we know the Gilderoy is not in Ravenclaw as well. And I have a whole bunch of similar sentences like this that are expressing that idea for other people and other houses as well. And so in addition to sentences of these form, I also have the knowledge that was given to me. Information like Gilderoy was in Gryffindor or in Ravenclaw that would be represented like this, Gilderoy Gryffindor or Gilderoy Ravenclaw. And then using these sorts of sentences, I can begin to draw some conclusions about the world. So let's see an example of this. We'll go ahead and actually try and implement this logic puzzle to see if we can figure out what the answer is. I'll go ahead and open up puzzle.py, where I've already started to implement this sort of idea. I've defined a list of people and a list of houses. And I've so far created one symbol for every person and for every house. That's what this double four loop is doing, looping over all people, looping over all houses, creating a new symbol for each of them. And then I've added some information. I know that every person belongs to a house, so I've added the information for every person that person Gryffindor or person Hufflepuff or person Ravenclaw or person Slytherin, that one of those four things must be true. Every person belongs to a house. What other information do I know? I also know that only one house per person, so no person belongs to multiple houses. So how does this work? Well, this is going to be true for all people. So I'll loop over every person. And then I need to loop over all different pairs of houses. The idea is I want to encode the idea that if Minerva is in Gryffindor, then Minerva can't be in Ravenclaw. So I'll loop over all houses, each one. And I'll loop over all houses again, h2. And as long as they're different, h1 not equal to h2, then I'll add to my knowledge base this piece of information. That implication, in other words, an if then, if the person is in h1, then I know that they are not in house h2. So these lines here are encoding the notion that for every person, if they belong to house one, then they are not in house two. And the other piece of logic we need to encode is the idea that every house can only have one person. In other words, if Pomona is in Hufflepuff, then nobody else is allowed to be in Hufflepuff either. And that's the same logic, but sort of backwards. I loop over all of the houses and loop over all different pairs of people. So I loop over people once, loop over people again, and only do this when the people are different, p1 not equal to p2. And I add the knowledge that if, as given by the implication, if person one belongs to the house, then it is not the case that person two belongs to the same house. So here I'm just encoding the knowledge that represents the problem's constraints. I know that everyone's in a different house. I know that any person can only belong to one house. And I can now take my knowledge and try and print out the information that I happen to know. So I'll go ahead and print out knowledge.formula, just to see this in action, and I'll go ahead and skip this for now. But we'll come back to this in a second. Let's print out the knowledge that I know by running Python puzzle.py. It's a lot of information, a lot that I have to scroll through, because there are 16 different variables all going on. But the basic idea, if we scroll up to the very top, is I see my initial information. Gilderoy is either in Gryffindor, or Gilderoy is in Hufflepuff, or Gilderoy is in Ravenclaw, or Gilderoy is in Slytherin, and then way more information as well. So this is quite messy, more than we really want to be looking at. And soon, too, we'll see ways of representing this a little bit more nicely using logic. But for now, we can just say these are the variables that we're dealing with. And now we'd like to add some information. So the information we're going to add is Gilderoy is in Gryffindor, or he is in Ravenclaw. So that knowledge was given to us. So I'll go ahead and say knowledge.add. And I know that either or Gilderoy Gryffindor or Gilderoy Ravenclaw. One of those two things must be true. I also know that Pomona was not in Slytherin, so I can say knowledge.add not this symbol, not the Pomona-Slytherin symbol. And then I can add the knowledge that Minerva is in Gryffindor by adding the symbol Minerva Gryffindor. So those are the pieces of knowledge that I know. And this loop here at the bottom just loops over all of my symbols, checks to see if the knowledge entails that symbol by calling this model check function again. And if it does, if we know the symbol is true, we print out the symbol. So now I can run Python, puzzle.py, and Python is going to solve this puzzle for me. We're able to conclude that Gilderoy belongs to Ravenclaw, Pomona belongs to Hufflepuff, Minerva to Gryffindor, and Horace to Slytherin just by encoding this knowledge inside the computer, although it was quite tedious to do in this case. And as a result, we were able to get the conclusion from that as well. And you can imagine this being applied to many sorts of different deductive situations. So not only these situations where we're trying to deal with Harry Potter characters in this puzzle, but if you've ever played games like Mastermind, where you're trying to figure out which order different colors go in and trying to make predictions about it, I could tell you, for example, let's play a simplified version of Mastermind where there are four colors, red, blue, green, and yellow, and they're in some order, but I'm not telling you what order. You just have to make a guess, and I'll tell you of red, blue, green, and yellow how many of the four you got in the right position. So a simplified version of this game, you might make a guess like red, blue, green, yellow, and I would tell you something like two of those four are in the correct position, but the other two are not. And then you could reasonably make a guess and say, all right, look at this, blue, red, green, yellow. Try switching two of them around, and this time maybe I tell you, you know what, none of those are in the correct position. And the question then is, all right, what is the correct order of these four colors? And we as humans could begin to reason this through. All right, well, if none of these were correct, but two of these were correct, well, it must have been because I switched the red and the blue, which means red and blue here must be correct, which means green and yellow are probably not correct. You can begin to do this sort of deductive reasoning. And we can also equivalently try and take this and encode it inside of our computer as well. And it's going to be very similar to the logic puzzle that we just did a moment ago. So I won't spend too much time on this code because it is fairly similar. But again, we have a whole bunch of colors and four different positions in which those colors can be. And then we have some additional knowledge. And I encode all of that knowledge. And you can take a look at this code on your own time. But I just want to demonstrate that when we run this code, run python mastermind.py and run and see what we get, we ultimately are able to compute red 0 in the 0 position, blue in the 1 position, yellow in the 2 position, and green in the 3 position as the ordering of those symbols. Now, ultimately, what you might have noticed is this process was taking quite a long time. And in fact, model checking is not a particularly efficient algorithm, right? What I need to do in order to model check is take all of my possible different variables and enumerate all of the possibilities that they could be in. If I have n variables, I have 2 to the n possible worlds that I need to be looking through in order to perform this model checking algorithm. And this is probably not tractable, especially as we start to get to much larger and larger sets of data where you have many, many more variables that are at play. Right here, we only have a relatively small number of variables. So this sort of approach can actually work. But as the number of variables increases, model checking becomes less and less good of a way of trying to solve these sorts of problems. So while it might have been OK for something like Mastermind to conclude that this is indeed the correct sequence where all four are in the correct position, what we'd like to do is come up with some better ways to be able to make inferences rather than just enumerate all of the possibilities. And to do so, what we'll transition to next is the idea of inference rules, some sort of rules that we can apply to take knowledge that already exists and translate it into new forms of knowledge. And the general way we'll structure an inference rule is by having a horizontal line here. Anything above the line is going to represent a premise, something that we know to be true. And then anything below the line will be the conclusion that we can arrive at after we apply the logic from the inference rule that we're going to demonstrate. So we'll do some of these inference rules by demonstrating them in English first, but then translating them into the world of propositional logic so you can see what those inference rules actually look like. So for example, let's imagine that I have access to two pieces of information. I know, for example, that if it is raining, then Harry is inside, for example. And let's say I also know it is raining. Then most of us could reasonably then look at this information and conclude that, all right, Harry must be inside. This inference rule is known as modus ponens, and it's phrased more formally in logic as this. If we know that alpha implies beta, in other words, if alpha, then beta, and we also know that alpha is true, then we should be able to conclude that beta is also true. We can apply this inference rule to take these two pieces of information and generate this new piece of information. Notice that this is a totally different approach from the model checking approach, where the approach was look at all of the possible worlds and see what's true in each of these worlds. Here, we're not dealing with any specific world. We're just dealing with the knowledge that we know and what conclusions we can arrive at based on that knowledge. That I know that A implies B, and I know A, and the conclusion is B. And this should seem like a relatively obvious rule. But of course, if alpha, then beta, and we know alpha, then we should be able to conclude that beta is also true. And that's going to be true for many, but maybe even all of the inference rules that we'll take a look at. You should be able to look at them and say, yeah, of course that's going to be true. But it's putting these all together, figuring out the right combination of inference rules that can be applied that ultimately is going to allow us to generate interesting knowledge inside of our AI. So that's modus ponensis application of implication, that if we know alpha and we know that alpha implies beta, then we can conclude beta. Let's take a look at another example. Fairly straightforward, something like Harry is friends with Ron and Hermione. Based on that information, we can reasonably conclude Harry is friends with Hermione. That must also be true. And this inference rule is known as and elimination. And what and elimination says is that if we have a situation where alpha and beta are both true, I have information alpha and beta, well then, just alpha is true. Or likewise, just beta is true. That if I know that both parts are true, then one of those parts must also be true. Again, something obvious from the point of view of human intuition, but a computer needs to be told this kind of information. To be able to apply the inference rule, we need to tell the computer that this is an inference rule that you can apply, so the computer has access to it and is able to use it in order to translate information from one form to another. In addition to that, let's take a look at another example of an inference rule, something like it is not true that Harry did not pass the test. Bit of a tricky sentence to parse. I'll read it again. It is not true, or it is false, that Harry did not pass the test. Well, if it is false that Harry did not pass the test, then the only reasonable conclusion is that Harry did pass the test. And so this, instead of being and elimination, is what we call double negation elimination. That if we have two negatives inside of our premise, then we can just remove them altogether. They cancel each other out. One turns true to false, and the other one turns false back into true. Phrased a little bit more formally, we say that if the premise is not alpha, then the conclusion we can draw is just alpha. We can say that alpha is true. We'll take a look at a couple more of these. If I have it is raining, then Harry is inside. How do I reframe this? Well, this one is a little bit trickier. But if I know if it is raining, then Harry is inside, then I conclude one of two things must be true. Either it is not raining, or Harry is inside. Now, this one's trickier. So let's think about it a little bit. This first premise here, if it is raining, then Harry is inside, is saying that if I know that it is raining, then Harry must be inside. So what is the other possible case? Well, if Harry is not inside, then I know that it must not be raining. So one of those two situations must be true. Either it's not raining, or it is raining, in which case Harry is inside. So the conclusion I can draw is either it is not raining, or it is raining, so therefore, Harry is inside. And so this is a way to translate if-then statements into or statements. And this is known as implication elimination. And this is similar to what we actually did in the beginning when we were first looking at those very first sentences about Harry and Hagrid and Dumbledore. And phrased a little bit more formally, this says that if I have the implication, alpha implies beta, that I can draw the conclusion that either not alpha or beta, because there are only two possibilities. Either alpha is true or alpha is not true. So one of those possibilities is alpha is not true. But if alpha is true, well, then we can draw the conclusion that beta must be true. So either alpha is not true or alpha is true, in which case beta is also true. So this is one way to turn an implication into just a statement about or. In addition to eliminating implications, we can also eliminate biconditionals as well. So let's take an English example, something like, it is raining if and only if Harry is inside. And this if and only if really sounds like that biconditional, that double arrow sign that we saw in propositional logic not too long ago. And what does this actually mean if we were to translate this? Well, this means that if it is raining, then Harry is inside. And if Harry is inside, then it is raining, that this implication goes both ways. And this is what we would call biconditional elimination, that I can take a biconditional, a if and only if b, and translate that into something like this, a implies b, and b implies a. So many of these inference rules are taking logic that uses certain symbols and turning them into different symbols, taking an implication and turning it into an or, or taking a biconditional and turning it into implication. And another example of it would be something like this. It is not true that both Harry and Ron passed the test. Well, all right, how do we translate that? What does that mean? Well, if it is not true that both of them passed the test, well, then the reasonable conclusion we might draw is that at least one of them didn't pass the test. So the conclusion is either Harry did not pass the test or Ron did not pass the test, or both. This is not an exclusive or. But if it is true that it is not true that both Harry and Ron passed the test, well, then either Harry didn't pass the test or Ron didn't pass the test. And this type of law is one of De Morgan's laws. Quite famous in logic where the idea is that we can turn an and into an or. We can say we can take this and that both Harry and Ron passed the test and turn it into an or by moving the nots around. So if it is not true that Harry and Ron passed the test, well, then either Harry did not pass the test or Ron did not pass the test either. And the way we frame that more formally using logic is to say this. If it is not true that alpha and beta, well, then either not alpha or not beta. The way I like to think about this is that if you have a negation in front of an and expression, you move the negation inwards, so to speak, moving the negation into each of these individual sentences and then flip the and into an or. So the negation moves inwards and the and flips into an or. So I go from not a and b to not a or not b. And there's actually a reverse of De Morgan's law that goes in the other direction for something like this. If I say it is not true that Harry or Ron passed the test, meaning neither of them passed the test, well, then the conclusion I can draw is that Harry did not pass the test and Ron did not pass the test. So in this case, instead of turning an and into an or, we're turning an or into an and. But the idea is the same. And this, again, is another example of De Morgan's laws. And the way that works is that if I have not a or b this time, the same logic is going to apply. I'm going to move the negation inwards. And I'm going to flip this time, flip the or into an and. So if not a or b, meaning it is not true that a or b or alpha or beta, then I can say not alpha and not beta, moving the negation inwards in order to make that conclusion. So those are De Morgan's laws and a couple other inference rules that are worth just taking a look at. One is the distributive law that works this way. So if I have alpha and beta or gamma, well, then much in the same way that you can use in math, use distributive laws to distribute operands like addition and multiplication, I can do a similar thing here, where I can say if alpha and beta or gamma, then I can say something like alpha and beta or alpha and gamma, that I've been able to distribute this and sign throughout this expression. So this is an example of the distributive property or the distributive law as applied to logic in much the same way that you would distribute a multiplication over the addition of something, for example. This works the other way too. So if, for example, I have alpha or beta and gamma, I can distribute the or throughout the expression. I can say alpha or beta and alpha or gamma. So the distributive law works in that way too. And it's helpful if I want to take an or and move it into the expression. And we'll see an example soon of why it is that we might actually care to do something like that. All right, so now we've seen a lot of different inference rules. And the question now is, how can we use those inference rules to actually try and draw some conclusions, to actually try and prove something about entailment, proving that given some initial knowledge base, we would like to find some way to prove that a query is true? Well, one way to think about it is actually to think back to what we talked about last time when we talked about search problems. Recall again that search problems have some sort of initial state. They have actions that you can take from one state to another as defined by a transition model that tells you how to get from one state to another. We talked about testing to see if you were at a goal. And then some path cost function to see how many steps did you have to take or how costly was the solution that you found. Now that we have these inference rules that take some set of sentences in propositional logic and get us some new set of sentences in propositional logic, we can actually treat those sentences or those sets of sentences as states inside of a search problem. So if we want to prove that some query is true, prove that some logical theorem is true, we can treat theorem proving as a form of a search problem. I can say that we begin in some initial state, where that initial state is the knowledge base that I begin with, the set of all of the sentences that I know to be true. What actions are available to me? Well, the actions are any of the inference rules that I can apply at any given time. The transition model just tells me after I apply the inference rule, here is the new set of all of the knowledge that I have, which will be the old set of knowledge, plus some additional inference that I've been able to draw, much as in the same way we saw what we got when we applied those inference rules and got some sort of conclusion. That conclusion gets added to our knowledge base, and our transition model will encode that. What is the goal test? Well, our goal test is checking to see if we have proved the statement we're trying to prove, if the thing we're trying to prove is inside of our knowledge base. And the path cost function, the thing we're trying to minimize, is maybe the number of inference rules that we needed to use, the number of steps, so to speak, inside of our proof. And so here we've been able to apply the same types of ideas that we saw last time with search problems to something like trying to prove something about knowledge by taking our knowledge and framing it in terms that we can understand as a search problem with an initial state, with actions, with a transition model. So this shows a couple of things, one being how versatile search problems are, that they can be the same types of algorithms that we use to solve a maze or figure out how to get from point A to point B inside of driving directions, for example, can also be used as a theorem proving method of taking some sort of starting knowledge base and trying to prove something about that knowledge. So this, yet again, is a second way, in addition to model checking, to try and prove that certain statements are true. But it turns out there's yet another way that we can try and apply inference. And we'll talk about this now, which is not the only way, but certainly one of the most common, which is known as resolution. And resolution is based on another inference rule that we'll take a look at now, quite a powerful inference rule that will let us prove anything that can be proven about a knowledge base. And it's based on this basic idea. Let's say I know that either Ron is in the Great Hall or Hermione is in the library. And let's say I also know that Ron is not in the Great Hall. Based on those two pieces of information, what can I conclude? Well, I could pretty reasonably conclude that Hermione must be in the library. How do I know that? Well, it's because these two statements, these two what we'll call complementary literals, literals that complement each other, they're opposites of each other, seem to conflict with each other. This sentence tells us that either Ron is in the Great Hall or Hermione is in the library. So if we know that Ron is not in the Great Hall, that conflicts with this one, which means Hermione must be in the library. And this we can frame as a more general rule known as the unit resolution rule, a rule that says that if we have p or q and we also know not p, well then from that we can reasonably conclude q. That if p or q are true and we know that p is not true, the only possibility is for q to then be true. And this, it turns out, is quite a powerful inference rule in terms of what it can do, in part because we can quickly start to generalize this rule. This q right here doesn't need to just be a single propositional symbol. It could be multiple, all chained together in a single clause, as we'll call it. So if I had something like p or q1 or q2 or q3, so on and so forth, up until qn, so I had n different other variables, and I have not p, well then what happens when these two complement each other is that these two clauses resolve, so to speak, to produce a new clause that is just q1 or q2 all the way up to qn. And in an or, the order of the arguments in the or doesn't actually matter. The p doesn't need to be the first thing. It could have been in the middle. But the idea here is that if I have p in one clause and not p in the other clause, well then I know that one of these remaining things must be true. I've resolved them in order to produce a new clause. But it turns out we can generalize this idea even further, in fact, and display even more power that we can have with this resolution rule. So let's take another example. Let's say, for instance, that I know the same piece of information that either Ron is in the Great Hall or Hermione is in the library. And the second piece of information I know is that Ron is not in the Great Hall or Harry is sleeping. So it's not just a single piece of information. I have two different clauses. And we'll define clauses more precisely in just a moment. What do I know here? Well again, for any propositional symbol like Ron is in the Great Hall, there are only two possibilities. Either Ron is in the Great Hall, in which case, based on resolution, we know that Harry must be sleeping, or Ron is not in the Great Hall, in which case we know based on the same rule that Hermione must be in the library. Based on those two things in combination, I can say based on these two premises that I can conclude that either Hermione is in the library or Harry is sleeping. So again, because these two conflict with each other, I know that one of these two must be true. And you can take a closer look and try and reason through that logic. Make sure you convince yourself that you believe this conclusion. Stated more generally, we can name this resolution rule by saying that if we know p or q is true, and we also know that not p or r is true, we resolve these two clauses together to get a new clause, q or r, that either q or r must be true. And again, much as in the last case, q and r don't need to just be single propositional symbols. It could be multiple symbols. So if I had a rule that had p or q1 or q2 or q3, so on and so forth, up until qn, where n is just some number. And likewise, I had not p or r1 or r2, so on and so forth, up until rm, where m, again, is just some other number. I can resolve these two clauses together to get one of these must be true, q1 or q2 up until qn or r1 or r2 up until rm. And this is just a generalization of that same rule we saw before. Each of these things here are what we're going to call a clause, where a clause is formally defined as a disjunction of literals, where a disjunction means it's a bunch of things that are connected with or. Disjunction means things connected with or. Conjunction, meanwhile, is things connected with and. And a literal is either a propositional symbol or the opposite of a propositional symbol. So it's something like p or q or not p or not q. Those are all propositional symbols or not of the propositional symbols. And we call those literals. And so a clause is just something like this, p or q or r, for example. Meanwhile, what this gives us an ability to do is it gives us an ability to turn logic, any logical sentence, into something called conjunctive normal form. A conjunctive normal form sentence is a logical sentence that is a conjunction of clauses. Recall, again, conjunction means things are connected to one another using and. And so a conjunction of clauses means it is an and of individual clauses, each of which has ors in it. So something like this, a or b or c, and d or not e, and f or g. Everything in parentheses is one clause. All of the clauses are connected to each other using an and. And everything in the clause is separated using an or. And this is just a standard form that we can translate a logical sentence into that just makes it easy to work with and easy to manipulate. And it turns out that we can take any sentence in logic and turn it into conjunctive normal form just by applying some inference rules and transformations to it. So we'll take a look at how we can actually do that. So what is the process for taking a logical formula and converting it into conjunctive normal form, otherwise known as c and f? Well, the process looks a little something like this. We need to take all of the symbols that are not part of conjunctive normal form. The bi-conditionals and the implications and so forth, and turn them into something that is more closely like conjunctive normal form. So the first step will be to eliminate bi-conditionals, those if and only if double arrows. And we know how to eliminate bi-conditionals because we saw there was an inference rule to do just that. Any time I have an expression like alpha if and only if beta, I can turn that into alpha implies beta and beta implies alpha based on that inference rule we saw before. Likewise, in addition to eliminating bi-conditionals, I can eliminate implications as well, the if then arrows. And I can do that using the same inference rule we saw before too, taking alpha implies beta and turning that into not alpha or beta because that is logically equivalent to this first thing here. Then we can move knots inwards because we don't want knots on the outsides of our expressions. Conjunctive normal form requires that it's just claws and claws and claws and claws. Any knots need to be immediately next to propositional symbols. But we can move those knots around using De Morgan's laws by taking something like not A and B and turn it into not A or not B, for example, using De Morgan's laws to manipulate that. And after that, all we'll be left with are ands and ors. And those are easy to deal with. We can use the distributive law to distribute the ors so that the ors end up on the inside of the expression, so to speak, and the ands end up on the outside. So this is the general pattern for how we'll take a formula and convert it into conjunctive normal form. And let's now take a look at an example of how we would do this and explore then why it is that we would want to do something like this. Here's how we can do it. Let's take this formula, for example. P or Q implies R. And I'd like to convert this into conjunctive normal form, where it's all ands of clauses, and every clause is a disjunctive clause. It's ors together. So what's the first thing I need to do? Well, this is an implication. So let me go ahead and remove that implication. Using the implication inference rule, I can turn P or Q into P or Q implies R into not P or Q or R. So that's the first step. I've gotten rid of the implication. And next, I can get rid of the not on the outside of this expression, too. I can move the nots inwards so they're closer to the literals themselves by using De Morgan's laws. And De Morgan's law says that not P or Q is equivalent to not P and not Q. Again, here, just applying the inference rules that we've already seen in order to translate these statements. And now, I have two things that are separated by an or, where this thing on the inside is an and. What I'd really like to move the ors so the ors are on the inside, because conjunctive normal form means I need clause and clause and clause and clause. And so to do that, I can use the distributive law. If I have not P and not Q or R, I can distribute the or R to both of these to get not P or R and not Q or R using the distributive law. And this now here at the bottom is in conjunctive normal form. It is a conjunction and and of disjunctions of clauses that just are separated by ors. So this process can be used by any formula to take a logical sentence and turn it into this conjunctive normal form, where I have clause and clause and clause and clause and clause and so on. So why is this helpful? Why do we even care about taking all these sentences and converting them into this form? It's because once they're in this form where we have these clauses, these clauses are the inputs to the resolution inference rule that we saw a moment ago, that if I have two clauses where there's something that conflicts or something complementary between those two clauses, I can resolve them to get a new clause, to draw a new conclusion. And we call this process inference by resolution, using the resolution rule to draw some sort of inference. And it's based on the same idea, that if I have P or Q, this clause, and I have not P or R, that I can resolve these two clauses together to get Q or R as the resulting clause, a new piece of information that I didn't have before. Now, a couple of key points that are worth noting about this before we talk about the actual algorithm. One thing is that, let's imagine we have P or Q or S, and I also have not P or R or S. The resolution rule says that because this P conflicts with this not P, we would resolve to put everything else together to get Q or S or R or S. But it turns out that this double S is redundant, or S here and or S there. It doesn't change the meaning of the sentence. So in resolution, when we do this resolution process, we'll usually also do a process known as factoring, where we take any duplicate variables that show up and just eliminate them. So Q or S or R or S just becomes Q or R or S. The S only needs to appear once, no need to include it multiple times. Now, one final question worth considering is what happens if I try to resolve P and not P together? If I know that P is true and I know that not P is true, well, resolution says I can merge these clauses together and look at everything else. Well, in this case, there is nothing else, so I'm left with what we might call the empty clause. I'm left with nothing. And the empty clause is always false. The empty clause is equivalent to just being false. And that's pretty reasonable because it's impossible for both P and not P to both hold at the same time. P is either true or it's not true, which means that if P is true, then this must be false. And if this is true, then this must be false. There is no way for both of these to hold at the same time. So if ever I try and resolve these two, it's a contradiction, and I'll end up getting this empty clause where the empty clause I can call equivalent to false. And this idea that if I resolve these two contradictory terms, I get the empty clause, this is the basis for our inference by resolution algorithm. Here's how we're going to perform inference by resolution at a very high level. We want to prove that our knowledge base entails some query alpha, that based on the knowledge we have, we can prove conclusively that alpha is going to be true. How are we going to do that? Well, in order to do that, we're going to try to prove that if we know the knowledge and not alpha, that that would be a contradiction. And this is a common technique in computer science more generally, this idea of proving something by contradiction. If I want to prove that something is true, I can do so by first assuming that it is false and showing that it would be contradictory, showing that it leads to some contradiction. And if the thing I'm trying to prove, if when I assume it's false, leads to a contradiction, then it must be true. And that's the logical approach or the idea behind a proof by contradiction. And that's what we're going to do here. We want to prove that this query alpha is true. So we're going to assume that it's not true. We're going to assume not alpha. And we're going to try and prove that it's a contradiction. If we do get a contradiction, well, then we know that our knowledge entails the query alpha. If we don't get a contradiction, there is no entailment. This is this idea of a proof by contradiction of assuming the opposite of what you're trying to prove. And if you can demonstrate that that's a contradiction, then what you're proving must be true. But more formally, how do we actually do this? How do we check that knowledge base and not alpha is going to lead to a contradiction? Well, here is where resolution comes into play. To determine if our knowledge base entails some query alpha, we're going to convert knowledge base and not alpha to conjunctive normal form, that form where we have a whole bunch of clauses that are all anded together. And when we have these individual clauses, now we can keep checking to see if we can use resolution to produce a new clause. We can take any pair of clauses and check, is there some literal that is the opposite of each other or complementary to each other in both of them? For example, I have a p in one clause and a not p in another clause. Or an r in one clause and a not r in another clause. If ever I have that situation where once I convert to conjunctive normal form and I have a whole bunch of clauses, I see two clauses that I can resolve to produce a new clause, then I'll do so. This process occurs in a loop. I'm going to keep checking to see if I can use resolution to produce a new clause and keep using those new clauses to try to generate more new clauses after that. Now, it just so may happen that eventually we may produce the empty clause, the clause we were talking about before. If I resolve p and not p together, that produces the empty clause and the empty clause we know to be false. Because we know that there's no way for both p and not p to both simultaneously be true. So if ever we produce the empty clause, then we have a contradiction. And if we have a contradiction, that's exactly what we were trying to do in a fruit by contradiction. If we have a contradiction, then we know that our knowledge base must entail this query alpha. And we know that alpha must be true. And it turns out, and we won't go into the proof here, but you can show that otherwise, if you don't produce the empty clause, then there is no entailment. If we run into a situation where there are no more new clauses to add, we've done all the resolution that we can do, and yet we still haven't produced the empty clause, then there is no entailment in this case. And this now is the resolution algorithm. And it's very abstract looking, especially this idea of like, what does it even mean to have the empty clause? So let's take a look at an example, actually try and prove some entailment by using this inference by resolution process. So here's our question. We have this knowledge base. Here is the knowledge that we know, A or B, and not B or C, and not C. And we want to know if all of this entails A. So this is our knowledge base here, this whole log thing. And our query alpha is just this propositional symbol, A. So what do we do? Well, first, we want to prove by contradiction. So we want to first assume that A is false, and see if that leads to some sort of contradiction. So here is what we're going to start with, A or B, and not B or C, and not C. This is our knowledge base. And we're going to assume not A. We're going to assume that the thing we're trying to prove is, in fact, false. And so this is now in conjunctive normal form, and I have four different clauses. I have A or B. I have not B or C. I have not C, and I have not A. And now, I can begin to just pick two clauses that I can resolve, and apply the resolution rule to them. And so looking at these four clauses, I see, all right, these two clauses are ones I can resolve. I can resolve them because there are complementary literals that show up in them. There's a C here, and a not C here. So just looking at these two clauses, if I know that not B or C is true, and I know that C is not true, well, then I can resolve these two clauses to say, all right, not B, that must be true. I can generate this new clause as a new piece of information that I now know to be true. And all right, now I can repeat this process, do the process again. Can I use resolution again to get some new conclusion? Well, it turns out I can. I can use that new clause I just generated, along with this one here. There are complementary literals. This B is complementary to, or conflicts with, this not B over here. And so if I know that A or B is true, and I know that B is not true, well, then the only remaining possibility is that A must be true. So now we have A. That is a new clause that I've been able to generate. And now, I can do this one more time. I'm looking for two clauses that can be resolved, and you might programmatically do this by just looping over all possible pairs of clauses and checking for complementary literals in each. And here, I can say, all right, I found two clauses, not A and A, that conflict with each other. And when I resolve these two together, well, this is the same as when we were resolving P and not P from before. When I resolve these two clauses together, I get rid of the As, and I'm left with the empty clause. And the empty clause we know to be false, which means we have a contradiction, which means we can safely say that this whole knowledge base does entail A. That if this sentence is true, that we know that A for sure is also true. So this now, using inference by resolution, is an entirely different way to take some statement and try and prove that it is, in fact, true. Instead of enumerating all of the possible worlds that we might be in in order to try to figure out in which cases is the knowledge base true and in which cases are query true, instead we use this resolution algorithm to say, let's keep trying to figure out what conclusions we can draw and see if we reach a contradiction. And if we reach a contradiction, then that tells us something about whether our knowledge actually entails the query or not. And it turns out there are many different algorithms that can be used for inference. What we've just looked at here are just a couple of them. And in fact, all of this is just based on one particular type of logic. It's based on propositional logic, where we have these individual symbols and we connect them using and and or and not and implies and by conditionals. But propositional logic is not the only kind of logic that exists. And in fact, we see that there are limitations that exist in propositional logic, especially as we saw in examples like with the mastermind example or with the example with the logic puzzle where we had different Hogwarts house people that belong to different houses and we were trying to figure out who belonged to which houses. There were a lot of different propositional symbols that we needed in order to represent some fairly basic ideas. So now is the final topic that we'll take a look at just before we end class today is one final type of logic different from propositional logic known as first order logic, which is a little bit more powerful than propositional logic and is going to make it easier for us to express certain types of ideas. In propositional logic, if we think back to that puzzle with the people in the Hogwarts houses, we had a whole bunch of symbols. And every symbol could only be true or false. We had a symbol for Minerva Gryffindor, which was either true of Minerva within Gryffindor and false otherwise, and likewise for Minerva Hufflepuff and Minerva Ravenclaw and Minerva Slytherin and so forth. But this was starting to get quite redundant. We wanted some way to be able to express that there is a relationship between these propositional symbols, that Minerva shows up in all of them. And also, I would have liked to have not have had so many different symbols to represent what really was a fairly straightforward problem. So first order logic will give us a different way of trying to deal with this idea by giving us two different types of symbols. We're going to have constant symbols that are going to represent objects like people or houses. And then predicate symbols, which you can think of as relations or functions that take an input and evaluate them to true or false, for example, that tell us whether or not some property of some constant or some pair of constants or multiple constants actually holds. So we'll see an example of that in just a moment. For now, in this same problem, our constant symbols might be objects, things like people or houses. So Minerva, Pomona, Horace, Gilderoy, those are all constant symbols, as are my four houses, Gryffindor, Hufflepuff, Ravenclaw, and Slytherin. Predicates, meanwhile, these predicate symbols are going to be properties that might hold true or false of these individual constants. So person might hold true of Minerva, but it would be false for Gryffindor because Gryffindor is not a person. And house is going to hold true for Ravenclaw, but it's not going to hold true for Horace, for example, because Horace is a person. And belongs to, meanwhile, is going to be some relation that is going to relate people to their houses. And it's going to only tell me when someone belongs to a house or does not. So let's take a look at some examples of what a sentence in first order logic might actually look like. A sentence might look like something like this. Person Minerva, with Minerva in parentheses, and person being a predicate symbol, Minerva being a constant symbol. This sentence in first order logic effectively means Minerva is a person, or the person property applies to the Minerva object. So if I want to say something like Minerva is a person, here is how I express that idea using first order logic. Meanwhile, I can say something like, house Gryffindor, to likewise express the idea that Gryffindor is a house. I can do that this way. And all of the same logical connectives that we saw in propositional logic, those are going to work here too. And or implication by conditional not. In fact, I can use not to say something like, not house Minerva. And this sentence in first order logic means something like, Minerva is not a house. It is not true that the house property applies to Minerva. Meanwhile, in addition to some of these predicate symbols that just take a single argument, some of our predicate symbols are going to express binary relations, relations between two of its arguments. So I could say something like, belongs to, and then two inputs, Minerva and Gryffindor, to express the idea that Minerva belongs to Gryffindor. And so now here's the key difference, or one of the key differences, between this and propositional logic. In propositional logic, I needed one symbol for Minerva Gryffindor, and one symbol for Minerva Hufflepuff, and one symbol for all the other people's Gryffindor and Hufflepuff variables. In this case, I just need one symbol for each of my people, and one symbol for each of my houses. And then I can express as a predicate something like, belongs to, and say, belongs to Minerva Gryffindor, to express the idea that Minerva belongs to Gryffindor House. So already we can see that first order logic is quite expressive in being able to express these sorts of sentences using the existing constant symbols and predicates that already exist, while minimizing the number of new symbols that I need to create. I can just use eight symbols for people for houses, instead of 16 symbols for every possible combination of each. But first order logic gives us a couple of additional features that we can use to express even more complex ideas. And these more additional features are generally known as quantifiers. And there are two main quantifiers in first order logic, the first of which is universal quantification. Universal quantification lets me express an idea like something is going to be true for all values of a variable. Like for all values of x, some statement is going to hold true. So what might a sentence in universal quantification look like? Well, we're going to use this upside down a to mean for all. So upside down ax means for all values of x, where x is any object, this is going to hold true. Belongs to x Gryffindor implies not belongs to x Hufflepuff. So let's try and parse this out. This means that for all values of x, if this holds true, if x belongs to Gryffindor, then this does not hold true. x does not belong to Hufflepuff. So translated into English, this sentence is saying something like for all objects x, if x belongs to Gryffindor, then x does not belong to Hufflepuff, for example. Or a phrase even more simply, anyone in Gryffindor is not in Hufflepuff, simplified way of saying the same thing. So this universal quantification lets us express an idea like something is going to hold true for all values of a particular variable. In addition to universal quantification though, we also have existential quantification. Whereas universal quantification said that something is going to be true for all values of a variable, existential quantification says that some expression is going to be true for some value of a variable, at least one value of the variable. So let's take a look at a sample sentence using existential quantification. One such sentence looks like this. There exists an x. This backwards e stands for exists. And here we're saying there exists an x such that house x and belongs to Minerva x. In other words, there exists some object x where x is a house and Minerva belongs to x. Or phrased a little more succinctly in English, I'm here just saying Minerva belongs to a house. There's some object that is a house and Minerva belongs to a house. And combining this universal and existential quantification, we can create far more sophisticated logical statements than we were able to just using propositional logic. I could combine these to say something like this. For all x, person x implies there exists a y such that house y and belongs to xy. All right. So a lot of stuff going on there, a lot of symbols. Let's try and parse it out and just understand what it's saying. Here we're saying that for all values of x, if x is a person, then this is true. So in other words, I'm saying for all people, and we call that person x, this statement is going to be true. What statement is true of all people? Well, there exists a y that is a house, so there exists some house, and x belongs to y. In other words, I'm saying that for all people out there, there exists some house such that x, the person, belongs to y, the house. This is phrased more succinctly. I'm saying that every person belongs to a house, that for all x, if x is a person, then there exists a house that x belongs to. And so we can now express a lot more powerful ideas using this idea now of first order logic. And it turns out there are many other kinds of logic out there. There's second order logic and other higher order logic, each of which allows us to express more and more complex ideas. But all of it, in this case, is really in pursuit of the same goal, which is the representation of knowledge. We want our AI agents to be able to know information, to represent that information, whether that's using propositional logic or first order logic or some other logic, and then be able to reason based on that, to be able to draw conclusions, make inferences, figure out whether there's some sort of entailment relationship, as by using some sort of inference algorithm, something like inference by resolution or model checking or any number of these other algorithms that we can use in order to take information that we know and translate it to additional conclusions. So all of this has helped us to create AI that is able to represent information about what it knows and what it doesn't know. Next time, though, we'll take a look at how we can make our AI even more powerful by not just encoding information that we know for sure to be true and not to be true, but also to take a look at uncertainty, to look at what happens if AI thinks that something might be probable or maybe not very probable or somewhere in between those two extremes, all in the pursuit of trying to build our intelligent systems to be even more intelligent. We'll see you next time. Thank you. All right, welcome back, everyone, to an introduction to artificial intelligence with Python. And last time, we took a look at how it is that AI inside of our computers can represent knowledge. We represented that knowledge in the form of logical sentences in a variety of different logical languages. And the idea was we wanted our AI to be able to represent knowledge or information and somehow use those pieces of information to be able to derive new pieces of information by inference, to be able to take some information and deduce some additional conclusions based on the information that it already knew for sure. But in reality, when we think about computers and we think about AI, very rarely are our machines going to be able to know things for sure. Oftentimes, there's going to be some amount of uncertainty in the information that our AIs or our computers are dealing with, where it might believe something with some probability, as we'll soon discuss what probability is all about and what it means, but not entirely for certain. And we want to use the information that it has some knowledge about, even if it doesn't have perfect knowledge, to still be able to make inferences, still be able to draw conclusions. So you might imagine, for example, in the context of a robot that has some sensors and is exploring some environment, it might not know exactly where it is or exactly what's around it, but it does have access to some data that can allow it to draw inferences with some probability. There's some likelihood that one thing is true or another. Or you can imagine in context where there is a little bit more randomness and uncertainty, something like predicting the weather, where you might not be able to know for sure what tomorrow's weather is with 100% certainty, but you can probably infer with some probability what tomorrow's weather is going to be based on maybe today's weather and yesterday's weather and other data that you might have access to as well. And so oftentimes, we can distill this in terms of just possible events that might happen and what the likelihood of those events are. This comes a lot in games, for example, where there is an element of chance inside of those games. So you imagine rolling a dice. You're not sure exactly what the die roll is going to be, but you know it's going to be one of these possibilities from 1 to 6, for example. And so here now, we introduce the idea of probability theory. And what we'll take a look at today is beginning by looking at the mathematical foundations of probability theory, getting an understanding for some of the key concepts within probability, and then diving into how we can use probability and the ideas that we look at mathematically to represent some ideas in terms of models that we can put into our computers in order to program an AI that is able to use information about probability to draw inferences, to make some judgments about the world with some probability or likelihood of being true. So probability ultimately boils down to this idea that there are possible worlds that we're here representing using this little Greek letter omega. And the idea of a possible world is that when I roll a die, there are six possible worlds that could result from it. I could roll a 1, or a 2, or a 3, or a 4, or a 5, or a 6. And each of those are a possible world. And each of those possible worlds has some probability of being true, the probability that I do roll a 1, or a 2, or a 3, or something else. And we represent that probability like this, using the capital letter P. And then in parentheses, what it is that we want the probability of. So this right here would be the probability of some possible world as represented by the little letter omega. Now, there are a couple of basic axioms of probability that become relevant as we consider how we deal with probability and how we think about it. First and foremost, every probability value must range between 0 and 1 inclusive. So the smallest value any probability can have is the number 0, which is an impossible event. Something like I roll a die, and the die is a 7 is the roll that I get. If the die only has numbers 1 through 6, the event that I roll a 7 is impossible, so it would have probability 0. And on the other end of the spectrum, probability can range all the way up to the positive number 1, meaning an event is certain to happen, that I roll a die and the number is less than 10, for example. That is an event that is guaranteed to happen if the only sides on my die are 1 through 6, for instance. And then they can range through any real number in between these two values. Where, generally speaking, a higher value for the probability means an event is more likely to take place, and a lower value for the probability means the event is less likely to take place. And the other key rule for probability looks a little bit like this. This sigma notation, if you haven't seen it before, refers to summation, the idea that we're going to be adding up a whole sequence of values. And this sigma notation is going to come up a couple of times today, because as we deal with probability, oftentimes we're adding up a whole bunch of individual values or individual probabilities to get some other value. So we'll see this come up a couple of times. But what this notation means is that if I sum up all of the possible worlds omega that are in big omega, which represents the set of all the possible worlds, meaning I take for all of the worlds in the set of possible worlds and add up all of their probabilities, what I ultimately get is the number 1. So if I take all the possible worlds, add up what each of their probabilities is, I should get the number 1 at the end, meaning all probabilities just need to sum to 1. So for example, if I take dice, for example, and if you imagine I have a fair die with numbers 1 through 6 and I roll the die, each one of these rolls has an equal probability of taking place. And the probability is 1 over 6, for example. So each of these probabilities is between 0 and 1, 0 meaning impossible and 1 meaning for certain. And if you add up all of these probabilities for all of the possible worlds, you get the number 1. And we can represent any one of those probabilities like this. The probability that we roll the number 2, for example, is just 1 over 6. Every six times we roll the die, we'd expect that one time, for instance, the die might come up as a 2. Its probability is not certain, but it's a little more than nothing, for instance. And so this is all fairly straightforward for just a single die. But things get more interesting as our models of the world get a little bit more complex. Let's imagine now that we're not just dealing with a single die, but we have two dice, for example. I have a red die here and a blue die there, and I care not just about what the individual roll is, but I care about the sum of the two rolls. In this case, the sum of the two rolls is the number 3. How do I begin to now reason about what does the probability look like if instead of having one die, I now have two dice? Well, what we might imagine is that we could first consider what are all of the possible worlds. And in this case, all of the possible worlds are just every combination of the red and blue die that I could come up with. For the red die, it could be a 1 or a 2 or a 3 or a 4 or a 5 or a 6. And for each of those possibilities, the blue die, likewise, could also be either 1 or 2 or 3 or 4 or 5 or 6. And it just so happens that in this particular case, each of these possible combinations is equally likely. Equally likely are all of these various different possible worlds. That's not always going to be the case. If you imagine more complex models that we could try to build and things that we could try to represent in the real world, it's probably not going to be the case that every single possible world is always equally likely. But in the case of fair dice, where in any given die roll, any one number has just as good a chance of coming up as any other number, we can consider all of these possible worlds to be equally likely. But even though all of the possible worlds are equally likely, that doesn't necessarily mean that their sums are equally likely. So if we consider what the sum is of all of these two, so 1 plus 1, that's a 2. 2 plus 1 is a 3. And consider for each of these possible pairs of numbers what their sum ultimately is, we can notice that there are some patterns here, where it's not entirely the case that every number comes up equally likely. If you consider 7, for example, what's the probability that when I roll two dice, their sum is 7? There are several ways this can happen. There are six possible worlds where the sum is 7. It could be a 1 and a 6, or a 2 and a 5, or a 3 and a 4, a 4 and a 3, and so forth. But if you instead consider what's the probability that I roll two dice, and the sum of those two die rolls is 12, for example, we're looking at this diagram, there's only one possible world in which that can happen. And that's the possible world where both the red die and the blue die both come up as sixes to give us a sum total of 12. So based on just taking a look at this diagram, we see that some of these probabilities are likely different. The probability that the sum is a 7 must be greater than the probability that the sum is a 12. And we can represent that even more formally by saying, OK, the probability that we sum to 12 is 1 out of 36. Out of the 36 equally likely possible worlds, 6 squared because we have six options for the red die and six options for the blue die, out of those 36 options, only one of them sums to 12. Whereas on the other hand, the probability that if we take two dice rolls and they sum up to the number 7, well, out of those 36 possible worlds, there were six worlds where the sum was 7. And so we get 6 over 36, which we can simplify as a fraction to just 1 over 6. So here now, we're able to represent these different ideas of probability, representing some events that might be more likely and then other events that are less likely as well. And these sorts of judgments, where we're figuring out just in the abstract what is the probability that this thing takes place, are generally known as unconditional probabilities. Some degree of belief we have in some proposition, some fact about the world, in the absence of any other evidence. Without knowing any additional information, if I roll a die, what's the chance it comes up as a 2? Or if I roll two dice, what's the chance that the sum of those two die rolls is a 7? But usually when we're thinking about probability, especially when we're thinking about training in AI to intelligently be able to know something about the world and make predictions based on that information, it's not unconditional probability that our AI is dealing with, but rather conditional probability, probability where rather than having no original knowledge, we have some initial knowledge about the world and how the world actually works. So conditional probability is the degree of belief in a proposition given some evidence that has already been revealed to us. So what does this look like? Well, it looks like this in terms of notation. We're going to represent conditional probability as probability of A and then this vertical bar and then B. And the way to read this is the thing on the left-hand side of the vertical bar is what we want the probability of. Here now, I want the probability that A is true, that it is the real world, that it is the event that actually does take place. And then on the right side of the vertical bar is our evidence, the information that we already know for certain about the world. For example, that B is true. So the way to read this entire expression is what is the probability of A given B, the probability that A is true, given that we already know that B is true. And this type of judgment, conditional probability, the probability of one thing given some other fact, comes up quite a lot when we think about the types of calculations we might want our AI to be able to do. For example, we might care about the probability of rain today given that we know that it rained yesterday. We could think about the probability of rain today just in the abstract. What is the chance that today it rains? But usually, we have some additional evidence. I know for certain that it rained yesterday. And so I would like to calculate the probability that it rains today given that I know that it rained yesterday. Or you might imagine that I want to know the probability that my optimal route to my destination changes given the current traffic condition. So whether or not traffic conditions change, that might change the probability that this route is actually the optimal route. Or you might imagine in a medical context, I want to know the probability that a patient has a particular disease given some results of some tests that have been performed on that patient. And I have some evidence, the results of that test, and I would like to know the probability that a patient has a particular disease. So this notion of conditional probability comes up everywhere. So we begin to think about what we would like to reason about, but being able to reason a little more intelligently by taking into account evidence that we already have. We're more able to get an accurate result for what is the likelihood that someone has this disease if we know this evidence, the results of the test, as opposed to if we were just calculating the unconditional probability of saying, what is the probability they have the disease without any evidence to try and back up our result one way or the other. So now that we've got this idea of what conditional probability is, the next question we have to ask is, all right, how do we calculate conditional probability? How do we figure out mathematically, if I have an expression like this, how do I get a number from that? What does conditional probability actually mean? Well, the formula for conditional probability looks a little something like this. The probability of a given b, the probability that a is true, given that we know that b is true, is equal to this fraction, the probability that a and b are true, divided by just the probability that b is true. And the way to intuitively try to think about this is that if I want to know the probability that a is true, given that b is true, well, I want to consider all the ways they could both be true out of the only worlds that I care about are the worlds where b is already true. I can sort of ignore all the cases where b isn't true, because those aren't relevant to my ultimate computation. They're not relevant to what it is that I want to get information about. So let's take a look at an example. Let's go back to that example of rolling two dice and the idea that those two dice might sum up to the number 12. We discussed earlier that the unconditional probability that if I roll two dice and they sum to 12 is 1 out of 36, because out of the 36 possible worlds that I might care about, in only one of them is the sum of those two dice 12. It's only when red is 6 and blue is also 6. But let's say now that I have some additional information. I now want to know what is the probability that the two dice sum to 12, given that I know that the red die was a 6. So I already have some evidence. I already know the red die is a 6. I don't know what the blue die is. That information isn't given to me in this expression. But given the fact that I know that the red die rolled a 6, what is the probability that we sum to 12? And so we can begin to do the math using that expression from before. Here, again, are all of the possibilities, all of the possible combinations of red die being 1 through 6 and blue die being 1 through 6. And I might consider first, all right, what is the probability of my evidence, my B variable, where I want to know, what is the probability that the red die is a 6? Well, the probability that the red die is a 6 is just 1 out of 6. So these 1 out of 6 options are really the only worlds that I care about here now. All the rest of them are irrelevant to my calculation, because I already have this evidence that the red die was a 6, so I don't need to care about all of the other possibilities that could result. So now, in addition to the fact that the red die rolled as a 6 and the probability of that, the other piece of information I need to know in order to calculate this conditional probability is the probability that both of my variables, A and B, are true. The probability that both the red die is a 6, and they all sum to 12. So what is the probability that both of these things happen? Well, it only happens in one possible case in 1 out of these 36 cases, and it's the case where both the red and the blue die are equal to 6. This is a piece of information that we already knew. And so this probability is equal to 1 over 36. And so to get the conditional probability that the sum is 12, given that I know that the red dice is equal to 6, well, I just divide these two values together, and 1 over 36 divided by 1 over 6 gives us this probability of 1 over 6. Given that I know that the red die rolled a value of 6, the probability that the sum of the two dice is 12 is also 1 over 6. And that probably makes intuitive sense to you, too, because if the red die is a 6, the only way for me to get to a 12 is if the blue die also rolls a 6, and we know that the probability of the blue die rolling a 6 is 1 over 6. So in this case, the conditional probability seems fairly straightforward. But this idea of calculating a conditional probability by looking at the probability that both of these events take place is an idea that's going to come up again and again. This is the definition now of conditional probability. And we're going to use that definition as we think about probability more generally to be able to draw conclusions about the world. This, again, is that formula. The probability of A given B is equal to the probability that A and B take place divided by the probability of B. And you'll see this formula sometimes written in a couple of different ways. You could imagine algebraically multiplying both sides of this equation by probability of B to get rid of the fraction, and you'll get an expression like this. The probability of A and B, which is this expression over here, is just the probability of B times the probability of A given B. Or you could represent this equivalently since A and B in this expression are interchangeable. A and B is the same thing as B and A. You could imagine also representing the probability of A and B as the probability of A times the probability of B given A, just switching all of the A's and B's. These three are all equivalent ways of trying to represent what joint probability means. And so you'll sometimes see all of these equations, and they might be useful to you as you begin to reason about probability and to think about what values might be taking place in the real world. Now, sometimes when we deal with probability, we don't just care about a Boolean event like did this happen or did this not happen. Sometimes we might want the ability to represent variable values in a probability space where some variable might take on multiple different possible values. And in probability, we call a variable in probability theory a random variable. A random variable in probability is just some variable in probability theory that has some domain of values that it can take on. So what do I mean by this? Well, what I mean is I might have a random variable that is just called roll, for example, that has six possible values. Roll is my variable, and the possible values, the domain of values that it can take on are 1, 2, 3, 4, 5, and 6. And I might like to know the probability of each. In this case, they happen to all be the same. But in other random variables, that might not be the case. For example, I might have a random variable to represent the weather, for example, where the domain of values it could take on are things like sun or cloudy or rainy or windy or snowy. And each of those might have a different probability. And I care about knowing what is the probability that the weather equals sun or that the weather equals clouds, for instance. And I might like to do some mathematical calculations based on that information. Other random variables might be something like traffic. What are the odds that there is no traffic or light traffic or heavy traffic? Traffic, in this case, is my random variable. And the values that that random variable can take on are here. It's either none or light or heavy. And I, the person doing these calculations, I, the person encoding these random variables into my computer, need to make the decision as to what these possible values actually are. You might imagine, for example, for a flight. If I care about whether or not I make it or do a flight on time, my flight has a couple of possible values that it could take on. My flight could be on time. My flight could be delayed. My flight could be canceled. So flight, in this case, is my random variable. And these are the values that it can take on. And often, I want to know something about the probability that my random variable takes on each of those possible values. And this is what we then call a probability distribution. A probability distribution takes a random variable and gives me the probability for each of the possible values in its domain. So in the case of this flight, for example, my probability distribution might look something like this. My probability distribution says the probability that the random variable flight is equal to the value on time is 0.6. Or otherwise, put into more English human-friendly terms, the likelihood that my flight is on time is 60%, for example. And in this case, the probability that my flight is delayed is 30%. The probability that my flight is canceled is 10% or 0.1. And if you sum up all of these possible values, the sum is going to be 1, right? If you take all of the possible worlds, here are my three possible worlds for the value of the random variable flight, add them all up together, the result needs to be the number 1 per that axiom of probability theory that we've discussed before. So this now is one way of representing this probability distribution for the random variable flight. Sometimes you'll see it represented a little bit more concisely that this is pretty verbose for really just trying to express three possible values. And so often, you'll instead see the same notation representing using a vector. And all a vector is is a sequence of values. As opposed to just a single value, I might have multiple values. And so I could extend instead, represent this idea this way. Bold p, so a larger p, generally meaning the probability distribution of this variable flight is equal to this vector represented in angle brackets. The probability distribution is 0.6, 0.3, and 0.1. And I would just have to know that this probability distribution is in order of on time or delayed and canceled to know how to interpret this vector. To mean the first value in the vector is the probability that my flight is on time. The second value in the vector is the probability that my flight is delayed. And the third value in the vector is the probability that my flight is canceled. And so this is just an alternate way of representing this idea, a little more verbosely. But oftentimes, you'll see us just talk about a probability distribution over a random variable. And whenever we talk about that, what we're really doing is trying to figure out the probabilities of each of the possible values that that random variable can take on. But this notation is just a little bit more succinct, even though it can sometimes be a little confusing, depending on the context in which you see it. So we'll start to look at examples where we use this sort of notation to describe probability and to describe events that might take place. A couple of other important ideas to know with regards to probability theory. One is this idea of independence. And independence refers to the idea that the knowledge of one event doesn't influence the probability of another event. So for example, in the context of my two dice rolls, where I had the red die and the blue die, the probability that I roll the red die and the blue die, those two events, red die and blue die, are independent. Knowing the result of the red die doesn't change the probabilities for the blue die. It doesn't give me any additional information about what the value of the blue die is ultimately going to be. But that's not always going to be the case. You might imagine that in the case of weather, something like clouds and rain, those are probably not independent. But if it is cloudy, that might increase the probability that later in the day it's going to rain. So some information informs some other event or some other random variable. So independence refers to the idea that one event doesn't influence the other. And if they're not independent, then there might be some relationship. So mathematically, formally, what does independence actually mean? Well, recall this formula from before, that the probability of A and B is the probability of A times the probability of B given A. And the more intuitive way to think about this is that to know how likely it is that A and B happen, well, let's first figure out the likelihood that A happens. And then given that we know that A happens, let's figure out the likelihood that B happens and multiply those two things together. But if A and B were independent, meaning knowing A doesn't change anything about the likelihood that B is true, well, then the probability of B given A, meaning the probability that B is true, given that I know A is true, well, that I know A is true shouldn't really make a difference if these two things are independent, that A shouldn't influence B at all. So the probability of B given A is really just the probability of B. If it is true that A and B are independent. And so this right here is one example of a definition for what it means for A and B to be independent. The probability of A and B is just the probability of A times the probability of B. Anytime you find two events A and B where this relationship holds, then you can say that A and B are independent. So an example of that might be the dice that we were taking a look at before. Here, if I wanted the probability of red being a 6 and blue being a 6, well, that's just the probability that red is a 6 multiplied by the probability that blue is a 6. It's both equal to 1 over 36. So I can say that these two events are independent. What wouldn't be independent, for example, would be an example. So this, for example, has a probability of 1 over 36, as we talked about before. But what wouldn't be independent would be a case like this, the probability that the red die rolls a 6 and the red die rolls a 4. If you just naively took, OK, red die 6, red die 4, well, if I'm only rolling the die once, you might imagine the naive approach is to say, well, each of these has a probability of 1 over 6. So multiply them together, and the probability is 1 over 36. But of course, if you're only rolling the red die once, there's no way you could get two different values for the red die. It couldn't both be a 6 and a 4. So the probability should be 0. But if you were to multiply probability of red 6 times probability of red 4, well, that would equal 1 over 36. But of course, that's not true. Because we know that there is no way, probability 0, that when we roll the red die once, we get both a 6 and a 4, because only one of those possibilities can actually be the result. And so we can say that the event that red roll is 6 and the event that red roll is 4, those two events are not independent. If I know that the red roll is a 6, I know that the red roll cannot possibly be a 4, so these things are not independent. And instead, if I wanted to calculate the probability, I would need to use this conditional probability as the regular definition of the probability of two events taking place. And the probability of this now, well, the probability of the red roll being a 6, that's 1 over 6. But what's the probability that the roll is a 4 given that the roll is a 6? Well, this is just 0, because there's no way for the red roll to be a 4, given that we already know the red roll is a 6. And so the value, if we do add all that multiplication, is we get the number 0. So this idea of conditional probability is going to come up again and again, especially as we begin to reason about multiple different random variables that might be interacting with each other in some way. And this gets us to one of the most important rules in probability theory, which is known as Bayes rule. And it turns out that just using the information we've already learned about probability and just applying a little bit of algebra, we can actually derive Bayes rule for ourselves. But it's a very important rule when it comes to inference and thinking about probability in the context of what it is that a computer can do or what a mathematician could do by having access to information about probability. So let's go back to these equations to be able to derive Bayes rule ourselves. We know the probability of A and B, the likelihood that A and B take place, is the likelihood of B, and then the likelihood of A, given that we know that B is already true. And likewise, the probability of A given A and B is the probability of A times the probability of B, given that we know that A is already true. This is sort of a symmetric relationship where it doesn't matter the order of A and B and B and A mean the same thing. And so in these equations, we can just swap out A and B to be able to represent the exact same idea. So we know that these two equations are already true. We've seen that already. And now let's just do a little bit of algebraic manipulation of this stuff. Both of these expressions on the right-hand side are equal to the probability of A and B. So what I can do is take these two expressions on the right-hand side and just set them equal to each other. If they're both equal to the probability of A and B, then they both must be equal to each other. So probability of A times probability of B given A is equal to the probability of B times the probability of A given B. And now all we're going to do is do a little bit of division. I'm going to divide both sides by P of A. And now I get what is Bayes' rule. The probability of B given A is equal to the probability of B times the probability of A given B divided by the probability of A. And sometimes in Bayes' rule, you'll see the order of these two arguments switched. So instead of B times A given B, it'll be A given B times B. That ultimately doesn't matter because in multiplication, you can switch the order of the two things you're multiplying, and it doesn't change the result. But this here right now is the most common formulation of Bayes' rule. The probability of B given A is equal to the probability of A given B times the probability of B divided by the probability of A. And this rule, it turns out, is really important when it comes to trying to infer things about the world, because it means you can express one conditional probability, the conditional probability of B given A, using knowledge about the probability of A given B, using the reverse of that conditional probability. So let's first do a little bit of an example with this, just to see how we might use it, and then explore what this means a little bit more generally. So we're going to construct a situation where I have some information. There are two events that I care about, the idea that it's cloudy in the morning and the idea that it is rainy in the afternoon. Those are two different possible events that could take place, cloudy in the morning, or the AM, rainy in the PM. And what I care about is, given clouds in the morning, what is the probability of rain in the afternoon? A reasonable question I might ask, in the morning, I look outside, or an AI's camera looks outside and sees that there are clouds in the morning. And we want to conclude, we want to figure out what is the probability that in the afternoon, there is going to be rain. Of course, in the abstract, we don't have access to this kind of information, but we can use data to begin to try and figure this out. So let's imagine now that I have access to some pieces of information. I have access to the idea that 80% of rainy afternoons start out with a cloudy morning. And you might imagine that I could have gathered this data just by looking at data over a sequence of time, that I know that 80% of the time when it's raining in the afternoon, it was cloudy that morning. I also know that 40% of days have cloudy mornings. And I also know that 10% of days have rainy afternoons. And now using this information, I would like to figure out, given clouds in the morning, what is the probability that it rains in the afternoon? I want to know the probability of afternoon rain given morning clouds. And I can do that, in particular, using this fact, the probability of, so if I know that 80% of rainy afternoons start with cloudy mornings, then I know the probability of cloudy mornings given rainy afternoons. So using sort of the reverse conditional probability, I can figure that out. Expressed in terms of Bayes rule, this is what that would look like. Probability of rain given clouds is the probability of clouds given rain times the probability of rain divided by the probability of clouds. Here I'm just substituting in for the values of a and b from that equation of Bayes rule from before. And then I can just do the math. I have this information. I know that 80% of the time, if it was raining, then there were clouds in the morning. So 0.8 here. Probability of rain is 0.1, because 10% of days were rainy, and 40% of days were cloudy. I do the math, and I can figure out the answer is 0.2. So the probability that it rains in the afternoon, given that it was cloudy in the morning, is 0.2 in this case. And this now is an application of Bayes rule, the idea that using one conditional probability, we can get the reverse conditional probability. And this is often useful when one of the conditional probabilities might be easier for us to know about or easier for us to have data about. And using that information, we can calculate the other conditional probability. So what does this look like? Well, it means that knowing the probability of cloudy mornings given rainy afternoons, we can calculate the probability of rainy afternoons given cloudy mornings. Or, for example, more generally, if we know the probability of some visible effect, some effect that we can see and observe, given some unknown cause that we're not sure about, well, then we can calculate the probability of that unknown cause given the visible effect. So what might that look like? Well, in the context of medicine, for example, I might know the probability of some medical test result given a disease. Like, I know that if someone has a disease, then x% of the time the medical test result will show up as this, for instance. And using that information, then I can calculate, all right, what is the probability that given I know the medical test result, what is the likelihood that someone has the disease? This is the piece of information that is usually easier to know, easier to immediately have access to data for. And this is the information that I actually want to calculate. Or I might want to know, for example, if I know that some probability of counterfeit bills have blurry text around the edges, because counterfeit printers aren't nearly as good at printing text precisely. So I have some information about, given that something is a counterfeit bill, like x% of counterfeit bills have blurry text, for example. And using that information, then I can calculate some piece of information that I might want to know, like, given that I know there's blurry text on a bill, what is the probability that that bill is counterfeit? So given one conditional probability, I can calculate the other conditional probability as well. And so now we've taken a look at a couple of different types of probability. And we've looked at unconditional probability, where I just look at what is the probability of this event occurring, given no additional evidence that I might have access to. And we've also looked at conditional probability, where I have some sort of evidence, and I would like to, using that evidence, be able to calculate some other probability as well. And the other kind of probability that will be important for us to think about is joint probability. And this is when we're considering the likelihood of multiple different events simultaneously. And so what do we mean by this? For example, I might have probability distributions that look a little something like this. Like, oh, I want to know the probability distribution of clouds in the morning. And that distribution looks like this. 40% of the time, C, which is my random variable here, is equal to it's cloudy. And 60% of the time, it's not cloudy. So here is just a simple probability distribution that is effectively telling me that 40% of the time, it's cloudy. I might also have a probability distribution for rain in the afternoon, where 10% of the time, or with probability 0.1, it is raining in the afternoon. And with probability 0.9, it is not raining in the afternoon. And using just these two pieces of information, I don't actually have a whole lot of information about how these two variables relate to each other. But I could if I had access to their joint probability, meaning for every combination of these two things, meaning morning cloudy and afternoon rain, morning cloudy and afternoon not rain, morning not cloudy and afternoon rain, and morning not cloudy and afternoon not raining, if I had access to values for each of those four, I'd have more information. So information that'd be organized in a table like this, and this, rather than just a probability distribution, is a joint probability distribution. It tells me the probability distribution of each of the possible combinations of values that these random variables can take on. So if I want to know what is the probability that on any given day it is both cloudy and rainy, well, I would say, all right, we're looking at cases where it is cloudy and cases where it is raining. And the intersection of those two, that row in that column, is 0.08. So that is the probability that it is both cloudy and rainy using that information. And using this conditional probability table, using this joint probability table, I can begin to draw other pieces of information about things like conditional probability. So I might ask a question like, what is the probability distribution of clouds given that I know that it is raining? Meaning I know for sure that it's raining. Tell me the probability distribution over whether it's cloudy or not, given that I know already that it is, in fact, raining. And here I'm using C to stand for that random variable. I'm looking for a distribution, meaning the answer to this is not going to be a single value. It's going to be two values, a vector of two values, where the first value is probability of clouds, the second value is probability that it is not cloudy, but the sum of those two values is going to be 1. Because when you add up the probabilities of all of the possible worlds, the result that you get must be the number 1. And well, what do we know about how to calculate a conditional probability? Well, we know that the probability of A given B is the probability of A and B divided by the probability of B. So what does this mean? Well, it means that I can calculate the probability of clouds given that it's raining as the probability of clouds and raining divided by the probability of rain. And this comma here for the probability distribution of clouds and rain, this comma sort of stands in for the word and. You'll sort of see in the logical operator and and the comma used interchangeably. This means the probability distribution over the clouds and knowing the fact that it is raining divided by the probability of rain. And the interesting thing to note here and what we'll often do in order to simplify our mathematics is that dividing by the probability of rain, the probability of rain here is just some numerical constant. It is some number. Dividing by probability of rain is just dividing by some constant, or in other words, multiplying by the inverse of that constant. And it turns out that oftentimes we can just not worry about what the exact value of this is and just know that it is, in fact, a constant value. And we'll see why in a moment. So instead of expressing this as this joint probability divided by the probability of rain, sometimes we'll just represent it as alpha times the numerator here, the probability distribution of C, this variable, and that we know that it is raining, for instance. So all we've done here is said this value of 1 over the probability of rain, that's really just a constant we're going to divide by or equivalently multiply by the inverse of at the end. We'll just call it alpha for now and deal with it a little bit later. But the key idea here now, and this is an idea that's going to come up again, is that the conditional distribution of C given rain is proportional to, meaning just some factor multiplied by the joint probability of C and rain being true. And so how do we figure this out? Well, this is going to be the probability that it is cloudy given that it's raining, which is 0.08, and the probability that it's not cloudy given that it's raining, which is 0.02. And so we get alpha times here now is that probability distribution. 0.08 is clouds and rain. 0.02 is not cloudy and rain. But of course, 0.08 and 0.02 don't sum up to the number 1. And we know that in a probability distribution, if you consider all of the possible values, they must sum up to a probability of 1. And so we know that we just need to figure out some constant to normalize, so to speak, these values, something we can multiply or divide by to get it so that all these probabilities sum up to 1, and it turns out that if we multiply both numbers by 10, then we can get that result of 0.8 and 0.2. The proportions are still equivalent, but now 0.8 plus 0.2, those sum up to the number 1. So take a look at this and see if you can understand step by step how it is we're getting from one point to another. The key idea here is that by using the joint probabilities, these probabilities that it is both cloudy and rainy and that it is not cloudy and rainy, I can take that information and figure out the conditional probability given that it's raining. What is the chance that it's cloudy versus not cloudy? Just by multiplying by some normalization constant, so to speak. And this is what a computer can begin to use to be able to interact with these various different types of probabilities. And it turns out there are a number of other probability rules that are going to be useful to us as we begin to explore how we can actually use this information to encode into our computers some more complex analysis that we might want to do about probability and distributions and random variables that we might be interacting with. So here are a couple of those important probability rules. One of the simplest rules is just this negation rule. What is the probability of not event A? So A is an event that has some probability, and I would like to know what is the probability that A does not occur. And it turns out it's just 1 minus P of A, which makes sense. Because if those are the two possible cases, either A happens or A doesn't happen, then when you add up those two cases, you must get 1, which means that P of not A must just be 1 minus P of A. Because P of A and P of not A must sum up to the number 1. They must include all of the possible cases. We've seen an expression for calculating the probability of A and B. We might also reasonably want to calculate the probability of A or B. What is the probability that one thing happens or another thing happens? So for example, I might want to calculate what is the probability that if I roll two dice, a red die and a blue die, what is the likelihood that A is a 6 or B is a 6, like one or the other? And what you might imagine you could do, and the wrong way to approach it, would be just to say, all right, well, A comes up as a 6 with the red die comes up as a 6 with probability 1 over 6. The same for the blue die, it's also 1 over 6. Add them together, and you get 2 over 6, otherwise known as 1 third. But this suffers from a problem of over counting, that we've double counted the case, where both A and B, both the red die and the blue die, both come up as a 6-roll. And I've counted that instance twice. So to resolve this, the actual expression for calculating the probability of A or B uses what we call the inclusion-exclusion formula. So I take the probability of A, add it to the probability of B. That's all same as before. But then I need to exclude the cases that I've double counted. So I subtract from that the probability of A and B. And that gets me the result for A or B. I consider all the cases where A is true and all the cases where B is true. And if you imagine this is like a Venn diagram of cases where A is true, cases where B is true, I just need to subtract out the middle to get rid of the cases that I have overcounted by double counting them inside of both of these individual expressions. One other rule that's going to be quite helpful is a rule called marginalization. So marginalization is answering the question of how do I figure out the probability of A using some other variable that I might have access to, like B? Even if I don't know additional information about it, I know that B, some event, can have two possible states, either B happens or B doesn't happen, assuming it's a Boolean, true or false. And well, what that means is that for me to be able to calculate the probability of A, there are only two cases. Either A happens and B happens, or A happens and B doesn't happen. And those are two disjoint, meaning they can't both happen together. Either B happens or B doesn't happen. They're disjoint or separate cases. And so I can figure out the probability of A just by adding up those two cases. The probability that A is true is the probability that A and B is true, plus the probability that A is true and B isn't true. So by marginalizing, I've looked at the two possible cases that might take place, either B happens or B doesn't happen. And in either of those cases, I look at what's the probability that A happens. And if I add those together, well, then I get the probability that A happens as a whole. So take a look at that rule. It doesn't matter what B is or how it's related to A. So long as I know these joint distributions, I can figure out the overall probability of A. And this can be a useful way if I have a joint distribution, like the joint distribution of A and B, to just figure out some unconditional probability, like the probability of A. And we'll see examples of this soon as well. Now, sometimes these might not just be random, might not just be variables that are events that are like they happened or they didn't happen, like B is here. They might be some broader probability distribution where there are multiple possible values. And so here, in order to use this marginalization rule, I need to sum up not just over B and not B, but for all of the possible values that the other random variable could take on. And so here, we'll see a version of this rule for random variables. And it's going to include that summation notation to indicate that I'm summing up, adding up a whole bunch of individual values. So here's the rule. Looks a lot more complicated, but it's actually the equivalent exactly the same rule. What I'm saying here is that if I have two random variables, one called x and one called y, well, the probability that x is equal to some value x sub i, this is just some value that this variable takes on. How do I figure it out? Well, I'm going to sum up over j, where j is going to range over all of the possible values that y can take on. Well, let's look at the probability that x equals xi and y equals yj. So the exact same rule, the only difference here is now I'm summing up over all of the possible values that y can take on, saying let's add up all of those possible cases and look at this joint distribution, this joint probability, that x takes on the value I care about, given all of the possible values for y. And if I add all those up, then I can get this unconditional probability of what x is equal to, whether or not x is equal to some value x sub i. So let's take a look at this rule, because it does look a little bit complicated. Let's try and put a concrete example to it. Here again is that same joint distribution from before. I have cloud, not cloudy, rainy, not rainy. And maybe I want to access some variable. I want to know what is the probability that it is cloudy. Well, marginalization says that if I have this joint distribution and I want to know what is the probability that it is cloudy, well, I need to consider the other variable, the variable that's not here, the idea that it's rainy. And I consider the two cases, either it's raining or it's not raining. And I just sum up the values for each of those possibilities. In other words, the probability that it is cloudy is equal to the sum of the probability that it's cloudy and it's rainy and the probability that it's cloudy and it is not raining. And so these now are values that I have access to. These are values that are just inside of this joint probability table. What is the probability that it is both cloudy and rainy? Well, it's just the intersection of these two here, which is 0.08. And the probability that it's cloudy and not raining is, all right, here's cloudy, here's not raining. It's 0.32. So it's 0.08 plus 0.32, which just gives us equal to 0.4. That is the unconditional probability that it is, in fact, cloudy. And so marginalization gives us a way to go from these joint distributions to just some individual probability that I might care about. And you'll see a little bit later why it is that we care about that and why that's actually useful to us as we begin doing some of these calculations. Last rule we'll take a look at before transitioning to something a little bit different is this rule of conditioning, very similar to the marginalization rule. But it says that, again, if I have two events, a and b, but instead of having access to their joint probabilities, I have access to their conditional probabilities, how they relate to each other. Well, again, if I want to know the probability that a happens, and I know that there's some other variable b, either b happens or b doesn't happen, and so I can say that the probability of a is the probability of a given b times the probability of b, meaning b happened. And given that I know b happened, what's the likelihood that a happened? And then I consider the other case, that b didn't happen. So here's the probability that b didn't happen. And here's the probability that a happens, given that I know that b didn't happen. And this is really the equivalent rule just using conditional probability instead of joint probability, where I'm saying let's look at both of these two cases and condition on b. Look at the case where b happens, and look at the case where b doesn't happen, and look at what probabilities I get as a result. And just as in the case of marginalization, where there was an equivalent rule for random variables that could take on multiple possible values in a domain of possible values, here, too, conditioning has the same equivalent rule. Again, there's a summation to mean I'm summing over all of the possible values that some random variable y could take on. But if I want to know what is the probability that x takes on this value, then I'm going to sum up over all the values j that y could take on, and say, all right, what's the chance that y takes on that value yj? And multiply it by the conditional probability that x takes on this value, given that y took on that value yj. So equivalent rule just using conditional probabilities instead of joint probabilities. And using the equation we know about joint probabilities, we can translate between these two. So all right, we've seen a whole lot of mathematics, and we've just laid the foundation for mathematics. And no need to worry if you haven't seen probability in too much detail up until this point. These are the foundations of the ideas that are going to come up as we begin to explore how we can now take these ideas from probability and begin to apply them to represent something inside of our computer, something inside of the AI agent we're trying to design that is able to represent information and probabilities and the likelihoods between various different events. So there are a number of different probabilistic models that we can generate, but the first of the models we're going to talk about are what are known as Bayesian networks. And a Bayesian network is just going to be some network of random variables, connected random variables that are going to represent the dependence between these random variables. The odds are most random variables in this world are not independent from each other, but there's some relationship between things that are happening that we care about. If it is rainy today, that might increase the likelihood that my flight or my train gets delayed, for example. There are some dependence between these random variables, and a Bayesian network is going to be able to capture those dependencies. So what is a Bayesian network? What is its actual structure, and how does it work? Well, a Bayesian network is going to be a directed graph. And again, we've seen directed graphs before. They are individual nodes with arrows or edges that connect one node to another node pointing in a particular direction. And so this directed graph is going to have nodes as well, where each node in this directed graph is going to represent a random variable, something like the weather, or something like whether my train was on time or delayed. And we're going to have an arrow from a node x to a node y to mean that x is a parent of y. So that'll be our notation. If there's an arrow from x to y, x is going to be considered a parent of y. And the reason that's important is because each of these nodes is going to have a probability distribution that we're going to store along with it, which is the distribution of x given some evidence, given the parents of x. So the way to more intuitively think about this is the parents seem to be thought of as sort of causes for some effect that we're going to observe. And so let's take a look at an actual example of a Bayesian network and think about the types of logic that might be involved in reasoning about that network. Let's imagine for a moment that I have an appointment out of town, and I need to take a train in order to get to that appointment. So what are the things I might care about? Well, I care about getting to my appointment on time. Whether I make it to my appointment and I'm able to attend it or I miss the appointment. And you might imagine that that's influenced by the train, that the train is either on time or it's delayed, for example. But that train itself is also influenced. Whether the train is on time or not depends maybe on the rain. Is there no rain? Is it light rain? Is there heavy rain? And it might also be influenced by other variables too. It might be influenced as well by whether or not there's maintenance on the train track, for example. If there is maintenance on the train track, that probably increases the likelihood that my train is delayed. And so we can represent all of these ideas using a Bayesian network that looks a little something like this. Here I have four nodes representing four random variables that I would like to keep track of. I have one random variable called rain that can take on three possible values in its domain, either none or light or heavy, for no rain, light rain, or heavy rain. I have a variable called maintenance for whether or not there is maintenance on the train track, which it has two possible values, just either yes or no. Either there is maintenance or there's no maintenance happening on the track. Then I have a random variable for the train indicating whether or not the train was on time or not. That random variable has two possible values in its domain. The train is either on time or the train is delayed. And then finally, I have a random variable for whether I make it to my appointment. For my appointment down here, I have a random variable called appointment that itself has two possible values, attend and miss. And so here are the possible values. Here are my four nodes, each of which represents a random variable, each of which has a domain of possible values that it can take on. And the arrows, the edges pointing from one node to another, encode some notion of dependence inside of this graph, that whether I make it to my appointment or not is dependent upon whether the train is on time or delayed. And whether the train is on time or delayed is dependent on two things given by the two arrows pointing at this node. It is dependent on whether or not there was maintenance on the train track. And it is also dependent upon whether or not it was raining or whether it is raining. And just to make things a little complicated, let's say as well that whether or not there is maintenance on the track, this too might be influenced by the rain. That if there's heavier rain, well, maybe it's less likely that it's going to be maintenance on the train track that day because they're more likely to want to do maintenance on the track on days when it's not raining, for example. And so these nodes might have different relationships between them. But the idea is that we can come up with a probability distribution for any of these nodes based only upon its parents. And so let's look node by node at what this probability distribution might actually look like. And we'll go ahead and begin with this root node, this rain node here, which is at the top, and has no arrows pointing into it, which means its probability distribution is not going to be a conditional distribution. It's not based on anything. I just have some probability distribution over the possible values for the rain random variable. And that distribution might look a little something like this. None, light and heavy, each have a possible value. Here I'm saying the likelihood of no rain is 0.7, of light rain is 0.2, of heavy rain is 0.1, for example. So here is a probability distribution for this root node in this Bayesian network. And let's now consider the next node in the network, maintenance. Track maintenance is yes or no. And the general idea of what this distribution is going to encode, at least in this story, is the idea that the heavier the rain is, the less likely it is that there's going to be maintenance on the track. Because the people that are doing maintenance on the track probably want to wait until a day when it's not as rainy in order to do the track maintenance, for example. And so what might that probability distribution look like? Well, this now is going to be a conditional probability distribution, that here are the three possible values for the rain random variable, which I'm here just going to abbreviate to R, either no rain, light rain, or heavy rain. And for each of those possible values, either there is yes track maintenance or no track maintenance. And those have probabilities associated with them. That I see here that if it is not raining, then there is a probability of 0.4 that there's track maintenance and a probability of 0.6 that there isn't. But if there's heavy rain, then here the chance that there is track maintenance is 0.1 and the chance that there is not track maintenance is 0.9. Each of these rows is going to sum up to 1. Because each of these represent different values of whether or not it's raining, the three possible values that that random variable can take on. And each is associated with its own probability distribution that is ultimately all going to add up to the number 1. So that there is our distribution for this random variable called maintenance, about whether or not there is maintenance on the train track. And now let's consider the next variable. Here we have a node inside of our Bayesian network called train that has two possible values, on time and delayed. And this node is going to be dependent upon the two nodes that are pointing towards it, that whether or not the train is on time or delayed depends on whether or not there is track maintenance. And it depends on whether or not there is rain, that heavier rain probably means more likely that my train is delayed. And if there is track maintenance, that also probably means it's more likely that my train is delayed as well. And so you could construct a larger probability distribution, a conditional probability distribution, that instead of conditioning on just one variable, as was the case here, is now conditioning on two variables, conditioning both on rain represented by r and on maintenance represented by yes. Again, each of these rows has two values that sum up to the number 1, one for whether the train is on time, one for whether the train is delayed. And here I can say something like, all right, if I know there was light rain and track maintenance, well, OK, that would be r is light and m is yes. Well, then there is a probability of 0.6 that my train is on time, and a probability of 0.4 the train is delayed. And you can imagine gathering this data just by looking at real world data, looking at data about, all right, if I knew that it was light rain and there was track maintenance, how often was a train delayed or not delayed? And you could begin to construct this thing. The interesting thing is intelligently, being able to try to figure out how might you go about ordering these things, what things might influence other nodes inside of this Bayesian network. And the last thing I care about is whether or not I make it to my appointment. So did I attend or miss the appointment? And ultimately, whether I attend or miss the appointment, it is influenced by track maintenance, because it's indirectly this idea that, all right, if there is track maintenance, well, then my train might more likely be delayed. And if my train is more likely to be delayed, then I'm more likely to miss my appointment. But what we encode in this Bayesian network are just what we might consider to be more direct relationships. So the train has a direct influence on the appointment. And given that I know whether the train is on time or delayed, knowing whether there's track maintenance isn't going to give me any additional information that I didn't already have. That if I know train, these other nodes that are up above isn't really going to influence the result. And so here we might represent it using another conditional probability distribution that looks a little something like this. The train can take on two possible values. Either my train is on time or my train is delayed. And for each of those two possible values, I have a distribution for what are the odds that I'm able to attend the meeting and what are the odds that I missed the meeting. And obviously, if my train is on time, I'm much more likely to be able to attend the meeting than if my train is delayed, in which case I'm more likely to miss that meeting. So all of these nodes put all together here represent this Bayesian network, this network of random variables whose values I ultimately care about, and that have some sort of relationship between them, some sort of dependence where these arrows from one node to another indicate some dependence, that I can calculate the probability of some node given the parents that happen to exist there. So now that we've been able to describe the structure of this Bayesian network and the relationships between each of these nodes by associating each of the nodes in the network with a probability distribution, whether that's an unconditional probability distribution in the case of this root node here, like rain, and a conditional probability distribution in the case of all of the other nodes whose probabilities are dependent upon the values of their parents, we can begin to do some computation and calculation using the information inside of that table. So let's imagine, for example, that I just wanted to compute something simple like the probability of light rain. How would I get the probability of light rain? Well, light rain, rain here is a root node. And so if I wanted to calculate that probability, I could just look at the probability distribution for rain and extract from it the probability of light rains, just a single value that I already have access to. But we could also imagine wanting to compute more complex joint probabilities, like the probability that there is light rain and also no track maintenance. This is a joint probability of two values, light rain and no track maintenance. And the way I might do that is first by starting by saying, all right, well, let me get the probability of light rain. But now I also want the probability of no track maintenance. But of course, this node is dependent upon the value of rain. So what I really want is the probability of no track maintenance, given that I know that there was light rain. And so the expression for calculating this idea that the probability of light rain and no track maintenance is really just the probability of light rain and the probability that there is no track maintenance, given that I know that there already is light rain. So I take the unconditional probability of light rain, multiply it by the conditional probability of no track maintenance, given that I know there is light rain. And you can continue to do this again and again for every variable that you want to add into this joint probability that I might want to calculate. If I wanted to know the probability of light rain and no track maintenance and a delayed train, well, that's going to be the probability of light rain, multiplied by the probability of no track maintenance, given light rain, multiplied by the probability of a delayed train, given light rain and no track maintenance. Because whether the train is on time or delayed is dependent upon both of these other two variables. And so I have two pieces of evidence that go into the calculation of that conditional probability. And each of these three values is just a value that I can look up by looking at one of these individual probability distributions that is encoded into my Bayesian network. And if I wanted a joint probability over all four of the variables, something like the probability of light rain and no track maintenance and a delayed train and I miss my appointment, well, that's going to be multiplying four different values, one from each of these individual nodes. It's going to be the probability of light rain, then of no track maintenance given light rain, then of a delayed train, given light rain and no track maintenance. And then finally, for this node here, for whether I make it to my appointment or not, it's not dependent upon these two variables, given that I know whether or not the train is on time. I only need to care about the conditional probability that I miss my train, or that I miss my appointment, given that the train happens to be delayed. And so that's represented here by four probabilities, each of which is located inside of one of these probability distributions for each of the nodes, all multiplied together. And so I can take a variable like that and figure out what the joint probability is by multiplying a whole bunch of these individual probabilities from the Bayesian network. But of course, just as with last time, where what I really wanted to do was to be able to get new pieces of information, here, too, this is what we're going to want to do with our Bayesian network. In the context of knowledge, we talked about the problem of inference. Given things that I know to be true, can I draw conclusions, make deductions about other facts about the world that I also know to be true? And what we're going to do now is apply the same sort of idea to probability. Using information about which I have some knowledge, whether some evidence or some probabilities, can I figure out not other variables for certain, but can I figure out the probabilities of other variables taking on particular values? And so here, we introduce the problem of inference in a probabilistic setting, in a case where variables might not necessarily be true for sure, but they might be random variables that take on different values with some probability. So how do we formally define what exactly this inference problem actually is? Well, the inference problem has a couple of parts to it. We have some query, some variable x that we want to compute the distribution for. Maybe I want the probability that I miss my train, or I want the probability that there is track maintenance, something that I want information about. And then I have some evidence variables. Maybe it's just one piece of evidence. Maybe it's multiple pieces of evidence. But I've observed certain variables for some sort of event. So for example, I might have observed that it is raining. This is evidence that I have. I know that there is light rain, or I know that there is heavy rain. And that is evidence I have. And using that evidence, I want to know what is the probability that my train is delayed, for example. And that is a query that I might want to ask based on this evidence. So I have a query, some variable. Evidence, which are some other variables that I have observed inside of my Bayesian network. And of course, that does leave some hidden variables. Why? These are variables that are not evidence variables and not query variables. So you might imagine in the case where I know whether or not it's raining, and I want to know whether my train is going to be delayed or not, the hidden variable, the thing I don't have access to, is something like, is there maintenance on the track? Or am I going to make or not make my appointment, for example? These are variables that I don't have access to. They're hidden because they're not things I observed, and they're also not the query, the thing that I'm asking. And so ultimately, what we want to calculate is I want to know the probability distribution of x given e, the event that I observed. So given that I observed some event, I observed that it is raining, I would like to know what is the distribution over the possible values of the train random variable. Is it on time? Is it delayed? What's the likelihood it's going to be there? And it turns out we can do this calculation just using a lot of the probability rules that we've already seen in action. And ultimately, we're going to take a look at the math at a little bit of a high level, at an abstract level. But ultimately, we can allow computers and programming libraries that already exist to begin to do some of this math for us. But it's good to get a general sense for what's actually happening when this inference process takes place. Let's imagine, for example, that I want to compute the probability distribution of the appointment random variable given some evidence, given that I know that there was light rain and no track maintenance. So there's my evidence, these two variables that I observe the values of. I observe the value of rain. I know there's light rain. And I know that there is no track maintenance going on today. And what I care about knowing, my query, is this random variable appointment. I want to know the distribution of this random variable appointment, like what is the chance that I'm able to attend my appointment? What is the chance that I miss my appointment given this evidence? And the hidden variable, the information that I don't have access to, is this variable train. This is information that is not part of the evidence that I see, not something that I observe. But it is also not the query that I'm asking for. And so what might this inference procedure look like? Well, if you recall back from when we were defining conditional probability and doing math with conditional probabilities, we know that a conditional probability is proportional to the joint probability. And we remembered this by recalling that the probability of A given B is just some constant factor alpha multiplied by the probability of A and B. That constant factor alpha turns out to be like dividing over the probability of B. But the important thing is that it's just some constant multiplied by the joint distribution, the probability that all of these individual things happen. So in this case, I can take the probability of the appointment random variable given light rain and no track maintenance and say that is just going to be proportional, some constant alpha, multiplied by the joint probability, the probability of a particular value for the appointment random variable and light rain and no track maintenance. Well, all right, how do I calculate this, probability of appointment and light rain and no track maintenance, when what I really care about is knowing I need all four of these values to be able to calculate a joint distribution across everything because in a particular appointment depends upon the value of train? Well, in order to do that, here I can begin to use that marginalization trick, that there are only two ways I can get any configuration of an appointment, light rain, and no track maintenance. Either this particular setting of variables happens and the train is on time, or this particular setting of variables happens and the train is delayed. Those are two possible cases that I would want to consider. And if I add those two cases up, well, then I get the result just by adding up all of the possibilities for the hidden variable or variables that there are multiple. But since there's only one hidden variable here, train, all I need to do is iterate over all the possible values for that hidden variable train and add up their probabilities. So this probability expression here becomes probability distribution over appointment, light, no rain, and train is on time, and the probability distribution over the appointment, light rain, no track maintenance, and that the train is delayed, for example. So I take both of the possible values for train, go ahead and add them up. These are just joint probabilities that we saw earlier, how to calculate just by going parent, parent, parent, parent, and calculating those probabilities and multiplying them together. And then you'll need to normalize them at the end, speaking at a high level, to make sure that everything adds up to the number 1. So the formula for how you do this in a process known as inference by enumeration looks a little bit complicated, but ultimately it looks like this. And let's now try to distill what it is that all of these symbols actually mean. Let's start here. What I care about knowing is the probability of x, my query variable, given some sort of evidence. What do I know about conditional probabilities? Well, a conditional probability is proportional to the joint probability. So it is some alpha, some normalizing constant, multiplied by this joint probability of x and evidence. And how do I calculate that? Well, to do that, I'm going to marginalize over all of the hidden variables, all the variables that I don't directly observe the values for. I'm basically going to iterate over all of the possibilities that it could happen and just sum them all up. And so I can translate this into a sum over all y, which ranges over all the possible hidden variables and the values that they could take on, and adds up all of those possible individual probabilities. And that is going to allow me to do this process of inference by enumeration. Now, ultimately, it's pretty annoying if we as humans have to do all this math for ourselves. But turns out this is where computers and AI can be particularly helpful, that we can program a computer to understand a Bayesian network, to be able to understand these inference procedures, and to be able to do these calculations. And using the information you've seen here, you could implement a Bayesian network from scratch yourself. But turns out there are a lot of libraries, especially written in Python, that allow us to make it easier to do this sort of probabilistic inference, to be able to take a Bayesian network and do these sorts of calculations, so that you don't need to know and understand all of the underlying math, though it's helpful to have a general sense for how it works. But you just need to be able to describe the structure of the network and make queries in order to be able to produce the result. And so let's take a look at an example of that right now. It turns out that there are a lot of possible libraries that exist in Python for doing this sort of inference. It doesn't matter too much which specific library you use. They all behave in fairly similar ways. But the library I'm going to use here is one known as pomegranate. And here inside of model.py, I have defined a Bayesian network, just using the structure and the syntax that the pomegranate library expects. And what I'm effectively doing is just, in Python, creating nodes to represent each of the nodes of the Bayesian network that you saw me describe a moment ago. So here on line four, after I've imported pomegranate, I'm defining a variable called rain that is going to represent a node inside of my Bayesian network. It's going to be a node that follows this distribution, where there are three possible values, none for no rain, light for light rain, heavy for heavy rain. And these are the probabilities of each of those taking place. 0.7 is the likelihood of no rain, 0.2 for light rain, 0.1 for heavy rain. Then after that, we go to the next variable, the variable for track maintenance, for example, which is dependent upon that rain variable. And this, instead of being an unconditional distribution, is a conditional distribution, as indicated by a conditional probability table here. And the idea is that I'm following this is conditional on the distribution of rain. So if there is no rain, then the chance that there is, yes, track maintenance is 0.4. If there's no rain, the chance that there is no track maintenance is 0.6. Likewise, for light rain, I have a distribution. For heavy rain, I have a distribution as well. But I'm effectively encoding the same information you saw represented graphically a moment ago. But I'm telling this Python program that the maintenance node obeys this particular conditional probability distribution. And we do the same thing for the other random variables as well. Train was a node inside my distribution that was a conditional probability table with two parents. It was dependent not only on rain, but also on track maintenance. And so here I'm saying something like, given that there is no rain and, yes, track maintenance, the probability that my train is on time is 0.8. And the probability that it's delayed is 0.2. And likewise, I can do the same thing for all of the other possible values of the parents of the train node inside of my Bayesian network by saying, for all of those possible values, here is the distribution that the train node should follow. Then I do the same thing for an appointment based on the distribution of the variable train. Then at the end, what I do is actually construct this network by describing what the states of the network are and by adding edges between the dependent nodes. So I create a new Bayesian network, add states to it, one for rain, one for maintenance, one for the train, one for the appointment. And then I add edges connecting the related pieces. Rain has an arrow to maintenance because rain influences track maintenance. Rain also influences the train. Maintenance also influences the train. And train influences whether I make it to my appointment and bake just finalizes the model and does some additional computation. So the specific syntax of this is not really the important part. Pomegranate just happens to be one of several different libraries that can all be used for similar purposes. And you could describe and define a library for yourself that implemented similar things. But the key idea here is that someone can design a library for a general Bayesian network that has nodes that are based upon its parents. And then all a programmer needs to do using one of those libraries is to define what those nodes and what those probability distributions are. And we can begin to do some interesting logic based on it. So let's try doing that conditional or joint probability calculation that we saw us do by hand before by going into likelihood.py, where here I'm importing the model that I just defined a moment ago. And here I'd just like to calculate model.probability, which calculates the probability for a given observation. And I'd like to calculate the probability of no rain, no track maintenance, my train is on time, and I'm able to attend the meeting. So sort of the optimal scenario that there is no rain and no maintenance on the track, my train is on time, and I'm able to attend the meeting. What is the probability that all of that actually happens? And I can calculate that using the library and just print out its probability. And so I'll go ahead and run python of likelihood.py. And I see that, OK, the probability is about 0.34. So about a third of the time, everything goes right for me in this case. No rain, no track maintenance, train is on time, and I'm able to attend the meeting. But I could experiment with this, try and calculate other probabilities as well. What's the probability that everything goes right up until the train, but I still miss my meeting? So no rain, no track maintenance, train is on time, but I miss the appointment. Let's calculate that probability. And all right, that has a probability of about 0.04. So about 4% of the time, the train will be on time, there won't be any rain, no track maintenance, and yet I'll still miss the meeting. And so this is really just an implementation of the calculation of the joint probabilities that we did before. What this library is likely doing is first figuring out the probability of no rain, then figuring out the probability of no track maintenance given no rain, then the probability that my train is on time given both of these values, and then the probability that I miss my appointment given that I know that the train was on time. So this, again, is the calculation of that joint probability. And turns out we can also begin to have our computer solve inference problems as well, to begin to infer, based on information, evidence that we see, what is the likelihood of other variables also being true. So let's go into inference.py, for example. We're here, I'm again importing that exact same model from before, importing all the nodes and all the edges and the probability distribution that is encoded there as well. And now there's a function for doing some sort of prediction. And here, into this model, I pass in the evidence that I observe. So here, I've encoded into this Python program the evidence that I have observed. I have observed the fact that the train is delayed. And that is the value for one of the four random variables inside of this Bayesian network. And using that information, I would like to be able to draw inspiration and figure out inferences about the values of the other random variables that are inside of my Bayesian network. I would like to make predictions about everything else. So all of the actual computational logic is happening in just these three lines, where I'm making this call to this prediction. Down below, I'm just iterating over all of the states and all the predictions and just printing them out so that we can visually see what the results are. But let's find out, given the train is delayed, what can I predict about the values of the other random variables? Let's go ahead and run python inference.py. I run that, and all right, here is the result that I get. Given the fact that I know that the train is delayed, this is evidence that I have observed. Well, given that there is a 45% chance or a 46% chance that there was no rain, a 31% chance there was light rain, a 23% chance there was heavy rain, I can see a probability distribution of a track maintenance and a probability distribution over whether I'm able to attend or miss my appointment. Now, we know that whether I attend or miss the appointment, that is only dependent upon the train being delayed or not delayed. It shouldn't depend on anything else. So let's imagine, for example, that I knew that there was heavy rain. That shouldn't affect the distribution for making the appointment. And indeed, if I go up here and add some evidence, say that I know that the value of rain is heavy. That is evidence that I now have access to. I now have two pieces of evidence. I know that the rain is heavy, and I know that my train is delayed. I can calculate the probability by running this inference procedure again and seeing the result. I know that the rain is heavy. I know my train is delayed. The probability distribution for track maintenance changed. Given that I know that there's heavy rain, now it's more likely that there is no track maintenance, 88%, as opposed to 64% from here before. And now, what is the probability that I make the appointment? Well, that's the same as before. It's still going to be attend the appointment with probability 0.6, missed the appointment with probability 0.4, because it was only dependent upon whether or not my train was on time or delayed. And so this here is implementing that idea of that inference algorithm to be able to figure out, based on the evidence that I have, what can we infer about the values of the other variables that exist as well. So inference by enumeration is one way of doing this inference procedure, just looping over all of the values the hidden variables could take on and figuring out what the probability is. Now, it turns out this is not particularly efficient. And there are definitely optimizations you can make by avoiding repeated work. If you're calculating the same sort of probability multiple times, there are ways of optimizing the program to avoid having to recalculate the same probabilities again and again. But even then, as the number of variables get large, as the number of possible values of variables could take on, get large, we're going to start to have to do a lot of computation, a lot of calculation, to be able to do this inference. And at that point, it might start to get unreasonable, in terms of the amount of time that it would take to be able to do this sort of exact inference. And it's for that reason that oftentimes, when it comes towards probability and things we're not entirely sure about, we don't always care about doing exact inference and knowing exactly what the probability is. But if we can approximate the inference procedure, do some sort of approximate inference, that that can be pretty good as well. That if I don't know the exact probability, but I have a general sense for the probability that I can get increasingly accurate with more time, that that's probably pretty good, especially if I can get that to happen even faster. So how could I do approximate inference inside of a Bayesian network? Well, one method is through a procedure known as sampling. In the process of sampling, I'm going to take a sample of all of the variables inside of this Bayesian network here. And how am I going to sample? Well, I'm going to sample one of the values from each of these nodes according to their probability distribution. So how might I take a sample of all these nodes? Well, I'll start at the root. I'll start with rain. Here's the distribution for rain. And I'll go ahead and, using a random number generator or something like it, randomly pick one of these three values. I'll pick none with probability 0.7, light with probability 0.2, and heavy with probability 0.1. So I'll randomly just pick one of them according to that distribution. And maybe in this case, I pick none, for example. Then I do the same thing for the other variable. Maintenance also has a probability distribution. And I'm going to sample. Now, there are three probability distributions here. But I'm only going to sample from this first row here, because I've observed already in my sample that the value of rain is none. So given that rain is none, I'm going to sample from this distribution to say, all right, what should the value of maintenance be? And in this case, maintenance is going to be, let's just say yes, which happens 40% of the time in the event that there is no rain, for example. And we'll sample all of the rest of the nodes in this way as well, that I want to sample from the train distribution. And I'll sample from this first row here, where there is no rain, but there is track maintenance. And I'll sample 80% of the time. I'll say the train is on time. 20% of the time, I'll say the train is delayed. And finally, we'll do the same thing for whether I make it to my appointment or not. Did I attend or miss the appointment? We'll sample based on this distribution and maybe say that in this case, I attend the appointment, which happens 90% of the time when the train is actually on time. So by going through these nodes, I can very quickly just do some sampling and get a sample of the possible values that could come up from going through this entire Bayesian network according to those probability distributions. And where this becomes powerful is if I do this not once, but I do this thousands or tens of thousands of times and generate a whole bunch of samples all using this distribution. I get different samples. Maybe some of them are the same. But I get a value for each of the possible variables that could come up. And so then if I'm ever faced with a question, a question like, what is the probability that the train is on time, you could do an exact inference procedure. This is no different than the inference problem we had before where I could just marginalize, look at all the possible other values of the variables, and do the computation of inference by enumeration to find out this probability exactly. But I could also, if I don't care about the exact probability, just sample it, approximate it to get close. And this is a powerful tool in AI where we don't need to be right 100% of the time or we don't need to be exactly right. If we just need to be right with some probability, we can often do so more effectively, more efficiently. And so if here now are all of those possible samples, I'll highlight the ones where the train is on time. I'm ignoring the ones where the train is delayed. And in this case, there's like six out of eight of the samples have the train is arriving on time. And so maybe in this case, I can say that in six out of eight cases, that's the likelihood that the train is on time. And with eight samples, that might not be a great prediction. But if I had thousands upon thousands of samples, then this could be a much better inference procedure to be able to do these sorts of calculations. So this is a direct sampling method to just do a bunch of samples and then figure out what the probability of some event is. Now, this from before was an unconditional probability. What is the probability that the train is on time? And I did that by looking at all the samples and figuring out, right, here are the ones where the train is on time. But sometimes what I want to calculate is not an unconditional probability, but rather a conditional probability, something like what is the probability that there is light rain, given that the train is on time, something to that effect. And to do that kind of calculation, well, what I might do is here are all the samples that I have. And I want to calculate a probability distribution, given that I know that the train is on time. So to be able to do that, I can kind of look at the two cases where the train was delayed and ignore or reject them, sort of exclude them from the possible samples that I'm considering. And now I want to look at these remaining cases where the train is on time. Here are the cases where there is light rain. And I say, OK, these are two out of the six possible cases. That can give me an approximation for the probability of light rain, given the fact that I know the train was on time. And I did that in almost exactly the same way, just by adding an additional step, by saying that, all right, when I take each sample, let me reject all of the samples that don't match my evidence and only consider the samples that do match what it is that I have in my evidence that I want to make some sort of calculation about. And it turns out, using the libraries that we've had for Bayesian networks, we can begin to implement this same sort of idea, like implement rejection sampling, which is what this method is called, to be able to figure out some probability, not via direct inference, but instead by sampling. So what I have here is a program called sample.py. Imports the exact same model. And what I define first is a program to generate a sample. And the way I generate a sample is just by looping over all of the states. The states need to be in some sort of order to make sure I'm looping in the correct order. But effectively, if it is a conditional distribution, I'm going to sample based on the parents. And otherwise, I'm just going to directly sample the variable, like rain, which has no parents. It's just an unconditional distribution and keep track of all those parent samples and return the final sample. The exact syntax of this, again, not particularly important. It just happens to be part of the implementation details of this particular library. The interesting logic is down below. Now that I have the ability to generate a sample, if I want to know the distribution of the appointment random variable, given that the train is delayed, well, then I can begin to do calculations like this. Let me take 10,000 samples and assemble all my results in this list called data. I'll go ahead and loop n times, in this case, 10,000 times. I'll generate a sample. And I want to know the distribution of appointment, given that the train is delayed. So according to rejection sampling, I'm only going to consider samples where the train is delayed. If the train is not delayed, I'm not going to consider those values at all. So I'm going to say, all right, if I take the sample, look at the value of the train random variable, if the train is delayed, well, let me go ahead and add to my data that I'm collecting the value of the appointment random variable that it took on in this particular sample. So I'm only considering the samples where the train is delayed. And for each of those samples, considering what the value of appointment is, and then at the end, I'm using a Python class called counter, which quickly counts up all the values inside of a data set. So I can take this list of data and figure out how many times was my appointment made and how many times was my appointment missed. And so this here, with just a couple lines of code, is an implementation of rejection sampling. And I can run it by going ahead and running Python sample.py. And when I do that, here is the result I get. This is the result of the counter. 1,251 times, I was able to attend the meeting. And 856 times, I was able to miss the meeting. And you can imagine, by doing more and more samples, I'll be able to get a better and better, more accurate result. And this is a randomized process. It's going to be an approximation of the probability. If I run it a different time, you'll notice the numbers are similar, 12, 72, and 905. But they're not identical because there's some randomization, some likelihood that things might be higher or lower. And so this is why we generally want to try and use more samples so that we can have a greater amount of confidence in our result, be more sure about the result that we're getting of whether or not it accurately reflects or represents the actual underlying probabilities that are inherent inside of this distribution. And so this, then, was an instance of rejection sampling. And it turns out there are a number of other sampling methods that you could use to begin to try to sample. One problem that rejection sampling has is that if the evidence you're looking for is a fairly unlikely event, well, you're going to be rejecting a lot of samples. Like if I'm looking for the probability of x given some evidence e, if e is very unlikely to occur, like occurs maybe one every 1,000 times, then I'm only going to be considering 1 out of every 1,000 samples that I do, which is a pretty inefficient method for trying to do this sort of calculation. I'm throwing away a lot of samples. And it takes computational effort to be able to generate those samples. So I'd like to not have to do something like that. So there are other sampling methods that can try and address this. One such sampling method is called likelihood weighting. In likelihood weighting, we follow a slightly different procedure. And the goal is to avoid needing to throw out samples that didn't match the evidence. And so what we'll do is we'll start by fixing the values for the evidence variables. Rather than sample everything, we're going to fix the values of the evidence variables and not sample those. Then we're going to sample all the other non-evidence variables in the same way, just using the Bayesian network looking at the probability distributions, sampling all the non-evidence variables. But then what we need to do is weight each sample by its likelihood. If our evidence is really unlikely, we want to make sure that we've taken into account how likely was the evidence to actually show up in the sample. If I have a sample where the evidence was much more likely to show up than another sample, then I want to weight the more likely one higher. So we're going to weight each sample by its likelihood, where likelihood is just defined as the probability of all the evidence. Given all the evidence we have, what is the probability that it would happen in that particular sample? So before, all of our samples were weighted equally. They all had a weight of 1 when we were calculating the overall average. In this case, we're going to weight each sample, multiply each sample by its likelihood in order to get the more accurate distribution. So what would this look like? Well, if I ask the same question, what is the probability of light rain, given that the train is on time, when I do the sampling procedure and start by trying to sample, I'm going to start by fixing the evidence variable. I'm already going to have in my sample the train is on time. That way, I don't have to throw out anything. I'm only sampling things where I know the value of the variables that are my evidence are what I expect them to be. So I'll go ahead and sample from rain. And maybe this time, I sample light rain instead of no rain. Then I'll sample from track maintenance and say, maybe, yes, there's track maintenance. Then for train, well, I've already fixed it in place. Train was an evidence variable. So I'm not going to bother sampling again. I'll just go ahead and move on. I'll move on to appointment and go ahead and sample from appointment as well. So now I've generated a sample. I've generated a sample by fixing this evidence variable and sampling the other three. And the last step is now weighting the sample. How much weight should it have? And the weight is based on how probable is it that the train was actually on time, this evidence actually happened, given the values of these other variables, light rain and the fact that, yes, there was track maintenance. Well, to do that, I can just go back to the train variable and say, all right, if there was light rain and track maintenance, the likelihood of my evidence, the likelihood that my train was on time, is 0.6. And so this particular sample would have a weight of 0.6. And I could repeat the sampling procedure again and again. Each time every sample would be given a weight according to the probability of the evidence that I see associated with it. And there are other sampling methods that exist as well, but all of them are designed to try and get it the same idea, to approximate the inference procedure of figuring out the value of a variable. So we've now dealt with probability as it pertains to particular variables that have these discrete values. But what we haven't really considered is how values might change over time. That we've considered something like a variable for rain, where rain can take on values of none or light rain or heavy rain. But in practice, usually when we consider values for variables like rain, we like to consider it for over time, how do the values of these variables change? What do we do with when we're dealing with uncertainty over a period of time, which can come up in the context of weather, for example, if I have sunny days and I have rainy days. And I'd like to know not just what is the probability that it's raining now, but what is the probability that it rains tomorrow, or the day after that, or the day after that. And so to do this, we're going to introduce a slightly different kind of model. But here, we're going to have a random variable, not just one for the weather, but for every possible time step. And you can define time step however you like. A simple way is just to use days as your time step. And so we can define a variable called x sub t, which is going to be the weather at time t. So x sub 0 might be the weather on day 0. x sub 1 might be the weather on day 1, so on and so forth. x sub 2 is the weather on day 2. But as you can imagine, if we start to do this over longer and longer periods of time, there's an incredible amount of data that might go into this. If you're keeping track of data about the weather for a year, now suddenly you might be trying to predict the weather tomorrow, given 365 days of previous pieces of evidence. And that's a lot of evidence to have to deal with and manipulate and calculate. Probably nobody knows what the exact conditional probability distribution is for all of those combinations of variables. And so when we're trying to do this inference inside of a computer, when we're trying to reasonably do this sort of analysis, it's helpful to make some simplifying assumptions, some assumptions about the problem that we can just assume are true, to make our lives a little bit easier. Even if they're not totally accurate assumptions, if they're close to accurate or approximate, they're usually pretty good. And the assumption we're going to make is called the Markov assumption, which is the assumption that the current state depends only on a finite fixed number of previous states. So the current day's weather depends not on all the previous day's weather for the rest of all of history, but the current day's weather I can predict just based on yesterday's weather, or just based on the last two days weather, or the last three days weather. But oftentimes, we're going to deal with just the one previous state that helps to predict this current state. And by putting a whole bunch of these random variables together, using this Markov assumption, we can create what's called a Markov chain, where a Markov chain is just some sequence of random variables where each of the variables distribution follows that Markov assumption. And so we'll do an example of this where the Markov assumption is, I can predict the weather. Is it sunny or rainy? And we'll just consider those two possibilities for now, even though there are other types of weather. But I can predict each day's weather just on the prior day's weather, using today's weather, I can come up with a probability distribution for tomorrow's weather. And here's what this weather might look like. It's formatted in terms of a matrix, as you might describe it, as rows and columns of values, where on the left-hand side, I have today's weather, represented by the variable x sub t. And over here in the columns, I have tomorrow's weather, represented by the variable x sub t plus 1, t plus 1 day's weather instead. And what this matrix is saying is, if today is sunny, well, then it's more likely than not that tomorrow is also sunny. Oftentimes, the weather stays consistent for multiple days in a row. And for example, let's say that if today is sunny, our model says that tomorrow, with probability 0.8, it will also be sunny. And with probability 0.2, it will be raining. And likewise, if today is raining, then it's more likely than not that tomorrow is also raining. With probability 0.7, it'll be raining. With probability 0.3, it will be sunny. So this matrix, this description of how it is we transition from one state to the next state is what we're going to call the transition model. And using the transition model, you can begin to construct this Markov chain by just predicting, given today's weather, what's the likelihood of tomorrow's weather happening. And you can imagine doing a similar sampling procedure, where you take this information, you sample what tomorrow's weather is going to be. Using that, you sample the next day's weather. And the result of that is you can form this Markov chain of like x0, time and time, day zero is sunny, the next day is sunny, maybe the next day it changes to raining, then raining, then raining. And the pattern that this Markov chain follows, given the distribution that we had access to, this transition model here, is that when it's sunny, it tends to stay sunny for a little while. The next couple of days tend to be sunny too. And when it's raining, it tends to be raining as well. And so you get a Markov chain that looks like this, and you can do analysis on this. You can say, given that today is raining, what is the probability that tomorrow is raining? Or you can begin to ask probability questions like, what is the probability of this sequence of five values, sun, sun, rain, rain, rain, and answer those sorts of questions too. And it turns out there are, again, many Python libraries for interacting with models like this of probabilities that have distributions and random variables that are based on previous variables according to this Markov assumption. And pomegranate2 has ways of dealing with these sorts of variables. So I'll go ahead and go into the chain directory, where I have some information about Markov chains. And here, I've defined a file called model.py, where I've defined in a very similar syntax. And again, the exact syntax doesn't matter so much as the idea that I'm encoding this information into a Python program so that the program has access to these distributions. I've here defined some starting distribution. So every Markov model begins at some point in time, and I need to give it some starting distribution. And so we'll just say, you know at the start, you can pick 50-50 between sunny and rainy. We'll say it's sunny 50% of the time, rainy 50% of the time. And then down below, I've here defined the transition model, how it is that I transition from one day to the next. And here, I've encoded that exact same matrix from before, that if it was sunny today, then with probability 0.8, it will be sunny tomorrow. And it'll be rainy tomorrow with probability 0.2. And I likewise have another distribution for if it was raining today instead. And so that alone defines the Markov model. You can begin to answer questions using that model. But one thing I'll just do is sample from the Markov chain. It turns out there is a method built into this Markov chain library that allows me to sample 50 states from the chain, basically just simulating like 50 instances of weather. And so let me go ahead and run this. Python model.py. And when I run it, what I get is that it's going to sample from this Markov chain 50 states, 50 days worth of weather that it's just going to randomly sample. And you can imagine sampling many times to be able to get more data, to be able to do more analysis. But here, for example, it's sunny two days in a row, rainy a whole bunch of days in a row before it changes back to sun. And so you get this model that follows the distribution that we originally described, that follows the distribution of sunny days tend to lead to more sunny days. Rainy days tend to lead to more rainy days. And that then is a Markov model. And Markov models rely on us knowing the values of these individual states. I know that today is sunny or that today is raining. And using that information, I can draw some sort of inference about what tomorrow is going to be like. But in practice, this often isn't the case. It often isn't the case that I know for certain what the exact state of the world is. Oftentimes, the state of the world is exactly unknown. But I'm able to somehow sense some information about that state, that a robot or an AI doesn't have exact knowledge about the world around it. But it has some sort of sensor, whether that sensor is a camera or sensors that detect distance or just a microphone that is sensing audio, for example. It is sensing data. And using that data, that data is somehow related to the state of the world, even if it doesn't actually know, our AI doesn't know, what the underlying true state of the world actually is. And for that, we need to get into the world of sensor models, the way of describing how it is that we translate what the hidden state, the underlying true state of the world, is with what the observation, what it is that the AI knows or the AI has access to, actually is. And so for example, a hidden state might be a robot's position. If a robot is exploring new uncharted territory, the robot likely doesn't know exactly where it is. But it does have an observation. It has robot sensor data, where it can sense how far away are possible obstacles around it. And using that information, using the observed information that it has, it can infer something about the hidden state. Because what the true hidden state is influences those observations. Whatever the robot's true position is affects or has some effect upon what the sensor data of the robot is able to collect is, even if the robot doesn't actually know for certain what its true position is. Likewise, if you think about a voice recognition or a speech recognition program that listens to you and is able to respond to you, something like Alexa or what Apple and Google are doing with their voice recognition as well, that you might imagine that the hidden state, the underlying state, is what words are actually spoken. The true nature of the world contains you saying a particular sequence of words, but your phone or your smart home device doesn't know for sure exactly what words you said. The only observation that the AI has access to is some audio waveforms. And those audio waveforms are, of course, dependent upon this hidden state. And you can infer, based on those audio waveforms, what the words spoken likely were. But you might not know with 100% certainty what that hidden state actually is. And it might be a task to try and predict, given this observation, given these audio waveforms, can you figure out what the actual words spoken are. And likewise, you might imagine on a website, true user engagement. Might be information you don't directly have access to. But you can observe data, like website or app analytics, about how often was this button clicked or how often are people interacting with a page in a particular way. And you can use that to infer things about your users as well. So this type of problem comes up all the time when we're dealing with AI and trying to infer things about the world. That often AI doesn't really know the hidden true state of the world. All the AI has access to is some observation that is related to the hidden true state. But it's not direct. There might be some noise there. The audio waveform might have some additional noise that might be difficult to parse. The sensor data might not be exactly correct. There's some noise that might not allow you to conclude with certainty what the hidden state is, but can allow you to infer what it might be. And so the simple example we'll take a look at here is imagining the hidden state as the weather, whether it's sunny or rainy or not. And imagine you are programming an AI inside of a building that maybe has access to just a camera to inside the building. And all you have access to is an observation as to whether or not employees are bringing an umbrella into the building or not. You can detect whether it's an umbrella or not. And so you might have an observation as to whether or not an umbrella is brought into the building or not. And using that information, you want to predict whether it's sunny or rainy, even if you don't know what the underlying weather is. So the underlying weather might be sunny or rainy. And if it's raining, obviously people are more likely to bring an umbrella. And so whether or not people bring an umbrella, your observation, tells you something about the hidden state. And of course, this is a bit of a contrived example, but the idea here is to think about this more broadly in terms of more generally, any time you observe something, it having to do with some underlying hidden state. And so to try and model this type of idea where we have these hidden states and observations, rather than just use a Markov model, which has state, state, state, state, each of which is connected by that transition matrix that we described before, we're going to use what we call a hidden Markov model. Very similar to a Markov model, but this is going to allow us to model a system that has hidden states that we don't directly observe, along with some observed event that we do actually see. And so in addition to that transition model that we still need of saying, given the underlying state of the world, if it's sunny or rainy, what's the probability of tomorrow's weather? We also need another model that, given some state, is going to give us an observation of green, yes, someone brings an umbrella into the office, or red, no, nobody brings umbrellas into the office. And so the observation might be that if it's sunny, then odds are nobody is going to bring an umbrella to the office. But maybe some people are just being cautious, and they do bring an umbrella to the office anyways. And if it's raining, then with much higher probability, then people are going to bring umbrellas into the office. But maybe if the rain was unexpected, people didn't bring an umbrella. And so it might have some other probability as well. And so using the observations, you can begin to predict with reasonable likelihood what the underlying state is, even if you don't actually get to observe the underlying state, if you don't get to see what the hidden state is actually equal to. This here we'll often call the sensor model. It's also often called the emission probabilities, because the state, the underlying state, emits some sort of emission that you then observe. And so that can be another way of describing that same idea. And the sensor Markov assumption that we're going to use is this assumption that the evidence variable, the thing we observe, the emission that gets produced, depends only on the corresponding state, meaning it can predict whether or not people will bring umbrellas or not entirely dependent just on whether it is sunny or rainy today. Of course, again, this assumption might not hold in practice, that in practice, it might depend whether or not people bring umbrellas, might depend not just on today's weather, but also on yesterday's weather and the day before. But for simplification purposes, it can be helpful to apply this sort of assumption just to allow us to be able to reason about these probabilities a little more easily. And if we're able to approximate it, we can still often get a very good answer. And so what these hidden Markov models end up looking like is a little something like this, where now, rather than just have one chain of states, like sun, sun, rain, rain, rain, we instead have this upper level, which is the underlying state of the world. Is it sunny or is it rainy? And those are connected by that transition matrix we described before. But each of these states produces an emission, produces an observation that I see, that on this day, it was sunny and people didn't bring umbrellas. And on this day, it was sunny, but people did bring umbrellas. And on this day, it was raining and people did bring umbrellas, and so on and so forth. And so each of these underlying states represented by x sub t for x sub 1, 0, 1, 2, so on and so forth, produces some sort of observation or emission, which is what the e stands for, e sub 0, e sub 1, e sub 2, so on and so forth. And so this, too, is a way of trying to represent this idea. And what you want to think about is that these underlying states are the true nature of the world, the robot's position as it moves over time, and that produces some sort of sensor data that might be observed, or what people are actually saying and using the emission data of what audio waveforms do you detect in order to process that data and try and figure it out. And there are a number of possible tasks that you might want to do given this kind of information. And one of the simplest is trying to infer something about the future or the past or about these sort of hidden states that might exist. And so the tasks that you'll often see, and we're not going to go into the mathematics of these tasks, but they're all based on the same idea of conditional probabilities and using the probability distributions we have to draw these sorts of conclusions. One task is called filtering, which is given observations from the start until now, calculate the distribution for the current state, meaning given information about from the beginning of time until now, on which days do people bring an umbrella or not bring an umbrella, can I calculate the probability of the current state that today, is it sunny or is it raining? Another task that might be possible is prediction, which is looking towards the future. Given observations about people bringing umbrellas from the beginning of when we started counting time until now, can I figure out the distribution that tomorrow is it sunny or is it raining? And you can also go backwards as well by a smoothing, where I can say given observations from start until now, calculate the distributions for some past state. Like I know that today people brought umbrellas and tomorrow people brought umbrellas. And so given two days worth of data of people bringing umbrellas, what's the probability that yesterday it was raining? And that I know that people brought umbrellas today, that might inform that decision as well. It might influence those probabilities. And there's also a most likely explanation task, in addition to other tasks that might exist as well, which is combining some of these given observations from the start up until now, figuring out the most likely sequence of states. And this is what we're going to take a look at now, this idea that if I have all these observations, umbrella, no umbrella, umbrella, no umbrella, can I calculate the most likely states of sun, rain, sun, rain, and whatnot that actually represented the true weather that would produce these observations? And this is quite common when you're trying to do something like voice recognition, for example, that you have these emissions of the audio waveforms, and you would like to calculate based on all of the observations that you have, what is the most likely sequence of actual words, or syllables, or sounds that the user actually made when they were speaking to this particular device, or other tasks that might come up in that context as well. And so we can try this out by going ahead and going into the HMM directory, HMM for Hidden Markov Model. And here, what I've done is I've defined a model where this model first defines my possible state, sun, and rain, along with their emission probabilities, the observation model, or the emission model, where here, given that I know that it's sunny, the probability that I see people bring an umbrella is 0.2, the probability of no umbrella is 0.8. And likewise, if it's raining, then people are more likely to bring an umbrella. Umbrella has probability 0.9, no umbrella has probability 0.1. So the actual underlying hidden states, those states are sun and rain, but the things that I observe, the observations that I can see, are either umbrella or no umbrella as the things that I observe as a result. So this then, I also need to add to it a transition matrix, same as before, saying that if today is sunny, then tomorrow is more likely to be sunny. And if today is rainy, then tomorrow is more likely to be raining. As of before, I give it some starting probabilities, saying at first, 50-50 chance for whether it's sunny or rainy. And then I can create the model based on that information. Again, the exact syntax of this is not so important, so much as it is the data that I am now encoding into a program, such that now I can begin to do some inference. So I can give my program, for example, a list of observations, umbrella, umbrella, no umbrella, umbrella, umbrella, so on and so forth, no umbrella, no umbrella. And I would like to calculate, I would like to figure out the most likely explanation for these observations. What is likely is whether rain, rain, is this rain, or is it more likely that this was actually sunny, and then it switched back to it being rainy? And that's an interesting question. We might not be sure, because it might just be that it just so happened on this rainy day, people decided not to bring an umbrella. Or it could be that it switched from rainy to sunny back to rainy, which doesn't seem too likely, but it certainly could happen. And using the data we give to the hidden Markov model, our model can begin to predict these answers, can begin to figure it out. So we're going to go ahead and just predict these observations. And then for each of those predictions, go ahead and print out what the prediction is. And this library just so happens to have a function called predict that does this prediction process for me. So I'll run python sequence.py. And the result I get is this. This is the prediction based on the observations of what all of those states are likely to be. And it's likely to be rain and rain. In this case, it thinks that what most likely happened is that it was sunny for a day and then went back to being rainy. But in different situations, if it was rainy for longer maybe, or if the probabilities were slightly different, you might imagine that it's more likely that it was rainy all the way through. And it just so happened on one rainy day, people decided not to bring umbrellas. And so here, too, Python libraries can begin to allow for the sort of inference procedure. And by taking what we know and by putting it in terms of these tasks that already exist, these general tasks that work with hidden Markov models, then any time we can take an idea and formulate it as a hidden Markov model, formulate it as something that has hidden states and observed emissions that result from those states, then we can take advantage of these algorithms that are known to exist for trying to do this sort of inference. So now we've seen a couple of ways that AI can begin to deal with uncertainty. We've taken a look at probability and how we can use probability to describe numerically things that are likely or more likely or less likely to happen than other events or other variables. And using that information, we can begin to construct these standard types of models, things like Bayesian networks and Markov chains and hidden Markov models that all allow us to be able to describe how particular events relate to other events or how the values of particular variables relate to other variables, not for certain, but with some sort of probability distribution. And by formulating things in terms of these models that already exist, we can take advantage of Python libraries that implement these sort of models already and allow us just to be able to use them to produce some sort of resulting effect. So all of this then allows our AI to begin to deal with these sort of uncertain problems so that our AI doesn't need to know things for certain but can infer based on information it doesn't know. Next time, we'll take a look at additional types of problems that we can solve by taking advantage of AI-related algorithms, even beyond the world of the types of problems we've already explored. We'll see you next time. OK. Welcome back, everyone, to an introduction to artificial intelligence with Python. And now, so far, we've taken a look at a couple of different types of problems. We've seen classical search problems where we're trying to get from an initial state to a goal by figuring out some optimal path. We've taken a look at adversarial search where we have a game-playing agent that is trying to make the best move. We've seen knowledge-based problems where we're trying to use logic and inference to be able to figure out and draw some additional conclusions. And we've seen some probabilistic models as well where we might not have certain information about the world, but we want to use the knowledge about probabilities that we do have to be able to draw some conclusions. Today, we're going to turn our attention to another category of problems generally known as optimization problems, where optimization is really all about choosing the best option from a set of possible options. And we've already seen optimization in some contexts, like game-playing, where we're trying to create an AI that chooses the best move out of a set of possible moves. But what we'll take a look at today is a category of types of problems and algorithms to solve them that can be used in order to deal with a broader range of potential optimization problems. And the first of the algorithms that we'll take a look at is known as a local search. And local search differs from search algorithms we've seen before in the sense that the search algorithms we've looked at so far, which are things like breadth-first search or A-star search, for example, generally maintain a whole bunch of different paths that we're simultaneously exploring, and we're looking at a bunch of different paths at once trying to find our way to the solution. On the other hand, in local search, this is going to be a search algorithm that's really just going to maintain a single node, looking at a single state. And we'll generally run this algorithm by maintaining that single node and then moving ourselves to one of the neighboring nodes throughout this search process. And this is generally useful in context not like these problems, which we've seen before, like a maze-solving situation where we're trying to find our way from the initial state to the goal by following some path. But local search is most applicable when we really don't care about the path at all, and all we care about is what the solution is. And in the case of solving a maze, the solution was always obvious. You could point to the solution. You know exactly what the goal is, and the real question is, what is the path to get there? But local search is going to come up in cases where figuring out exactly what the solution is, exactly what the goal looks like, is actually the heart of the challenge. And to give an example of one of these kinds of problems, we'll consider a scenario where we have two types of buildings, for example. We have houses and hospitals. And our goal might be in a world that's formatted as this grid, where we have a whole bunch of houses, a house here, house here, two houses over there, maybe we want to try and find a way to place two hospitals on this map. So maybe a hospital here and a hospital there. And the problem now is we want to place two hospitals on the map, but we want to do so with some sort of objective. And our objective in this case is to try and minimize the distance of any of the houses from a hospital. So you might imagine, all right, what's the distance from each of the houses to their nearest hospital? There are a number of ways we could calculate that distance. But one way is using a heuristic we've looked at before, which is the Manhattan distance, this idea of how many rows and columns would you have to move inside of this grid layout in order to get to a hospital, for example. And it turns out, if you take each of these four houses and figure out, all right, how close are they to their nearest hospital, you get something like this, where this house is three away from a hospital, this house is six away, and these two houses are each four away. And if you add all those numbers up together, you get a total cost of 17, for example. So for this particular configuration of hospitals, a hospital here and a hospital there, that state, we might say, has a cost of 17. And the goal of this problem now that we would like to apply a search algorithm to figure out is, can you solve this problem to find a way to minimize that cost? Minimize the total amount if you sum up all of the distances from all the houses to the nearest hospital. How can we minimize that final value? And if we think about this problem a little bit more abstractly, abstracting away from this specific problem and thinking more generally about problems like it, you can often formulate these problems by thinking about them as a state-space landscape, as we'll soon call it. Here in this diagram of a state-space landscape, each of these vertical bars represents a particular state that our world could be in. So for example, each of these vertical bars represents a particular configuration of two hospitals. And the height of this vertical bar is generally going to represent some function of that state, some value of that state. So maybe in this case, the height of the vertical bar represents what is the cost of this particular configuration of hospitals in terms of what is the sum total of all the distances from all of the houses to their nearest hospital. And generally speaking, when we have a state-space landscape, we want to do one of two things. We might be trying to maximize the value of this function, trying to find a global maximum, so to speak, of this state-space landscape, a single state whose value is higher than all of the other states that we could possibly choose from. And generally in this case, when we're trying to find a global maximum, we'll call the function that we're trying to optimize some objective function, some function that measures for any given state how good is that state, such that we can take any state, pass it into the objective function, and get a value for how good that state is. And ultimately, what our goal is is to find one of these states that has the highest possible value for that objective function. An equivalent but reversed problem is the problem of finding a global minimum, some state that has a value after you pass it into this function that is lower than all of the other possible values that we might choose from. And generally speaking, when we're trying to find a global minimum, we call the function that we're calculating a cost function. Generally, each state has some sort of cost, whether that cost is a monetary cost, or a time cost, or in the case of the houses and hospitals, we've been looking at just now, a distance cost in terms of how far away each of the houses is from a hospital. And we're trying to minimize the cost, find the state that has the lowest possible value of that cost. So these are the general types of ideas we might be trying to go for within a state space landscape, trying to find a global maximum, or trying to find a global minimum. And how exactly do we do that? We'll recall that in local search, we generally operate this algorithm by maintaining just a single state, just some current state represented inside of some node, maybe inside of a data structure, where we're keeping track of where we are currently. And then ultimately, what we're going to do is from that state, move to one of its neighbor states. So in this case, represented in this one-dimensional space by just the state immediately to the left or to the right of it. But for any different problem, you might define what it means for there to be a neighbor of a particular state. In the case of a hospital, for example, that we were just looking at, a neighbor might be moving one hospital one space to the left or to the right or up or down. Some state that is close to our current state, but slightly different, and as a result, might have a slightly different value in terms of its objective function or in terms of its cost function. So this is going to be our general strategy in local search, to be able to take a state, maintaining some current node, and move where we're looking at in the state space landscape in order to try to find a global maximum or a global minimum somehow. And perhaps the simplest of algorithms that we could use to implement this idea of local search is an algorithm known as hill climbing. And the basic idea of hill climbing is, let's say I'm trying to maximize the value of my state. I'm trying to figure out where the global maximum is. I'm going to start at a state. And generally, what hill climbing is going to do is it's going to consider the neighbors of that state, that from this state, all right, I could go left or I could go right, and this neighbor happens to be higher and this neighbor happens to be lower. And in hill climbing, if I'm trying to maximize the value, I'll generally pick the highest one I can between the state to the left and right of me. This one is higher. So I'll go ahead and move myself to consider that state instead. And then I'll repeat this process, continually looking at all of my neighbors and picking the highest neighbor, doing the same thing, looking at my neighbors, picking the highest of my neighbors, until I get to a point like right here, where I consider both of my neighbors and both of my neighbors have a lower value than I do. This current state has a value that is higher than any of its neighbors. And at that point, the algorithm terminates. And I can say, all right, here I have now found the solution. And the same thing works in exactly the opposite way for trying to find a global minimum. But the algorithm is fundamentally the same. If I'm trying to find a global minimum and say my current state starts here, I'll continually look at my neighbors, pick the lowest value that I possibly can, until I eventually, hopefully, find that global minimum, a point at which when I look at both of my neighbors, they each have a higher value. And I'm trying to minimize the total score or cost or value that I get as a result of calculating some sort of cost function. So we can formulate this graphical idea in terms of pseudocode. And the pseudocode for hill climbing might look like this. We define some function called hill climb that takes as input the problem that we're trying to solve. And generally, we're going to start in some sort of initial state. So I'll start with a variable called current that is keeping track of my initial state, like an initial configuration of hospitals. And maybe some problems lend themselves to an initial state, some place where you begin. In other cases, maybe not, in which case we might just randomly generate some initial state, just by choosing two locations for hospitals at random, for example, and figuring out from there how we might be able to improve. But that initial state, we're going to store inside of current. And now, here comes our loop, some repetitive process we're going to do again and again until the algorithm terminates. And what we're going to do is first say, let's figure out all of the neighbors of the current state. From my state, what are all of the neighboring states for some definition of what it means to be a neighbor? And I'll go ahead and choose the highest value of all of those neighbors and save it inside of this variable called neighbor. So keep track of the highest-valued neighbor. This is in the case where I'm trying to maximize the value. In the case where I'm trying to minimize the value, you might imagine here, you'll pick the neighbor with the lowest possible value. But these ideas are really fundamentally interchangeable. And it's possible, in some cases, there might be multiple neighbors that each have an equally high value or an equally low value in the minimizing case. And in that case, we can just choose randomly from among them. Choose one of them and save it inside of this variable neighbor. And then the key question to ask is, is this neighbor better than my current state? And if the neighbor, the best neighbor that I was able to find, is not better than my current state, well, then the algorithm is over. And I'll just go ahead and return the current state. If none of my neighbors are better, then I may as well stay where I am, is the general logic of the hill climbing algorithm. But otherwise, if the neighbor is better, then I may as well move to that neighbor. So you might imagine setting current equal to neighbor, where the general idea is if I'm at a current state and I see a neighbor that is better than me, then I'll go ahead and move there. And then I'll repeat the process, continually moving to a better neighbor until I reach a point at which none of my neighbors are better than I am. And at that point, we'd say the algorithm can just terminate there. So let's take a look at a real example of this with these houses and hospitals. So we've seen now that if we put the hospitals in these two locations, that has a total cost of 17. And now we need to define, if we're going to implement this hill climbing algorithm, what it means to take this particular configuration of hospitals, this particular state, and get a neighbor of that state. And a simple definition of neighbor might be just, let's pick one of the hospitals and move it by one square, the left or right or up or down, for example. And that would mean we have six possible neighbors from this particular configuration. We could take this hospital and move it to any of these three possible squares, or we take this hospital and move it to any of those three possible squares. And each of those would generate a neighbor. And what I might do is say, all right, here's the locations and the distances between each of the houses and their nearest hospital. Let me consider all of the neighbors and see if any of them can do better than a cost of 17. And it turns out there are a couple of ways that we could do that. And it doesn't matter if we randomly choose among all the ways that are the best. But one such possible way is by taking a look at this hospital here and considering the directions in which it might move. If we hold this hospital constant, if we take this hospital and move it one square up, for example, that doesn't really help us. It gets closer to the house up here, but it gets further away from the house down here. And it doesn't really change anything for the two houses along the left-hand side. But if we take this hospital on the right and move it one square down, it's the opposite problem. It gets further away from the house up above, and it gets closer to the house down below. The real idea, the goal should be to be able to take this hospital and move it one square to the left. By moving it one square to the left, we move it closer to both of these houses on the right without changing anything about the houses on the left. For them, this hospital is still the closer one, so they aren't affected. So we're able to improve the situation by picking a neighbor that results in a decrease in our total cost. And so we might do that. Move ourselves from this current state to a neighbor by just taking that hospital and moving it. And at this point, there's not a whole lot that can be done with this hospital. But there's still other optimizations we can make, other neighbors we can move to that are going to have a better value. If we consider this hospital, for example, we might imagine that right now it's a bit far up, that both of these houses are a little bit lower. So we might be able to do better by taking this hospital and moving it one square down, moving it down so that now instead of a cost of 15, we're down to a cost of 13 for this particular configuration. And we can do even better by taking the hospital and moving it one square to the left. Now instead of a cost of 13, we have a cost of 11, because this house is one away from the hospital. This one is four away. This one is three away. And this one is also three away. So we've been able to do much better than that initial cost that we had using the initial configuration. Just by taking every state and asking ourselves the question, can we do better by just making small incremental changes, moving to a neighbor, moving to a neighbor, and moving to a neighbor after that? And now at this point, we can potentially see that at this point, the algorithm is going to terminate. There's actually no neighbor we can move to that is going to improve the situation, get us a cost that is less than 11. Because if we take this hospital and move it upper to the right, well, that's going to make it further away. If we take it and move it down, that doesn't really change the situation. It gets further away from this house but closer to that house. And likewise, the same story was true for this hospital. Any neighbor we move it to, up, left, down, or right, is either going to make it further away from the houses and increase the cost, or it's going to have no effect on the cost whatsoever. And so the question we might now ask is, is this the best we could do? Is this the best placement of the hospitals we could possibly have? And it turns out the answer is no, because there's a better way that we could place these hospitals. And in particular, there are a number of ways you could do this. But one of the ways is by taking this hospital here and moving it to this square, for example, moving it diagonally by one square, which was not part of our definition of neighbor. We could only move left, right, up, or down. But this is, in fact, better. It has a total cost of 9. It is now closer to both of these houses. And as a result, the total cost is less. But we weren't able to find it, because in order to get there, we had to go through a state that actually wasn't any better than the current state that we had been on previously. And so this appears to be a limitation, or a concern you might have as you go about trying to implement a hill climbing algorithm, is that it might not always give you the optimal solution. If we're trying to maximize the value of any particular state, we're trying to find the global maximum, a concern might be that we could get stuck at one of the local maxima, highlighted here in blue, where a local maxima is any state whose value is higher than any of its neighbors. If we ever find ourselves at one of these two states when we're trying to maximize the value of the state, we're not going to make any changes. We're not going to move left or right. We're not going to move left here, because those states are worse. But yet, we haven't found the global optimum. We haven't done as best as we could do. And likewise, in the case of the hospitals, what we're ultimately trying to do is find a global minimum, find a value that is lower than all of the others. But we have the potential to get stuck at one of the local minima, any of these states whose value is lower than all of its neighbors, but still not as low as the local minima. And so the takeaway here is that it's not always going to be the case that when we run this naive hill climbing algorithm, that we're always going to find the optimal solution. There are things that could go wrong. If we started here, for example, and tried to maximize our value as much as possible, we might move to the highest possible neighbor, move to the highest possible neighbor, move to the highest possible neighbor, and stop, and never realize that there's actually a better state way over there that we could have gone to instead. And other problems you might imagine just by taking a look at this state space landscape are these various different types of plateaus, something like this flat local maximum here, where all six of these states each have the exact same value. And so in the case of the algorithm we showed before, none of the neighbors are better, so we might just get stuck at this flat local maximum. And even if you allowed yourself to move to one of the neighbors, it wouldn't be clear which neighbor you would ultimately move to, and you could get stuck here as well. And there's another one over here. This one is called a shoulder. It's not really a local maximum, because there's still places where we can go higher, not a local minimum, because we can go lower. So we can still make progress, but it's still this flat area, where if you have a local search algorithm, there's potential to get lost here, unable to make some upward or downward progress, depending on whether we're trying to maximize or minimize it, and therefore another potential for us to be able to find a solution that might not actually be the optimal solution. And so because of this potential, the potential that hill climbing has to not always find us the optimal result, it turns out there are a number of different varieties and variations on the hill climbing algorithm that help to solve the problem better depending on the context, and depending on the specific type of problem, some of these variants might be more applicable than others. What we've taken a look at so far is a version of hill climbing generally called steepest ascent hill climbing, where the idea of steepest ascent hill climbing is we are going to choose the highest valued neighbor, in the case where we're trying to maximize or the lowest valued neighbor in cases where we're trying to minimize. But generally speaking, if I have five neighbors and they're all better than my current state, I will pick the best one of those five. Now, sometimes that might work pretty well. It's sort of a greedy approach of trying to take the best operation at any particular time step, but it might not always work. There might be cases where actually I want to choose an option that is slightly better than me, but maybe not the best one because that later on might lead to a better outcome ultimately. So there are other variants that we might consider of this basic hill climbing algorithm. One is known as stochastic hill climbing. And in this case, we choose randomly from all of our higher value neighbors. So if I'm at my current state and there are five neighbors that are all better than I am, rather than choosing the best one, as steep as the set would do, stochastic will just choose randomly from one of them, thinking that if it's better, then it's better. And maybe there's a potential to make forward progress, even if it is not locally the best option I could possibly choose. First choice hill climbing ends up just choosing the very first highest valued neighbor that it follows, behaving on a similar idea, rather than consider all of the neighbors. As soon as we find a neighbor that is better than our current state, we'll go ahead and move there. There may be some efficiency improvements there and maybe has the potential to find a solution that the other strategies weren't able to find. And with all of these variants, we still suffer from the same potential risk, this risk that we might end up at a local minimum or a local maximum. And we can reduce that risk by repeating the process multiple times. So one variant of hill climbing is random restart hill climbing, where the general idea is we'll conduct hill climbing multiple times. If we apply steepest descent hill climbing, for example, we'll start at some random state, try and figure out how to solve the problem and figure out what is the local maximum or local minimum we get to. And then we'll just randomly restart and try again, choose a new starting configuration, try and figure out what the local maximum or minimum is, and do this some number of times. And then after we've done it some number of times, we can pick the best one out of all of the ones that we've taken a look at. So there's another option we have access to as well. And then, although I said that generally local search will usually just keep track of a single node and then move to one of its neighbors, there are variants of hill climbing that are known as local beam searches, where rather than keep track of just one current best state, we're keeping track of k highest valued neighbors, such that rather than starting at one random initial configuration, I might start with 3 or 4 or 5, randomly generate all the neighbors, and then pick the 3 or 4 or 5 best of all of the neighbors that I find, and continually repeat this process, with the idea being that now I have more options that I'm considering, more ways that I could potentially navigate myself to the optimal solution that might exist for a particular problem. So let's now take a look at some actual code that can implement some of these kinds of ideas, something like steepest ascent hill climbing, for example, for trying to solve this hospital problem. So I'm going to go ahead and go into my hospitals directory, where I've actually set up the basic framework for solving this type of problem. I'll go ahead and go into hospitals.py, and we'll take a look at the code we've created here. I've defined a class that is going to represent the state space. So the space has a height, and a width, and also some number of hospitals. So you can configure how big is your map, how many hospitals should go here. We have a function for adding a new house to the state space, and then some functions that are going to get me all of the available spaces for if I want to randomly place hospitals in particular locations. And here now is the hill climbing algorithm. So what are we going to do in the hill climbing algorithm? Well, we're going to start by randomly initializing where the hospitals are going to go. We don't know where the hospitals should actually be, so let's just randomly place them. So here I'm running a loop for each of the hospitals that I have. I'm going to go ahead and add a new hospital at some random location. So I basically get all of the available spaces, and I randomly choose one of them as where I would like to add this particular hospital. I have some logging output and generating some images, which we'll take a look at a little bit later. But here is the key idea. So I'm going to just keep repeating this algorithm. I could specify a maximum of how many times I want it to run, or I could just run it up until it hits a local maximum or local minimum. And now we'll basically consider all of the hospitals that could potentially move. So consider each of the two hospitals or more hospitals if they're more than that. And consider all of the places where that hospital could move to, some neighbor of that hospital that we can move the neighbor to. And then see, is this going to be better than where we were currently? So if it is going to be better, then we'll go ahead and update our best neighbor and keep track of this new best neighbor that we found. And then afterwards, we can ask ourselves the question, if best neighbor cost is greater than or equal to the cost of the current set of hospitals, meaning if the cost of our best neighbor is greater than the current cost, meaning our best neighbor is worse than our current state, well, then we shouldn't make any changes at all. And we should just go ahead and return the current set of hospitals. But otherwise, we can update our hospitals in order to change them to one of the best neighbors. And if there are multiple that are all equivalent, I'm here using random.choice to say go ahead and choose one randomly. So this is really just a Python implementation of that same idea that we were just talking about, this idea of taking a current state, some current set of hospitals, generating all of the neighbors, looking at all of the ways we could take one hospital and move it one square to the left or right or up or down, and then figuring out, based on all of that information, which is the best neighbor or the set of all the best neighbors, and then choosing from one of those. And each time, we go ahead and generate an image in order to do that. And so now what we're doing is if we look down at the bottom, I'm going to randomly generate a space with height 10 and width 20. And I'll say go ahead and put three hospitals somewhere in the space. I'll randomly generate 15 houses that I just go ahead and add in random locations. And now I'm going to run this hill climbing algorithm in order to try and figure out where we should place those hospitals. So we'll go ahead and run this program by running Python hospitals. And we see that we started. Our initial state had a cost of 72, but we were able to continually find neighbors that were able to decrease that cost, decrease to 69, 66, 63, so on and so forth, all the way down to 53, as the best neighbor we were able to ultimately find. And we can take a look at what that looked like by just opening up these files. So here, for example, was the initial configuration. We randomly selected a location for each of these 15 different houses and then randomly selected locations for one, two, three hospitals that were just located somewhere inside of the state space. And if you add up all the distances from each of the houses to their nearest hospital, you get a total cost of about 72. And so now the question is, what neighbors can we move to that improve the situation? And it looks like the first one the algorithm found was by taking this house that was over there on the right and just moving it to the left. And that probably makes sense because if you look at the houses in that general area, really these five houses look like they're probably the ones that are going to be closest to this hospital over here. Moving it to the left decreases the total distance, at least to most of these houses, though it does increase that distance for one of them. And so we're able to make these improvements to the situation by continually finding ways that we can move these hospitals around until we eventually settle at this particular state that has a cost of 53, where we figured out a position for each of the hospitals. And now none of the neighbors that we could move to are actually going to improve the situation. We can take this hospital and this hospital and that hospital and look at each of the neighbors. And none of those are going to be better than this particular configuration. And again, that's not to say that this is the best we could do. There might be some other configuration of hospitals that is a global minimum. And this might just be a local minimum that is the best of all of its neighbors, but maybe not the best in the entire possible state space. And you could search through the entire state space by considering all of the possible configurations for hospitals. But ultimately, that's going to be very time intensive, especially as our state space gets bigger and there might be more and more possible states. It's going to take quite a long time to look through all of them. And so being able to use these sort of local search algorithms can often be quite good for trying to find the best solution we can do. And especially if we don't care about doing the best possible and we just care about doing pretty good and finding a pretty good placement of those hospitals, then these methods can be particularly powerful. But of course, we can try and mitigate some of this concern by instead of using hill climbing to use random restart, this idea of rather than just hill climb one time, we can hill climb multiple times and say, try hill climbing a whole bunch of times on the exact same map and figure out what is the best one that we've been able to find. And so I've here implemented a function for random restart that restarts some maximum number of times. And what we're going to do is repeat that number of times this process of just go ahead and run the hill climbing algorithm, figure out what the cost is of getting from all the houses to the hospitals, and then figure out is this better than we've done so far. So I can try this exact same idea where instead of running hill climbing, I'll go ahead and run random restart. And I'll randomly restart maybe 20 times, for example. And we'll go ahead and now I'll remove all the images and then rerun the program. And now we started by finding a original state. When we initially ran hill climbing, the best cost we were able to find was 56. Each of these iterations is a different iteration of the hill climbing algorithm. We're running hill climbing not one time, but 20 times here, each time going until we find a local minimum in this case. And we look and see each time did we do better than we did the best time we've done so far. So we went from 56 to 46. This one was greater, so we ignored it. This one was 41, which was less, so we went ahead and kept that one. And for all of the remaining 16 times that we tried to implement hill climbing and we tried to run the hill climbing algorithm, we couldn't do any better than that 41. Again, maybe there is a way to do better that we just didn't find, but it looks like that way ended up being a pretty good solution to the problem. That was attempt number three, starting from counting at zero. So we can take a look at that, open up number three. And this was the state that happened to have a cost of 41, that after running the hill climbing algorithm on some particular random initial configuration of hospitals, this is what we found was the local minimum in terms of trying to minimize the cost. And it looks like we did pretty well. This hospital is pretty close to this region. This one is pretty close to these houses here. This hospital looks about as good as we can do for trying to capture those houses over on that side. And so these sorts of algorithms can be quite useful for trying to solve these problems. But the real problem with many of these different types of hill climbing, steepest of sense, stochastic, first choice, and so forth, is that they never make a move that makes our situation worse. They're always going to take ourselves in our current state, look at the neighbors, and consider can we do better than our current state and move to one of those neighbors. Which of those neighbors we choose might vary among these various different types of algorithms, but we never go from a current position to a position that is worse than our current position. And ultimately, that's what we're going to need to do if we want to be able to find a global maximum or a global minimum. Because sometimes if we get stuck, we want to find some way of dislodging ourselves from our local maximum or local minimum in order to find the global maximum or the global minimum or increase the probability that we do find it. And so the most popular technique for trying to approach the problem from that angle is a technique known as simulated annealing, simulated because it's modeling after a real physical process of annealing, where you can think about this in terms of physics, a physical situation where you have some system of particles. And you might imagine that when you heat up a particular physical system, there's a lot of energy there. Things are moving around quite randomly. But over time, as the system cools down, it eventually settles into some final position. And that's going to be the general idea of simulated annealing. We're going to simulate that process of some high temperature system where things are moving around randomly quite frequently, but over time decreasing that temperature until we eventually settle at our ultimate solution. And the idea is going to be if we have some state space landscape that looks like this and we begin at its initial state here, if we're looking for a global maximum and we're trying to maximize the value of the state, our traditional hill climbing algorithms would just take the state and look at the two neighbor ones and always pick the one that is going to increase the value of the state. But if we want some chance of being able to find the global maximum, we can't always make good moves. We have to sometimes make bad moves and allow ourselves to make a move in a direction that actually seems for now to make our situation worse such that later we can find our way up to that global maximum in terms of trying to solve that problem. Of course, once we get up to this global maximum, once we've done a whole lot of the searching, then we probably don't want to be moving to states that are worse than our current state. And so this is where this metaphor for annealing starts to come in, where we want to start making more random moves and over time start to make fewer of those random moves based on a particular temperature schedule. So the basic outline looks something like this. Early on in simulated annealing, we have a higher temperature state. And what we mean by a higher temperature state is that we are more likely to accept neighbors that are worse than our current state. We might look at our neighbors. And if one of our neighbors is worse than the current state, especially if it's not all that much worse, if it's pretty close but just slightly worse, then we might be more likely to accept that and go ahead and move to that neighbor anyways. But later on as we run simulated annealing, we're going to decrease that temperature. And at a lower temperature, we're going to be less likely to accept neighbors that are worse than our current state. Now to formalize this and put a little bit of pseudocode to it, here is what that algorithm might look like. We have a function called simulated annealing that takes as input the problem we're trying to solve and also potentially some maximum number of times we might want to run the simulated annealing process, how many different neighbors we're going to try and look for. And that value is going to vary based on the problem you're trying to solve. We'll, again, start with some current state that will be equal to the initial state of the problem. But now we need to repeat this process over and over for max number of times. Repeat some process some number of times where we're first going to calculate a temperature. And this temperature function takes the current time t starting at 1 going all the way up to max and then gives us some temperature that we can use in our computation, where the idea is that this temperature is going to be higher early on and it's going to be lower later on. So there are a number of ways this temperature function could often work. One of the simplest ways is just to say it is like the proportion of time that we still have remaining. Out of max units of time, how much time do we have remaining? You start off with a lot of that time remaining. And as time goes on, the temperature is going to decrease because you have less and less of that remaining time still available to you. So we calculate a temperature for the current time. And then we pick a random neighbor of the current state. No longer are we going to be picking the best neighbor that we possibly can or just one of the better neighbors that we can. We're going to pick a random neighbor. It might be better. It might be worse. But we're going to calculate that. We're going to calculate delta E, E for energy in this case, which is just how much better is the neighbor than the current state. So if delta E is positive, that means the neighbor is better than our current state. If delta E is negative, that means the neighbor is worse than our current state. And so we can then have a condition that looks like this. If delta E is greater than 0, that means the neighbor state is better than our current state. And if ever that situation arises, we'll just go ahead and update current to be that neighbor. Same as before, move where we are currently to be the neighbor because the neighbor is better than our current state. We'll go ahead and accept that. But now the difference is that whereas before, we never, ever wanted to take a move that made our situation worse, now we sometimes want to make a move that is actually going to make our situation worse because sometimes we're going to need to dislodge ourselves from a local minimum or local maximum to increase the probability that we're able to find the global minimum or the global maximum a little bit later. And so how do we do that? How do we decide to sometimes accept some state that might actually be worse? Well, we're going to accept a worse state with some probability. And that probability needs to be based on a couple of factors. It needs to be based in part on the temperature, where if the temperature is higher, we're more likely to move to a worse neighbor. And if the temperature is lower, we're less likely to move to a worse neighbor. But it also, to some degree, should be based on delta E. If the neighbor is much worse than the current state, we probably want to be less likely to choose that than if the neighbor is just a little bit worse than the current state. So again, there are a couple of ways you could calculate this. But it turns out one of the most popular is just to calculate E to the power of delta E over T, where E is just a constant. Delta E over T are based on delta E and T here. We calculate that value. And that'll be some value between 0 and 1. And that is the probability with which we should just say, all right, let's go ahead and move to that neighbor. And it turns out that if you do the math for this value, when delta E is such that the neighbor is not that much worse than the current state, that's going to be more likely that we're going to go ahead and move to that state. And likewise, when the temperature is lower, we're going to be less likely to move to that neighboring state as well. So now this is the big picture for simulated annealing, this process of taking the problem and going ahead and generating random neighbors will always move to a neighbor if it's better than our current state. But even if the neighbor is worse than our current state, we'll sometimes move there depending on how much worse it is and also based on the temperature. And as a result, the hope, the goal of this whole process is that as we begin to try and find our way to the global maximum or the global minimum, we can dislodge ourselves if we ever get stuck at a local maximum or local minimum in order to eventually make our way to exploring the part of the state space that is going to be the best. And then as the temperature decreases, eventually we settle there without moving around too much from what we've found to be the globally best thing that we can do thus far. So at the very end, we just return whatever the current state happens to be. And that is the conclusion of this algorithm. We've been able to figure out what the solution is. And these types of algorithms have a lot of different applications. Any time you can take a problem and formulate it as something where you can explore a particular configuration and then ask, are any of the neighbors better than this current configuration and have some way of measuring that, then there is an applicable case for these hill climbing, simulated annealing types of algorithms. So sometimes it can be for facility location type problems, like for when you're trying to plan a city and figure out where the hospitals should be. But there are definitely other applications as well. And one of the most famous problems in computer science is the traveling salesman problem. Traveling salesman problem generally is formulated like this. I have a whole bunch of cities here indicated by these dots. And what I'd like to do is find some route that takes me through all of the cities and ends up back where I started. So some route that starts here, goes through all these cities, and ends up back where I originally started. And what I might like to do is minimize the total distance that I have to travel or the total cost of taking this entire path. And you can imagine this is a problem that's very applicable in situations like when delivery companies are trying to deliver things to a whole bunch of different houses, they want to figure out, how do I get from the warehouse to all these various different houses and get back again, all using as minimal time and distance and energy as possible. So you might want to try to solve these sorts of problems. But it turns out that solving this particular kind of problem is very computationally difficult. It is a very computationally expensive task to be able to figure it out. This falls under the category of what are known as NP-complete problems, problems that there is no known efficient way to try and solve these sorts of problems. And so what we ultimately have to do is come up with some approximation, some ways of trying to find a good solution, even if we're not going to find the globally best solution that we possibly can, at least not in a feasible or tractable amount of time. And so what we could do is take the traveling salesman problem and try to formulate it using local search and ask a question like, all right, I can pick some state, some configuration, some route between all of these nodes. And I can measure the cost of that state, figure out what the distance is. And I might now want to try to minimize that cost as much as possible. And then the only question now is, what does it mean to have a neighbor of this state? What does it mean to take this particular route and have some neighboring route that is close to it but slightly different and such that it might have a different total distance? And there are a number of different definitions for what a neighbor of a traveling salesman configuration might look like. But one way is just to say, a neighbor is what happens if we pick two of these edges between nodes and switch them effectively. So for example, I might pick these two edges here, these two that just happened across this node goes here, this node goes there, and go ahead and switch them. And what that process will generally look like is removing both of these edges from the graph, taking this node, and connecting it to the node it wasn't connected to. So connecting it up here instead. We'll need to take these arrows that were originally going this way and reverse them, so move them going the other way, and then just fill in that last remaining blank, add an arrow that goes in that direction instead. So by taking two edges and just switching them, I have been able to consider one possible neighbor of this particular configuration. And it looks like this neighbor is actually better. It looks like this probably travels a shorter distance in order to get through all the cities through this route than the current state did. And so you could imagine implementing this idea inside of a hill climbing or simulated annealing algorithm, where we repeat this process to try and take a state of this traveling salesman problem, look at all the neighbors, and then move to the neighbors if they're better, or maybe even move to the neighbors if they're worse, until we eventually settle upon some best solution that we've been able to find. And it turns out that these types of approximation algorithms, even if they don't always find the very best solution, can often do pretty well at trying to find solutions that are helpful too. So that then was a look at local search, a particular category of algorithms that can be used for solving a particular type of problem, where we don't really care about the path to the solution. I didn't care about the steps I took to decide where the hospitals should go. I just cared about the solution itself. I just care about where the hospitals should be, or what the route through the traveling salesman journey really ought to be. Another type of algorithm that might come up are known as these categories of linear programming types of problems. And linear programming often comes up in the context where we're trying to optimize for some mathematical function. But oftentimes, linear programming will come up when we might have real numbered values. So it's not just discrete fixed values that we might have, but any decimal values that we might want to be able to calculate. And so linear programming is a family of types of problems where we might have a situation that looks like this, where the goal of linear programming is to minimize a cost function. And you can invert the numbers and say try and maximize it, but often we'll frame it as trying to minimize a cost function that has some number of variables, x1, x2, x3, all the way up to xn, just some number of variables that are involved, things that I want to know the values to. And this cost function might have coefficients in front of those variables. And this is what we would call a linear equation, where we just have all of these variables that might be multiplied by a coefficient and then add it together. We're not going to square anything or cube anything, because that'll give us different types of equations. With linear programming, we're just dealing with linear equations in addition to linear constraints, where a constraint is going to look something like if we sum up this particular equation that is just some linear combination of all of these variables, it is less than or equal to some bound b. And we might have a whole number of these various different constraints that we might place onto our linear programming exercise. And likewise, just as we can have constraints that are saying this linear equation is less than or equal to some bound b, it might also be equal to something. That if you want some sum of some combination of variables to be equal to a value, you can specify that. And we can also maybe specify that each variable has lower and upper bounds, that it needs to be a positive number, for example, or it needs to be a number that is less than 50, for example. And there are a number of other choices that we can make there for defining what the bounds of a variable are. But it turns out that if you can take a problem and formulate it in these terms, formulate the problem as your goal is to minimize a cost function, and you're minimizing that cost function subject to particular constraints, subjects to equations that are of the form like this of some sequence of variables is less than a bound or is equal to some particular value, then there are a number of algorithms that already exist for solving these sorts of problems. So let's go ahead and take a look at an example. Here's an example of a problem that might come up in the world of linear programming. Often, this is going to come up when we're trying to optimize for something. And we want to be able to do some calculations, and we have constraints on what we're trying to optimize. And so it might be something like this. In the context of a factory, we have two machines, x1 and x2. x1 costs $50 an hour to run. x2 costs $80 an hour to run. And our goal, what we're trying to do, our objective, is to minimize the total cost. So that's what we'd like to do. But we need to do so subject to certain constraints. So there might be a labor constraint that x1 requires five units of labor per hour, x2 requires two units of labor per hour, and we have a total of 20 units of labor that we have to spend. So this is a constraint. We have no more than 20 units of labor that we can spend, and we have to spend it across x1 and x2, each of which requires a different amount of labor. And we might also have a constraint like this that tells us x1 is going to produce 10 units of output per hour, x2 is going to produce 12 units of output per hour, and the company needs 90 units of output. So we have some goal, something we need to achieve. We need to achieve 90 units of output, but there are some constraints that x1 can only produce 10 units of output per hour, x2 produces 12 units of output per hour. These types of problems come up quite frequently, and you can start to notice patterns in these types of problems, problems where I am trying to optimize for some goal, minimizing cost, maximizing output, maximizing profits, or something like that. And there are constraints that are placed on that process. And so now we just need to formulate this problem in terms of linear equations. So let's start with this first point. Two machines, x1 and x2, x costs $50 an hour, x2 costs $80 an hour. Here we can come up with an objective function that might look like this. This is our cost function, rather. 50 times x1 plus 80 times x2, where x1 is going to be a variable representing how many hours do we run machine x1 for, x2 is going to be a variable representing how many hours are we running machine x2 for. And what we're trying to minimize is this cost function, which is just how much it costs to run each of these machines per hour summed up. This is an example of a linear equation, just some combination of these variables plus coefficients that are placed in front of them. And I would like to minimize that total value. But I need to do so subject to these constraints. x1 requires 50 units of labor per hour, x2 requires 2, and we have a total of 20 units of labor to spend. And so that gives us a constraint of this form. 5 times x1 plus 2 times x2 is less than or equal to 20. 20 is the total number of units of labor we have to spend. And that's spent across x1 and x2, each of which requires a different number of units of labor per hour, for example. And finally, we have this constraint here. x1 produces 10 units of output per hour, x2 produces 12, and we need 90 units of output. And so this might look something like this. That 10x1 plus 12x2, this is amount of output per hour, it needs to be at least 90. We can do better or great, but it needs to be at least 90. And if you recall from my formulation before, I said that generally speaking in linear programming, we deal with equals constraints or less than or equal to constraints. So we have a greater than or equal to sign here. That's not a problem. Whenever we have a greater than or equal to sign, we can just multiply the equation by negative 1, and that'll flip it around to a less than or equals negative 90, for example, instead of a greater than or equal to 90. And that's going to be an equivalent expression that we can use to represent this problem. So now that we have this cost function and these constraints that it's subject to, it turns out there are a number of algorithms that can be used in order to solve these types of problems. And these problems go a little bit more into geometry and linear algebra than we're really going to get into. But the most popular of these types of algorithms are simplex, which was one of the first algorithms discovered for trying to solve linear programs. And later on, a class of interior point algorithms can be used to solve this type of problem as well. The key is not to understand exactly how these algorithms work, but to realize that these algorithms exist for efficiently finding solutions any time we have a problem of this particular form. And so we can take a look, for example, at the production directory here, where here I have a file called production.py, where here I'm using scipy, which was the library for a lot of science-related functions within Python. And I can go ahead and just run this optimization function in order to run a linear program. .linprog here is going to try and solve this linear program for me, where I provide to this expression, to this function call, all of the data about my linear program. So it needs to be in a particular format, which might be a little confusing at first. But this first argument to scipy.optimize.linprogramming is the cost function, which is in this case just an array or a list that has 50 and 80, because my original cost function was 50 times x1 plus 80 times x2. So I just tell Python, 50 and 80, those are the coefficients that I am now trying to optimize for. And then I provide all of the constraints. So the constraints, and I wrote them up above in comments, is the constraint 1 is 5x1 plus 2x2 is less than or equal to 20. And constraint 2 is negative 10x1 plus negative 12x2 is less than or equal to negative 90. And so scipy expects these constraints to be in a particular format. It first expects me to provide all of the coefficients for the upper bound equations, ub just for upper bound, where the coefficients of the first equation are 5 and 2, because we have 5x1 and 2x2. And the coefficients for the second equation are negative 10 and negative 12, because I have negative 10x1 plus negative 12x2. And then here, we provide it as a separate argument, just to keep things separate, what the actual bound is. What is the upper bound for each of these constraints? Well, for the first constraint, the upper bound is 20. That was constraint number 1. And then for constraint number 2, the upper bound is 90. So a bit of a cryptic way of representing it. It's not quite as simple as just writing the mathematical equations. What really is being expected here are all of the coefficients and all of the numbers that are in these equations by first providing the coefficients for the cost function, then providing all the coefficients for the inequality constraints, and then providing all of the upper bounds for those inequality constraints. And once all of that information is there, then we can run any of these interior point algorithms or the simplex algorithm. Even if you don't understand how it works, you can just run the function and figure out what the result should be. And here, I said if the result is a success, we were able to solve this problem. Go ahead and print out what the value of x1 and x2 should be. Otherwise, go ahead and print out no solution. And so if I run this program by running python production.py, it takes a second to calculate. But then we see here is what the optimal solution should be. x1 should run for 1.5 hours. x2 should run for 6.25 hours. And we were able to do this by just formulating the problem as a linear equation that we were trying to optimize, some cost that we were trying to minimize, and then some constraints that were placed on that. And many, many problems fall into this category of problems that you can solve if you can just figure out how to use equations and use these constraints to represent that general idea. And that's a theme that's going to come up a couple of times today, where we want to be able to take some problem and reduce it down to some problem we know how to solve in order to begin to find a solution and to use existing methods that we can use in order to find a solution more effectively or more efficiently. And it turns out that these types of problems, where we have constraints, show up in other ways too. And there's an entire class of problems that's more generally just known as constraint satisfaction problems. And we're going to now take a look at how you might formulate a constraint satisfaction problem and how you might go about solving a constraint satisfaction problem. But the basic idea of a constraint satisfaction problem is we have some number of variables that need to take on some values. And we need to figure out what values each of those variables should take on. But those variables are subject to particular constraints that are going to limit what values those variables can actually take on. So let's take a look at a real world example, for example. Let's look at exam scheduling, that I have four students here, students 1, 2, 3, and 4. Each of them is taking some number of different classes. Classes here are going to be represented by letters. So student 1 is enrolled in courses A, B, and C. Student 2 is enrolled in courses B, D, and E, so on and so forth. And now, say university, for example, is trying to schedule exams for all of these courses. But there are only three exam slots on Monday, Tuesday, and Wednesday. And we have to schedule an exam for each of these courses. But the constraint now, the constraint we have to deal with with the scheduling, is that we don't want anyone to have to take two exams on the same day. We would like to try and minimize that or eliminate it if at all possible. So how do we begin to represent this idea? How do we structure this in a way that a computer with an AI algorithm can begin to try and solve the problem? Well, let's in particular just look at these classes that we might take and represent each of the courses as some node inside of a graph. And what we'll do is we'll create an edge between two nodes in this graph if there is a constraint between those two nodes. So what does this mean? Well, we can start with student 1, who's enrolled in courses A, B, and C. What that means is that A and B can't have an exam at the same time. A and C can't have an exam at the same time. And B and C also can't have an exam at the same time. And I can represent that in this graph by just drawing edges. One edge between A and B, one between B and C, and then one between C and A. And that encodes now the idea that between those nodes, there is a constraint. And in particular, the constraint happens to be that these two can't be equal to each other, though there are other types of constraints that are possible, depending on the type of problem that you're trying to solve. And then we can do the same thing for each of the other students. So for student 2, who's enrolled in courses B, D, and E, well, that means B, D, and E, those all need to have edges that connect each other as well. Student 3 is enrolled in courses C, E, and F. So we'll go ahead and take C, E, and F and connect those by drawing edges between them too. And then finally, student 4 is enrolled in courses E, F, and G. And we can represent that by drawing edges between E, F, and G, although E and F already had an edge between them. We don't need another one, because this constraint is just encoding the idea that course E and course F cannot have an exam on the same day. So this then is what we might call the constraint graph. There's some graphical representation of all of my variables, so to speak, and the constraints between those possible variables. Where in this particular case, each of the constraints represents an inequality constraint, that an edge between B and D means whatever value the variable B takes on cannot be the value that the variable D takes on as well. So what then actually is a constraint satisfaction problem? Well, a constraint satisfaction problem is just some set of variables, x1 all the way through xn, some set of domains for each of those variables. So every variable needs to take on some values. Maybe every variable has the same domain, but maybe each variable has a slightly different domain. And then there's a set of constraints, and we'll just call a set C, that is some constraints that are placed upon these variables, like x1 is not equal to x2. But there could be other forms too, like maybe x1 equals x2 plus 1 if these variables are taking on numerical values in their domain, for example. The types of constraints are going to vary based on the types of problems. And constraint satisfaction shows up all over the place as well, in any situation where we have variables that are subject to particular constraints. So one popular game is Sudoku, for example, this 9 by 9 grid where you need to fill in numbers in each of these cells, but you want to make sure there's never a duplicate number in any row, or in any column, or in any grid of 3 by 3 cells, for example. So what might this look like as a constraint satisfaction problem? Well, my variables are all of the empty squares in the puzzle. So represented here is just like an x comma y coordinate, for example, as all of the squares where I need to plug in a value, where I don't know what value it should take on. The domain is just going to be all of the numbers from 1 through 9, any value that I could fill in to one of these cells. So that is going to be the domain for each of these variables. And then the constraints are going to be of the form, like this cell can't be equal to this cell, can't be equal to this cell, can't be, and all of these need to be different, for example, and same for all of the rows, and the columns, and the 3 by 3 squares as well. So those constraints are going to enforce what values are actually allowed. And we can formulate the same idea in the case of this exam scheduling problem, where the variables we have are the different courses, a up through g. The domain for each of these variables is going to be Monday, Tuesday, and Wednesday. Those are the possible values each of the variables can take on, that in this case just represent when is the exam for that class. And then the constraints are of this form, a is not equal to b, a is not equal to c, meaning a and b can't have an exam on the same day, a and c can't have an exam on the same day. Or more formally, these two variables cannot take on the same value within their domain. So that then is this formulation of a constraint satisfaction problem that we can begin to use to try and solve this problem. And constraints can come in a number of different forms. There are hard constraints, which are constraints that must be satisfied for a correct solution. So something like in the Sudoku puzzle, you cannot have this cell and this cell that are in the same row take on the same value. That is a hard constraint. But problems can also have soft constraints, where these are constraints that express some notion of preference, that maybe a and b can't have an exam on the same day, but maybe someone has a preference that a's exam is earlier than b's exam. It doesn't need to be the case with some expression that some solution is better than another solution. And in that case, you might formulate the problem as trying to optimize for maximizing people's preferences. You want people's preferences to be satisfied as much as possible. In this case, though, we'll mostly just deal with hard constraints, constraints that must be met in order to have a correct solution to the problem. So we want to figure out some assignment of these variables to their particular values that is ultimately going to give us a solution to the problem by allowing us to assign some day to each of the classes such that we don't have any conflicts between classes. So it turns out that we can classify the constraints in a constraint satisfaction problem into a number of different categories. The first of those categories are perhaps the simplest of the types of constraints, which are known as unary constraints, where unary constraint is a constraint that just involves a single variable. For example, a unary constraint might be something like, a does not equal Monday, meaning Course A cannot have its exam on Monday. If for some reason the instructor for the course isn't available on Monday, you might have a constraint in your problem that looks like this, something that just has a single variable a in it, and maybe says a is not equal to Monday, or a is equal to something, or in the case of numbers greater than or less than something, a constraint that just has one variable, we consider to be a unary constraint. And this is in contrast to something like a binary constraint, which is a constraint that involves two variables, for example. So this would be a constraint like the ones we were looking at before. Something like a does not equal b is an example of a binary constraint, because it is a constraint that has two variables involved in it, a and b. And we represented that using some arc or some edge that connects variable a to variable b. And using this knowledge of, OK, what is a unary constraint? What is a binary constraint? There are different types of things we can say about a particular constraint satisfaction problem. And one thing we can say is we can try and make the problem node consistent. So what does node consistency mean? Node consistency means that we have all of the values in a variable's domain satisfying that variable's unary constraints. So for each of the variables inside of our constraint satisfaction problem, if all of the values satisfy the unary constraints for that particular variable, we can say that the entire problem is node consistent, or we can even say that a particular variable is node consistent if we just want to make one node consistent within itself. So what does that actually look like? Let's look at now a simplified example, where instead of having a whole bunch of different classes, we just have two classes, a and b, each of which has an exam on either Monday or Tuesday or Wednesday. So this is the domain for the variable a, and this is the domain for the variable b. And now let's imagine we have these constraints, a not equal to Monday, b not equal to Tuesday, b not equal to Monday, a not equal to b. So those are the constraints that we have on this particular problem. And what we can now try to do is enforce node consistency. And node consistency just means we make sure that all of the values for any variable's domain satisfy its unary constraints. And so we could start by trying to make node a node consistent. Is it consistent? Does every value inside of a's domain satisfy its unary constraints? Well, initially, we'll see that Monday does not satisfy a's unary constraints, because we have a constraint, a unary constraint here, that a is not equal to Monday. But Monday is still in a's domain. And so this is something that is not node consistent, because we have Monday in the domain. But this is not a valid value for this particular node. And so how do we make this node consistent? Well, to make the node consistent, what we'll do is we'll just go ahead and remove Monday from a's domain. Now a can only be on Tuesday or Wednesday, because we had this constraint that said a is not equal to Monday. And at this point now, a is node consistent. For each of the values that a can take on, Tuesday and Wednesday, there is no constraint that is a unary constraint that conflicts with that idea. There is no constraint that says that a can't be Tuesday. There is no unary constraint that says that a cannot be on Wednesday. And so now we can turn our attention to b. b also has a domain, Monday, Tuesday, and Wednesday. And we can begin to see whether those variables satisfy the unary constraints as well. Well, here is a unary constraint, b is not equal to Tuesday. And that does not appear to be satisfied by this domain of Monday, Tuesday, and Wednesday, because Tuesday, this possible value that the variable b could take on is not consistent with this unary constraint, that b is not equal to Tuesday. So to solve that problem, we'll go ahead and remove Tuesday from b's domain. Now b's domain only contains Monday and Wednesday. But as it turns out, there's yet another unary constraint that we placed on the variable b, which is here. b is not equal to Monday. And that means that this value, Monday, inside of b's domain, is not consistent with b's unary constraints, because we have a constraint that says the b cannot be Monday. And so we can remove Monday from b's domain. And now we've made it through all of the unary constraints. We've not yet considered this constraint, which is a binary constraint. But we've considered all of the unary constraints, all of the constraints that involve just a single variable. And we've made sure that every node is consistent with those unary constraints. So we can say that now we have enforced node consistency, that for each of these possible nodes, we can pick any of these values in the domain. And there won't be a unary constraint that is violated as a result of it. So node consistency is fairly easy to enforce. We just take each node, make sure the values in the domain satisfy the unary constraints. Where things get a little bit more interesting is when we consider different types of consistency, something like arc consistency, for example. And arc consistency refers to when all of the values in a variable's domain satisfy the variable's binary constraints. So when we're looking at trying to make a arc consistent, we're no longer just considering the unary constraints that involve a. We're trying to consider all of the binary constraints that involve a as well. So any edge that connects a to another variable inside of that constraint graph that we were taking a look at before. Put a little bit more formally, arc consistency. And arc really is just another word for an edge that connects two of these nodes inside of our constraint graph. We can define arc consistency a little more precisely like this. In order to make some variable x arc consistent with respect to some other variable y, we need to remove any element from x's domain to make sure that every choice for x, every choice in x's domain, has a possible choice for y. So put another way, if I have a variable x and I want to make x an arc consistent, then I'm going to look at all of the possible values that x can take on and make sure that for all of those possible values, there is still some choice that I can make for y, if there's some arc between x and y, to make sure that y has a possible option that I can choose as well. So let's look at an example of that going back to this example from before. We enforced node consistency already by saying that a can only be on Tuesday or Wednesday because we knew that a could not be on Monday. And we also said that b's only domain only consists of Wednesday because we know that b does not equal Tuesday and also b does not equal Monday. So now let's begin to consider arc consistency. Let's try and make a arc consistent with b. And what that means is to make a arc consistent with respect to b means that for any choice we make in a's domain, there is some choice we can make in b's domain that is going to be consistent. And we can try that. For a, we can choose Tuesday as a possible value for a. If I choose Tuesday for a, is there a value for b that satisfies the binary constraint? Well, yes, b Wednesday would satisfy this constraint that a does not equal b because Tuesday does not equal Wednesday. However, if we chose Wednesday for a, well, then there is no choice in b's domain that satisfies this binary constraint. There is no way I can choose something for b that satisfies a does not equal b because I know b must be Wednesday. And so if ever I run into a situation like this where I see that here is a possible value for a such that there is no choice of value for b that satisfies the binary constraint, well, then this is not arc consistent. And to make it arc consistent, I would need to take Wednesday and remove it from a's domain. Because Wednesday was not going to be a possible choice I can make for a because it wasn't consistent with this binary constraint for b. There was no way I could choose Wednesday for a and still have an available solution by choosing something for b as well. So here now, I've been able to enforce arc consistency. And in doing so, I've actually solved this entire problem, that given these constraints where a and b can have exams on either Monday or Tuesday or Wednesday, the only solution, as it would appear, is that a's exam must be on Tuesday and b's exam must be on Wednesday. And that is the only option available to me. So if we want to apply our consistency to a larger graph, not just looking at one particular pair of our consistency, there are ways we can do that too. And we can begin to formalize what the pseudocode would look like for trying to write an algorithm that enforces arc consistency. And we'll start by defining a function called revise. Revise is going to take as input a CSP, otherwise known as a constraint satisfaction problem, and also two variables, x and y. And what revise is going to do is it is going to make x arc consistent with respect to y, meaning remove anything from x's domain that doesn't allow for a possible option for y. How does this work? Well, we'll go ahead and first keep track of whether or not we've made a revision. Revise is ultimately going to return true or false. It'll return true in the event that we did make a revision to x's domain. It'll return false if we didn't make any change to x's domain. And we'll see in a moment why that's going to be helpful. But we start by saying revised equals false. We haven't made any changes. Then we'll say, all right, let's go ahead and loop over all of the possible values in x's domain. So loop over x's domain for each little x in x's domain. I want to make sure that for each of those choices, I have some available choice in y that satisfies the binary constraints that are defined inside of my CSP, inside of my constraint satisfaction problem. So if ever it's the case that there is no value y in y's domain that satisfies the constraint for x and y, well, if that's the case, that means that this value x shouldn't be in x's domain. So we'll go ahead and delete x from x's domain. And I'll set revised equal to true because I did change x's domain. I changed x's domain by removing little x. And I removed little x because it wasn't art consistent. There was no way I could choose a value for y that would satisfy this xy constraint. So in this case, we'll go ahead and set revised equal true. And we'll do this again and again for every value in x's domain. Sometimes it might be fine. In other cases, it might not allow for a possible choice for y, in which case we need to remove this value from x's domain. And at the end, we just return revised to indicate whether or not we actually made a change. So this function, then, this revised function is effectively an implementation of what you saw me do graphically a moment ago. And it makes one variable, x, arc consistent with another variable, in this case, y. But generally speaking, when we want to enforce our consistency, we'll often want to enforce our consistency not just for a single arc, but for the entire constraint satisfaction problem. And it turns out there's an algorithm to do that as well. And that algorithm is known as AC3. AC3 takes a constraint satisfaction problem. And it enforces our consistency across the entire problem. How does it do that? Well, it's going to basically maintain a queue or basically just a line of all of the arcs that it needs to make consistent. And over time, we might remove things from that queue as we begin dealing with our consistency. And we might need to add things to that queue as well if there are more things we need to make arc consistent. So we'll go ahead and start with a queue that contains all of the arcs in the constraint satisfaction problem, all of the edges that connect two nodes that have some sort of binary constraint between them. And now, as long as the queue is non-empty, there is work to be done. The queue is all of the things that we need to make arc consistent. So as long as the queue is non-empty, there's still things we have to do. What do we have to do? Well, we'll start by de-queuing from the queue, remove something from the queue. And strictly speaking, it doesn't need to be a queue, but a queue is a traditional way of doing this. We'll de-queue from the queue, and that'll give us an arc, x and y, these two variables where I would like to make x arc consistent with y. So how do we make x arc consistent with y? Well, we can go ahead and just use that revise function that we talked about a moment ago. We called the revise function, passing as input the constraint satisfaction problem, and also these variables x and y, because I want to make x arc consistent with y. In other words, remove any values from x's domain that don't leave an available option for y. And recall, what does revised return? Well, it returns true if we actually made a change, if we removed something from x's domain, because there wasn't an available option for y, for example. And it returns false if we didn't make any change to x's domain at all. And it turns out if revised returns false, if we didn't make any changes, well, then there's not a whole lot more work to be done here for this arc. We can just move ahead to the next arc that's in the queue. But if we did make a change, if we did reduce x's domain by removing values from x's domain, well, then what we might realize is that this creates potential problems later on, that it might mean that some arc that was arc consistent with x, that node might no longer be arc consistent with x, because while there used to be an option that we could choose for x, now there might not be, because now we might have removed something from x that was necessary for some other arc to be arc consistent. And so if ever we did revise x's domain, we're going to need to add some things to the queue, some additional arcs that we might want to check. How do we do that? Well, first thing we want to check is to make sure that x's domain is not 0. If x's domain is 0, that means there are no available options for x at all. And that means that there's no way you can solve the constraint satisfaction problem. If we've removed everything from x's domain, we'll go ahead and just return false here to indicate there's no way to solve the problem, because there's nothing left in x's domain. But otherwise, if there are things left in x's domain, but fewer things than before, well, then what we'll do is we'll loop over each variable z that is in all of x's neighbors, except for y, y we already handled. But we'll consider all of x's other's neighbors and ask ourselves, all right, will that arc from each of those z's to x, that arc might no longer be arc consistent, because while for each z, there might have been a possible option we could choose for x to correspond with each of z's possible values, now there might not be, because we removed some elements from x's domain. And so what we'll do here is we'll go ahead and enqueue, adding something to the queue, this arc zx for all of those neighbors z. So we need to add back some arcs to the queue in order to continue to enforce arc consistency. At the very end, if we make it through all this process, then we can return true. But this now is AC3, this algorithm for enforcing arc consistency on a constraint satisfaction problem. And the big idea is really just keep track of all of the arcs that we might need to make arc consistent, make it arc consistent by calling the revise function. And if we did revise it, then there are some new arcs that might need to be added to the queue in order to make sure that everything is still arc consistent, even after we've removed some of the elements from a particular variable's domain. So what then would happen if we tried to enforce arc consistency on a graph like this, on a graph where each of these variables has a domain of Monday, Tuesday, and Wednesday? Well, it turns out that by enforcing arc consistency on this graph, well, it can solve some types of problems. Nothing actually changes here. For any particular arc, just considering two variables, there's always a way for me to just, for any of the choices I make for one of them, make a choice for the other one, because there are three options, and I just need the two to be different from each other. So this is actually quite easy to just take an arc and just declare that it is arc consistent, because if I pick Monday for D, then I just pick something that isn't Monday for B. In arc consistency, we only consider consistency between a binary constraint between two nodes, and we're not really considering all of the rest of the nodes yet. So just using AC3, the enforcement of arc consistency, that can sometimes have the effect of reducing domains to make it easier to find solutions, but it will not always actually solve the problem. We might still need to somehow search to try and find a solution. And we can use classical traditional search algorithms to try to do so. You'll recall that a search problem generally consists of these parts. We have some initial state, some actions, a transition model that takes me from one state to another state, a goal test to tell me have I satisfied my objective correctly, and then some path cost function, because in the case of like maze solving, I was trying to get to my goal as quickly as possible. So you could formulate a CSP, or a constraint satisfaction problem, as one of these types of search problems. The initial state will just be an empty assignment, where an assignment is just a way for me to assign any particular variable to any particular value. So if an empty assignment is no variables that are assigned to any values yet, then the action I can take is adding some new variable equals value pair to that assignment, saying for this assignment, let me add a new value for this variable. And the transition model just defines what happens when you take that action. You get a new assignment that has that variable equal to that value inside of it. The goal test is just checking to make sure all the variables have been assigned and making sure all the constraints have been satisfied. And the path cost function is sort of irrelevant. I don't really care about what the path really is. I just care about finding some assignment that actually satisfies all of the constraints. So really, all the paths have the same cost. I don't really care about the path to the goal. I just care about the solution itself, much as we've talked about now before. The problem here, though, is that if we just implement this naive search algorithm just by implementing like breadth-first search or depth-first search, this is going to be very, very inefficient. And there are ways we can take advantage of efficiencies in the structure of a constraint satisfaction problem itself. And one of the key ideas is that we can really just order these variables. And it doesn't matter what order we assign variables in. The assignment a equals 2 and then b equals 8 is identical to the assignment of b equals 8 and then a equals 2. Switching the order doesn't really change anything about the fundamental nature of that assignment. And so there are some ways that we can try and revise this idea of a search algorithm to apply it specifically for a problem like a constraint satisfaction problem. And it turns out the search algorithm we'll generally use when talking about constraint satisfaction problems is something known as backtracking search. And the big idea of backtracking search is we'll go ahead and make assignments from variables to values. And if ever we get stuck, we arrive at a place where there is no way we can make any forward progress while still preserving the constraints that we need to enforce, we'll go ahead and backtrack and try something else instead. So the very basic sketch of what backtracking search looks like is it looks like this. Function called backtrack that takes as input an assignment and a constraint satisfaction problem. So initially, we don't have any assigned variables. So when we begin backtracking search, this assignment is just going to be the empty assignment with no variables inside of it. But we'll see later this is going to be a recursive function. So backtrack takes as input the assignment and the problem. If the assignment is complete, meaning all of the variables have been assigned, we just return that assignment. That, of course, won't be true initially, because we start with an empty assignment. But over time, we might add things to that assignment. So if ever the assignment actually is complete, then we're done. Then just go ahead and return that assignment. But otherwise, there is some work to be done. So what we'll need to do is select an unassigned variable for this particular problem. So we need to take the problem, look at the variables that have already been assigned, and pick a variable that has not yet been assigned. And I'll go ahead and take that variable. And then I need to consider all of the values in that variable's domain. So we'll go ahead and call this domain values function. We'll talk a little more about that later, that takes a variable and just gives me back an ordered list of all of the values in its domain. So I've taken a random unselected variable. I'm going to loop over all of the possible values. And the idea is, let me just try all of these values as possible values for the variable. So if the value is consistent with the assignment so far, it doesn't violate any of the constraints, well then let's go ahead and add variable equals value to the assignment because it's so far consistent. And now let's recursively call backtrack to try and make the rest of the assignments also consistent. So I'll go ahead and call backtrack on this new assignment that I've added the variable equals value to. And now I recursively call backtrack and see what the result is. And if the result isn't a failure, well then let me just return that result. And otherwise, what else could happen? Well, if it turns out the result was a failure, well then that means this value was probably a bad choice for this particular variable because when I assigned this variable equal to that value, eventually down the road I ran into a situation where I violated constraints. There was nothing more I could do. So now I'll remove variable equals value from the assignment, effectively backtracking to say, all right, that value didn't work. Let's try another value instead. And then at the very end, if we were never able to return a complete assignment, we'll just go ahead and return failure because that means that none of the values worked for this particular variable. This now is the idea for backtracking search, to take each of the variables, try values for them, and recursively try backtracking search, see if we can make progress. And if ever we run into a dead end, we run into a situation where there is no possible value we can choose that satisfies the constraints, we return failure. And that propagates up, and eventually we make a different choice by going back and trying something else instead. So let's put this algorithm into practice. Let's actually try and use backtracking search to solve this problem now, where I need to figure out how to assign each of these courses to an exam slot on Monday or Tuesday or Wednesday in such a way that it satisfies these constraints, that each of these edges mean those two classes cannot have an exam on the same day. So I can start by just starting at a node. It doesn't really matter which I start with, but in this case, I'll just start with A. And I'll ask the question, all right, let me loop over the values in the domain. And maybe in this case, I'll just start with Monday and say, all right, let's go ahead and assign A to Monday. We'll just go and order Monday, Tuesday, Wednesday. And now let's consider node B. So I've made an assignment to A, so I recursively call backtrack with this new part of the assignment. And now I'm looking to pick another unassigned variable like B. And I'll say, all right, maybe I'll start with Monday, because that's the very first value in B's domain. And I ask, all right, does Monday violate any constraints? And it turns out, yes, it does. It violates this constraint here between A and B, because A and B are now both on Monday, and that doesn't work, because B can't be on the same day as A. So that doesn't work. So we might instead try Tuesday, try the next value in B's domain. And is that consistent with the assignment so far? Well, yeah, B, Tuesday, A, Monday, that is consistent so far, because they're not on the same day. So that's good. Now we can recursively call backtrack. Try again. Pick another unassigned variable, something like D, and say, all right, let's go through its possible values. Is Monday consistent with this assignment? Well, yes, it is. B and D are on different days, Monday versus Tuesday. And A and B are also on different days, Monday versus Tuesday. So that's fine so far, too. We'll go ahead and try again. Maybe we'll go to this variable here, E. Say, can we make that consistent? Let's go through the possible values. We've recursively called backtrack. We might start with Monday and say, all right, that's not consistent, because D and E now have exams on the same day. So we might try Tuesday instead, going to the next one. Ask, is that consistent? Well, no, it's not, because B and E, those have exams on the same day. And so we try, all right, is Wednesday consistent? And in turn, it's like, all right, yes, it is. Wednesday is consistent, because D and E now have exams on different days. B and E now have exams on different days. All seems to be well so far. I recursively call backtrack, select another unassigned variable, we'll say maybe choose C this time, and say, all right, let's try the values that C could take on. Let's start with Monday. And it turns out that's not consistent, because now A and C both have exams on the same day. So I try Tuesday and say, that's not consistent either, because B and C now have exams on the same day. And then I say, all right, let's go ahead and try Wednesday. But that's not consistent either, because C and E each have exams on the same day too. So now we've gone through all the possible values for C, Monday, Tuesday, and Wednesday. And none of them are consistent. There is no way we can have a consistent assignment. Backtrack, in this case, will return a failure. And so then we'd say, all right, we have to backtrack back to here. Well, now for E, we've tried all of Monday, Tuesday, and Wednesday. And none of those work, because Wednesday, which seemed to work, turned out to be a failure. So that means there's no possible way we can assign E. So that's a failure too. We have to go back up to D, which means that Monday assignment to D, that must be wrong. We must try something else. So we can try, all right, what if instead of Monday, we try Tuesday? Tuesday, it turns out, is not consistent, because B and D now have an exam on the same day. But Wednesday, as it turns out, works. And now we can begin to mix and forward progress again. We go back to E and say, all right, which of these values works? Monday turns out to work by not violating any constraints. Then we go up to C now. Monday doesn't work, because it violates a constraint. Violates two, actually. Tuesday doesn't work, because it violates a constraint as well. But Wednesday does work. Then we can go to the next variable, F, and say, all right, does Monday work? We'll know. It violates a constraint. But Tuesday does work. And then finally, we can look at the last variable, G, recursively calling backtrack one more time. Monday is inconsistent. That violates a constraint. Tuesday also violates a constraint. But Wednesday, that doesn't violate a constraint. And so now at this point, we recursively call backtrack one last time. We now have a satisfactory assignment of all of the variables. And at this point, we can say that we are now done. We have now been able to successfully assign a variable or a value to each one of these variables in such a way that we're not violating any constraints. We're going to go ahead and have classes A and E have their exams on Monday. Classes B and F can have their exams on Tuesday. And classes C, D, and G can have their exams on Wednesday. And there's no violated constraints that might come up there. So that then was a graphical look at how this might work. Let's now take a look at some code we could use to actually try and solve this problem as well. So here I'll go ahead and go into the scheduling directory. We're here now. We'll start by looking at schedule0.py. We're here. I define a list of variables, A, B, C, D, E, F, G. Those are all different classes. Then underneath that, I define my list of constraints. So constraint A and B. That is a constraint because they can't be on the same day. Likewise, A and C, B and C, so on and so forth, enforcing those exact same constraints. And here then is what the backtracking function might look like. First, if the assignment is complete, if I've made an assignment of every variable to a value, go ahead and just return that assignment. Then we'll select an unassigned variable from that assignment. Then for each of the possible values in the domain, Monday, Tuesday, Wednesday, let's go ahead and create a new assignment that assigns the variable to that value. I'll call this consistent function, which I'll show you in a moment, that just checks to make sure this new assignment is consistent. But if it is consistent, we'll go ahead and call backtrack to go ahead and continue trying to run backtracking search. And as long as the result is not none, meaning it wasn't a failure, we can go ahead and return that result. But if we make it through all the values and nothing works, then it is a failure. There's no solution. We go ahead and return none here. What do these functions do? Select unassigned variable is just going to choose a variable not yet assigned. So it's going to loop over all the variables. And if it's not already assigned, we'll go ahead and just return that variable. And what does the consistent function do? Well, the consistent function goes through all the constraints. And if we have a situation where we've assigned both of those values to variables, but they are the same, well, then that is a violation of the constraint, in which case we'll return false. But if nothing is inconsistent, then the assignment is consistent and will return true. And then all the program does is it calls backtrack on an empty assignment, an empty dictionary that has no variable assigned and no values yet, save that inside a solution, and then print out that solution. So by running this now, I can run Python schedule0.py. And what I get as a result of that is an assignment of all these variables to values. And it turns out we assign a to Monday as we would expect, b to Tuesday, c to Wednesday, exactly the same type of thing we were talking about before, an assignment of each of these variables to values that doesn't violate any constraints. And I had to do a fair amount of work in order to implement this idea myself. I had to write the backtrack function that went ahead and went through this process of recursively trying to do this backtracking search. But it turns out the constraint satisfaction problems are so popular that there exist many libraries that already implement this type of idea. Again, as with before, the specific library is not as important as the fact that libraries do exist. This is just one example of a Python constraint library, where now, rather than having to do all the work from scratch inside of schedule1.py, I'm just taking advantage of a library that implements a lot of these ideas already. So here, I create a new problem, add variables to it with particular domains. I add a whole bunch of these individual constraints, where I call addConstraint and pass in a function describing what the constraint is. And the constraint basically says the function that takes two variables, x and y, and makes sure that x is not equal to y, enforcing the idea that these two classes cannot have exams on the same day. And then, for any constraint satisfaction problem, I can call getSolutions to get all the solutions to that problem. And then, for each of those solutions, print out what that solution happens to be. And if I run python schedule1.py, and now see, there are actually a number of different solutions that can be used to solve the problem. There are, in fact, six different solutions, assignments of variables to values that will give me a satisfactory answer to this constraint satisfaction problem. So this then was an implementation of a very basic backtracking search method, where really we just went through each of the variables, picked one that wasn't assigned, tried the possible values the variable could take on. And then, if it worked, if it didn't violate any constraints, then we kept trying other variables. And if ever we hit a dead end, we had to backtrack. But ultimately, we might be able to be a little bit more intelligent about how we do this in order to improve the efficiency of how we solve these sorts of problems. And one thing we might imagine trying to do is going back to this idea of inference, using the knowledge we know to be able to draw conclusions in order to make the rest of the problem solving process a little bit easier. And let's now go back to where we got stuck in this problem the first time. When we were solving this constraint satisfaction problem, we dealt with B. And then we went on to D. And we went ahead and just assigned D to Monday, because that seemed to work with the assignment so far. It didn't violate any constraints. But it turned out that later on that choice turned out to be a bad one, that that choice wasn't consistent with the rest of the values that we could take on here. And the question is, is there anything we could do to avoid getting into a situation like this, avoid trying to go down a path that's ultimately not going to lead anywhere by taking advantage of knowledge that we have initially? And it turns out we do have that kind of knowledge. We can look at just the structure of this graph so far. And we can say that right now C's domain, for example, contains values Monday, Tuesday, and Wednesday. And based on those values, we can say that this graph is not arc consistent. Recall that arc consistency is all about making sure that for every possible value for a particular node, that there is some other value that we are able to choose. And as we can see here, Monday and Tuesday are not going to be possible values that we can choose for C. They're not going to be consistent with a node like B, for example, because B is equal to Tuesday, which means that C cannot be Tuesday. And because A is equal to Monday, C also cannot be Monday. So using that information, by making C arc consistent with A and B, we could remove Monday and Tuesday from C's domain and just leave C with Wednesday, for example. And if we continued to try and enforce arc consistency, we'd see there are some other conclusions we can draw as well. We see that B's only option is Tuesday and C's only option is Wednesday. And so if we want to make E arc consistent, well, E can't be Tuesday, because that wouldn't be arc consistent with B. And E can't be Wednesday, because that wouldn't be arc consistent with C. So we can go ahead and say E and just set that equal to Monday, for example. And then we can begin to do this process again and again, that in order to make D arc consistent with B and E, then D would have to be Wednesday. That's the only possible option. And likewise, we can make the same judgments for F and G as well. And it turns out that without having to do any additional search, just by enforcing arc consistency, we were able to actually figure out what the assignment of all the variables should be without needing to backtrack at all. And the way we did that is by interleaving this search process and the inference step, by this step of trying to enforce arc consistency. And the algorithm to do this is often called just the maintaining arc consistency algorithm, which just enforces arc consistency every time we make a new assignment of a value to an existing variable. So sometimes we can enforce our consistency using that AC3 algorithm at the very beginning of the problem before we even begin searching in order to limit the domain of the variables in order to make it easier to search. But we can also take advantage of the interleaving of enforcing our consistency with search such that every time in the search process we make a new assignment, we go ahead and enforce arc consistency as well to make sure that we're just eliminating possible values from domains whenever possible. And how do we do this? Well, this is really equivalent to just every time we make a new assignment to a variable x. We'll go ahead and call our AC3 algorithm, this algorithm that enforces arc consistency on a constraint satisfaction problem. And we go ahead and call that, starting it with a Q, not of all of the arcs, which we did originally, but just of all of the arcs that we want to make arc consistent with x, this thing that we have just made an assignment to. So all arcs yx, where y is a neighbor of x, something that shares a constraint with x, for example. And by maintaining arc consistency in the backtracking search process, we can ultimately make our search process a little bit more efficient. And so this is the revised version of this backtrack function. Same as before, the changes here are highlighted in yellow. Every time we add a new variable equals value to our assignment, we'll go ahead and run this inference procedure, which might do a number of different things. But one thing it could do is call the maintaining arc consistency algorithm to make sure we're able to enforce arc consistency on the problem. And we might be able to draw new inferences as a result of that process. Get new guarantees of this variable needs to be equal to that value, for example. That might happen one time. It might happen many times. And so long as those inferences are not a failure, as long as they don't lead to a situation where there is no possible way to make forward progress, well, then we can go ahead and add those inferences, those new knowledge, that new pieces of knowledge I know about what variables should be assigned to what values, I can add those to the assignment in order to more quickly make forward progress by taking advantage of information that I can just deduce, information I know based on the rest of the structure of the constraint satisfaction problem. And the only other change I'll need to make now is if it turns out this value doesn't work, well, then down here, I'll go ahead and need to remove not only variable equals value, but also any of those inferences that I made, remove that from the assignment as well. So here, then, we're often able to solve the problem by backtracking less than we might originally have needed to, just by taking advantage of the fact that every time we make a new assignment of one variable to one value, that might reduce the domains of other variables as well. And we can use that information to begin to more quickly draw conclusions in order to try and solve the problem more efficiently as well. And it turns out there are other heuristics we can use to try and improve the efficiency of our search process as well. And it really boils down to a couple of these functions that I've talked about, but we haven't really talked about how they're working. And one of them is this function here, select unassigned variable, where we're selecting some variable in the constraint satisfaction problem that has not yet been assigned. So far, I've sort of just been selecting variables randomly, just like picking one variable and one unassigned variable in order to decide, all right, this is the variable that we're going to assign next, and then going from there. But it turns out that by being a little bit intelligent, by following certain heuristics, we might be able to make the search process much more efficient just by choosing very carefully which variable we should explore next. So some of those heuristics include the minimum remaining values, or MRV heuristic, which generally says that if I have a choice between which variable I should select, I should select the variable with the smallest domain, the variable that has the fewest number of remaining values left. With the idea being, if there are only two remaining values left, well, I may as well prune one of them very quickly in order to get to the other, because one of those two has got to be the solution, if a solution does exist. Sometimes minimum remaining values might not give a conclusive result if all the nodes have the same number of remaining values, for example. And in that case, another heuristic that can be helpful to look at is the degree heuristic. The degree of a node is the number of nodes that are attached to that node, the number of nodes that are constrained by that particular node. And if you imagine which variable should I choose, should I choose a variable that has a high degree that is connected to a lot of different things, or a variable with a low degree that is not connected to a lot of different things, well, it can often make sense to choose the variable that has the highest degree that is connected to the most other nodes as the thing you would search first. Why is that the case? Well, it's because by choosing a variable with a high degree, that is immediately going to constrain the rest of the variables more, and it's more likely to be able to eliminate large sections of the state space that you don't need to search through at all. So what could this actually look like? Let's go back to this search problem here. In this particular case, I've made an assignment here. I've made an assignment here. And the question is, what should I look at next? And according to the minimum remaining values heuristic, what I should choose is the variable that has the fewest remaining possible values. And in this case, that's this node here, node C, that only has one variable left in this domain, which in this case is Wednesday, which is a very reasonable choice of a next assignment to make, because I know it's the only option, for example. I know that the only possible option for C is Wednesday, so I may as well make that assignment and then potentially explore the rest of the space after that. But meanwhile, at the very start of the problem, when I didn't have any knowledge of what nodes should have what values yet, I still had to pick what node should be the first one that I try and assign a value to. And I arbitrarily just chose the one at the top, node A originally. But we can be more intelligent about that. We can look at this particular graph. All of them have domains of the same size, domain of size 3. So minimum remaining values doesn't really help us there. But we might notice that node E has the highest degree. It is connected to the most things. And so perhaps it makes sense to begin our search, rather than starting at node A at the very top, start with the node with the highest degree. Start by searching from node E, because from there, that's going to much more easily allow us to enforce the constraints that are nearby, eliminating large portions of the search space that I might not need to search through. And in fact, by starting with E, we can immediately then assign other variables. And following that, we can actually assign the rest of the variables without needing to do any backtracking at all, even if I'm not using this inference procedure. Just by starting with a node that has a high degree, that is going to very quickly restrict the possible values that other nodes can take on. So that then is how we can go about selecting an unassigned variable in a particular order. Rather than randomly picking a variable, if we're a little bit intelligent about how we choose it, we can make our search process much, much more efficient by making sure we don't have to search through portions of the search space that ultimately aren't going to matter. The other variable we haven't really talked about, the other function here, is this domain values function. This domain values function that takes a variable and gives me back a sequence of all of the values inside of that variable's domain. The naive way to approach it is what we did before, which is just go in order, go Monday, then Tuesday, then Wednesday. But the problem is that going in that order might not be the most efficient order to search in, that sometimes it might be more efficient to choose values that are likely to be solutions first and then go to other values. Now, how do you assess whether a value is likelier to lead to a solution or less likely to lead to a solution? Well, one thing you can take a look at is how many constraints get added, how many things get removed from domains as you make this new assignment of a variable to this particular value. And the heuristic we can use here is the least constraining value heuristic, which is the idea that we should return variables in order based on the number of choices that are ruled out for neighboring values. And I want to start with the least constraining value, the value that rules out the fewest possible options. And the idea there is that if all I care about doing is finding a solution, if I start with a value that rules out a lot of other choices, I'm ruling out a lot of possibilities that maybe is going to make it less likely that this particular choice leads to a solution. Whereas on the other hand, if I have a variable and I start by choosing a value that doesn't rule out very much, well, then I still have a lot of space where there might be a solution that I could ultimately find. And this might seem a little bit counterintuitive and a little bit at odds with what we were talking about before, where I said, when you're picking a variable, you should pick the variable that is going to have the fewest possible values remaining. But here, I want to pick the value for the variable that is the least constraining. But the general idea is that when I am picking a variable, I would like to prune large portions of the search space by just choosing a variable that is going to allow me to quickly eliminate possible options. Whereas here, within a particular variable, as I'm considering values that that variable could take on, I would like to just find a solution. And so what I want to do is ultimately choose a value that still leaves open the possibility of me finding a solution to be as likely as possible. By not ruling out many options, I leave open the possibility that I can still find a solution without needing to go back later and backtrack. So an example of that might be in this particular situation here, if I'm trying to choose a variable for a value for node C here, that C is equal to either Tuesday or Wednesday. We know it can't be Monday because it conflicts with this domain here, where we already know that A is Monday, so C must be Tuesday or Wednesday. And the question is, should I try Tuesday first, or should I try Wednesday first? And if I try Tuesday, what gets ruled out? Well, one option gets ruled out here, a second option gets ruled out here, and a third option gets ruled out here. So choosing Tuesday would rule out three possible options. And what about choosing Wednesday? Well, choosing Wednesday would rule out one option here, and it would rule out one option there. And so I have two choices. I can choose Tuesday that rules out three options, or Wednesday that rules out two options. And according to the least constraining value heuristic, what I should probably do is go ahead and choose Wednesday, the one that rules out the fewest number of possible options, leaving open as many chances as possible for me to eventually find the solution inside of the state space. And ultimately, if you continue this process, we will find the solution, an assignment of variables, two values, that allows us to give each of these exams, each of these classes, an exam date that doesn't conflict with anyone that happens to be enrolled in two classes at the same time. So the big takeaway now with all of this is that there are a number of different ways we can formulate a problem. The ways we've looked at today are we can formulate a problem as a local search problem, a problem where we're looking at a current node and moving to a neighbor based on whether that neighbor is better or worse than the current node that we are looking at. We looked at formulating problems as linear programs, where just by putting things in terms of equations and constraints, we're able to solve problems a little bit more efficiently. And we saw formulating a problem as a constraint satisfaction problem, creating this graph of all of the constraints that connect two variables that have some constraint between them, and using that information to be able to figure out what the solution should be. And so the takeaway of all of this now is that if we have some problem in artificial intelligence that we would like to use AI to be able to solve them, whether that's trying to figure out where hospitals should be or trying to solve the traveling salesman problem, trying to optimize productions and costs and whatnot, or trying to figure out how to satisfy certain constraints, whether that's in a Sudoku puzzle, or whether that's in trying to figure out how to schedule exams for a university, or any number of a wide variety of types of problems, if we can formulate that problem as one of these sorts of problems, then we can use these known algorithms, these algorithms for enforcing art consistency and backtracking search, these hill climbing and simulated annealing algorithms, these simplex algorithms and interior point algorithms that can be used to solve linear programs, that we can use those techniques to begin to solve a whole wide variety of problems all in this world of optimization inside of artificial intelligence. This was an introduction to artificial intelligence with Python for today. We will see you next time. [" All right. Welcome back, everyone, to an introduction to artificial intelligence with Python. Now, so far in this class, we've used AI to solve a number of different problems, giving AI instructions for how to search for a solution, or how to satisfy certain constraints in order to find its way from some input point to some output point in order to solve some sort of problem. Today, we're going to turn to the world of learning, in particular the idea of machine learning, which generally refers to the idea where we are not going to give the computer explicit instructions for how to perform a task, but rather we are going to give the computer access to information in the form of data, or patterns that it can learn from, and let the computer try and figure out what those patterns are, try and understand that data to be able to perform a task on its own. Now, machine learning comes in a number of different forms, and it's a very wide field. So today, we'll explore some of the foundational algorithms and ideas that are behind a lot of the different areas within machine learning. And one of the most popular is the idea of supervised machine learning, or just supervised learning. And supervised learning is a particular type of task. It refers to the task where we give the computer access to a data set, where that data set consists of input-output pairs. And what we would like the computer to do is we would like our AI to be able to figure out some function that maps inputs to outputs. So we have a whole bunch of data that generally consists of some kind of input, some evidence, some information that the computer will have access to. And we would like the computer, based on that input information, to predict what some output is going to be. And we'll give it some data so that the computer can train its model on and begin to understand how it is that this information works and how it is that the inputs and outputs relate to each other. But ultimately, we hope that our computer will be able to figure out some function that, given those inputs, is able to get those outputs. There are a couple of different tasks within supervised learning. The one we'll focus on and start with is known as classification. And classification is the problem where, if I give you a whole bunch of inputs, you need to figure out some way to map those inputs into discrete categories, where you can decide what those categories are, and it's the job of the computer to predict what those categories are going to be. So that might be, for example, I give you information about a bank note, like a US dollar, and I'm asking you to predict for me, does it belong to the category of authentic bank notes, or does it belong to the category of counterfeit bank notes? You need to categorize the input, and we want to train the computer to figure out some function to be able to do that calculation. Another example might be the case of weather, someone we've talked about a little bit so far in this class, where we would like to predict on a given day, is it going to rain on that day? Is it going to be cloudy on that day? And before we've seen how we could do this, if we really give the computer all the exact probabilities for if these are the conditions, what's the probability of rain? Oftentimes, we don't have access to that information, though. But what we do have access to is a whole bunch of data. So if we wanted to be able to predict something like, is it going to rain or is it not going to rain, we would give the computer historical information about days when it was raining and days when it was not raining and ask the computer to look for patterns in that data. So what might that data look like? Well, we could structure that data in a table like this. This might be what our table looks like, where for any particular day, going back, we have information about that day's humidity, that day's air pressure, and then importantly, we have a label, something where the human has said that on this particular day, it was raining or it was not raining. So you could fill in this table with a whole bunch of data. And what makes this what we would call a supervised learning exercise is that a human has gone in and labeled each of these data points, said that on this day, when these were the values for the humidity and pressure, that day was a rainy day and this day was a not rainy day. And what we would like the computer to be able to do then is to be able to figure out, given these inputs, given the humidity and the pressure, can the computer predict what label should be associated with that day? Does that day look more like it's going to be a day that rains or does it look more like a day when it's not going to rain? Put a little bit more mathematically, you can think of this as a function that takes two inputs, the inputs being the data points that our computer will have access to, things like humidity and pressure. So we could write a function f that takes as input both humidity and pressure. And then the output is going to be what category we would ascribe to these particular input points, what label we would associate with that input. So we've seen a couple of example data points here, where given this value for humidity and this value for pressure, we predict, is it going to rain or is it not going to rain? And that's information that we just gathered from the world. We measured on various different days what the humidity and pressure were. We observed whether or not we saw rain or no rain on that particular day. And this function f is what we would like to approximate. Now, the computer and we humans don't really know exactly how this function f works. It's probably quite a complex function. So what we're going to do instead is attempt to estimate it. We would like to come up with a hypothesis function. h, which is going to try to approximate what f does. We want to come up with some function h that will also take the same inputs and will also produce an output, rain or no rain. And ideally, we'd like these two functions to agree as much as possible. So the goal then of the supervised learning classification tasks is going to be to figure out, what does that function h look like? How can we begin to estimate, given all of this information, all of this data, what category or what label should be assigned to a particular data point? So where could you begin doing this? Well, a reasonable thing to do, especially in this situation, I have two numerical values, is I could try to plot this on a graph that has two axes, an x-axis and a y-axis. And in this case, we're just going to be using two numerical values as input. But these same types of ideas scale as you add more and more inputs as well. We'll be plotting things in two dimensions. But as we soon see, you could add more inputs and just imagine things in multiple dimensions. And while we humans have trouble conceptualizing anything really beyond three dimensions, at least visually, a computer has no problem with trying to imagine things in many, many more dimensions, that for a computer, each dimension is just some separate number that it is keeping track of. So it wouldn't be unreasonable for a computer to think in 10 dimensions or 100 dimensions to be able to try to solve a problem. But for now, we've got two inputs. So we'll graph things along two axes, an x-axis, which will here represent humidity, and a y-axis, which here represents pressure. And what we might do is say, let's take all of the days that were raining and just try to plot them on this graph and see where they fall on this graph. And here might be all of the rainy days, where each rainy day is one of these blue dots here that corresponds to a particular value for humidity and a particular value for pressure. And then I might do the same thing with the days that were not rainy. So take all the not rainy days, figure out what their values were for each of these two inputs, and go ahead and plot them on this graph as well. And I've here plotted them in red. So blue here stands for a rainy day. Red here stands for a not rainy day. And this then is the input that my computer has access to all of this input. And what I would like the computer to be able to do is to train a model such that if I'm ever presented with a new input that doesn't have a label associated with it, something like this white dot here, I would like to predict, given those values for each of the two inputs, should we classify it as a blue dot, a rainy day, or should we classify it as a red dot, a not rainy day? And if you're just looking at this picture graphically, trying to say, all right, this white dot, does it look like it belongs to the blue category, or does it look like it belongs to the red category, I think most people would agree that it probably belongs to the blue category. And why is that? Well, it looks like it's close to other blue dots. And that's not a very formal notion, but it's a notion that we'll formalize in just a moment. That because it seems to be close to this blue dot here, nothing else is closer to it, then we might say that it should be categorized as blue. It should fall into that category of, I think that day is going to be a rainy day based on that input. Might not be totally accurate, but it's a pretty good guess. And this type of algorithm is actually a very popular and common machine learning algorithm known as nearest neighbor classification. It's an algorithm for solving these classification-type problems. And in nearest neighbor classification, it's going to perform this algorithm. What it will do is, given an input, it will choose the class of the nearest data point to that input. By class, we just here mean category, like rain or no rain, counterfeit or not counterfeit. And we choose the category or the class based on the nearest data point. So given all that data, we just looked at, is the nearest data point a blue point or is it a red point? And depending on the answer to that question, we were able to make some sort of judgment. We were able to say something like, we think it's going to be blue or we think it's going to be red. So likewise, we could apply this to other data points that we encounter as well. If suddenly this data point comes about, well, its nearest data is red. So we would go ahead and classify this as a red point, not raining. Things get a little bit trickier, though, when you look at a point like this white point over here and you ask the same sort of question. Should it belong to the category of blue points, the rainy days? Or should it belong to the category of red points, the not rainy days? Now, nearest neighbor classification would say the way you solve this problem is look at which point is nearest to that point. You look at this nearest point and say it's red. It's a not rainy day. And therefore, according to nearest neighbor classification, I would say that this unlabeled point, well, that should also be red. It should also be classified as a not rainy day. But your intuition might think that that's a reasonable judgment to make, that it's the closest thing is a not rainy day. So may as well guess that it's a not rainy day. But it's probably also reasonable to look at the bigger picture of things to say, yes, it is true that the nearest point to it was a red point. But it's surrounded by a whole bunch of other blue points. So looking at the bigger picture, there's potentially an argument to be made that this point should actually be blue. And with only this data, we actually don't know for sure. We are given some input, something we're trying to predict. And we don't necessarily know what the output is going to be. So in this case, which one is correct is difficult to say. But oftentimes, considering more than just a single neighbor, considering multiple neighbors can sometimes give us a better result. And so there's a variant on the nearest neighbor classification algorithm that is known as the K nearest neighbor classification algorithm, where K is some parameter, some number that we choose, for how many neighbors are we going to look at. So one nearest neighbor classification is what we saw before. Just pick the one nearest neighbor and use that category. But with K nearest neighbor classification, where K might be 3, or 5, or 7, to say look at the 3, or 5, or 7 closest neighbors, closest data points to that point, works a little bit differently. This algorithm, we'll give it an input. Choose the most common class out of the K nearest data points to that input. So if we look at the five nearest points, and three of them say it's raining, and two of them say it's not raining, we'll go with the three instead of the two, because each one effectively gets one vote towards what they believe the category ought to be. And ultimately, you choose the category that has the most votes as a consequence of that. So K nearest neighbor classification, fairly straightforward one to understand intuitively. You just look at the neighbors and figure out what the answer might be. And it turns out this can work very, very well for solving a whole variety of different types of classification problems. But not every model is going to work under every situation. And so one of the things we'll take a look at today, especially in the context of supervised machine learning, is that there are a number of different approaches to machine learning, a number of different algorithms that we can apply, all solving the same type of problem, all solving some kind of classification problem where we want to take inputs and organize it into different categories. And no one algorithm is necessarily always going to be better than some other algorithm. They each have their trade-offs. And maybe depending on the data, one type of algorithm is going to be better suited to trying to model that information than some other algorithm. And so this is what a lot of machine learning research ends up being about, that when you're trying to apply machine learning techniques, you're often looking not just at one particular algorithm, but trying multiple different algorithms, trying to see what is going to give you the best results for trying to predict some function that maps inputs to outputs. So what then are the drawbacks of K nearest neighbor classification? Well, there are a couple. One might be that in a naive approach, at least, it could be fairly slow to have to go through and measure the distance between a point and every single one of these points that exist here. Now, there are ways of trying to get around that. There are data structures that can help to make it more quickly to be able to find these neighbors. There are also techniques you can use to try and prune some of this data, remove some of the data points so that you're only left with the relevant data points just to make it a little bit easier. But ultimately, what we might like to do is come up with another way of trying to do this classification. And one way of trying to do the classification was looking at what are the neighboring points. But another way might be to try to look at all of the data and see if we can come up with some decision boundary, some boundary that will separate the rainy days from the not rainy days. And in the case of two dimensions, we can do that by drawing a line, for example. So what we might want to try to do is just find some line, find some separator that divides the rainy days, the blue points over here, from the not rainy days, the red points over there. We're now trying a different approach in contrast with the nearest neighbor approach, which just looked at local data around the input data point that we cared about. Now what we're doing is trying to use a technique known as linear regression to find some sort of line that will separate the two halves from each other. Now sometimes it'll actually be possible to come up with some line that perfectly separates all the rainy days from the not rainy days. Realistically, though, this is probably cleaner than many data sets will actually be. Oftentimes, data is messier. There are outliers. There's random noise that happens inside of a particular system. And what we'd like to do is still be able to figure out what a line might look like. So in practice, the data will not always be linearly separable. Or linearly separable refers to some data set where I could draw a line just to separate the two halves of it perfectly. Instead, you might have a situation like this, where there are some rainy points that are on this side of the line and some not rainy points that are on that side of the line. And there may not be a line that perfectly separates what path of the inputs from the other half, that perfectly separates all the rainy days from the not rainy days. But we can still say that this line does a pretty good job. And we'll try to formalize a little bit later what we mean when we say something like this line does a pretty good job of trying to make that prediction. But for now, let's just say we're looking for a line that does as good of a job as we can at trying to separate one category of things from another category of things. So let's now try to formalize this a little bit more mathematically. We want to come up with some sort of function, some way we can define this line. And our inputs are things like humidity and pressure in this case. So our inputs we might call x1 is going to represent humidity, and x2 is going to represent pressure. These are inputs that we are going to provide to our machine learning algorithm. And given those inputs, we would like for our model to be able to predict some sort of output. And we are going to predict that using our hypothesis function, which we called h. Our hypothesis function is going to take as input x1 and x2, humidity and pressure in this case. And you can imagine if we didn't just have two inputs, we had three or four or five inputs or more, we could have this hypothesis function take all of those as input. And we'll see examples of that a little bit later as well. And now the question is, what does this hypothesis function do? Well, it really just needs to measure, is this data point on one side of the boundary, or is it on the other side of the boundary? And how do we formalize that boundary? Well, the boundary is generally going to be a linear combination of these input variables, at least in this particular case. So what we're trying to do when we say linear combination is take each of these inputs and multiply them by some number that we're going to have to figure out. We'll generally call that number a weight for how important should these variables be in trying to determine the answer. So we'll weight each of these variables with some weight, and we might add a constant to it just to try and make the function a little bit different. And the result, we just need to compare. Is it greater than 0, or is it less than 0 to say, does it belong on one side of the line or the other side of the line? So what that mathematical expression might look like is this. We would take each of my variables, x1 and x2, multiply them by some weight. I don't yet know what that weight is, but it's going to be some number, weight 1 and weight 2. And maybe we just want to add some other weight 0 to it, because the function might require us to shift the entire value up or down by a certain amount. And then we just compare. If we do all this math, is it greater than or equal to 0? If so, we might categorize that data point as a rainy day. And otherwise, we might say, no rain. So the key here, then, is that this expression is how we are going to calculate whether it's a rainy day or not. We're going to do a bunch of math where we take each of the variables, multiply them by a weight, maybe add an extra weight to it, see if the result is greater than or equal to 0. And using that result of that expression, we're able to determine whether it's raining or not raining. This expression here is in this case going to refer to just some line. If you were to plot that graphically, it would just be some line. And what the line actually looks like depends upon these weights. x1 and x2 are the inputs, but these weights are really what determine the shape of that line, the slope of that line, and what that line actually looks like. So we then would like to figure out what these weights should be. We can choose whatever weights we want, but we want to choose weights in such a way that if you pass in a rainy day's humidity and pressure, then you end up with a result that is greater than or equal to 0. And we would like it such that if we passed into our hypothesis function a not rainy day's inputs, then the output that we get should be not raining. So before we get there, let's try and formalize this a little bit more mathematically just to get a sense for how it is that you'll often see this if you ever go further into supervised machine learning and explore this idea. One thing is that generally for these categories, we'll sometimes just use the names of the categories like rain and not rain. Often mathematically, if we're trying to do comparisons between these things, it's easier just to deal in the world of numbers. So we could just say 1 and 0, 1 for raining, 0 for not raining. So we do all this math. And if the result is greater than or equal to 0, we'll go ahead and say our hypothesis function outputs 1, meaning raining. And otherwise, it outputs 0, meaning not raining. And oftentimes, this type of expression will instead express using vector mathematics. And all a vector is, if you're not familiar with the term, is it refers to a sequence of numerical values. You could represent that in Python using a list of numerical values or a tuple with numerical values. And here, we have a couple of sequences of numerical values. One of our vectors, one of our sequences of numerical values, are all of these individual weights, w0, w1, and w2. So we could construct what we'll call a weight vector, and we'll see why this is useful in a moment, called w, generally represented using a boldface w, that is just a sequence of these three weights, weight 0, weight 1, and weight 2. And to be able to calculate, based on those weights, whether we think a day is raining or not raining, we're going to multiply each of those weights by one of our input variables. That w2, this weight, is going to be multiplied by input variable x2. w1 is going to be multiplied by input variable x1. And w0, well, it's not being multiplied by anything. But to make sure the vectors are the same length, and we'll see why that's useful in just a second, we'll just go ahead and say w0 is being multiplied by 1. Because you can multiply by something by 1, and you end up getting the exact same number. So in addition to the weight vector w, we'll also have an input vector that we'll call x that has three values, 1, again, because we're just multiplying w0 by 1 eventually, and then x1 and x2. So here, then, we've represented two distinct vectors, a vector of weights that we need to somehow learn. The goal of our machine learning algorithm is to learn what this weight vector is supposed to be. We could choose any arbitrary set of numbers, and it would produce a function that tries to predict rain or not rain, but it probably wouldn't be very good. What we want to do is come up with a good choice of these weights so that we're able to do the accurate predictions. And then this input vector represents a particular input to the function, a data point for which we would like to estimate, is that day a rainy day, or is that day a not rainy day? And so that's going to vary just depending on what input is provided to our function, what it is that we are trying to estimate. And then to do the calculation, we want to calculate this expression here, and it turns out that expression is what we would call the dot product of these two vectors. The dot product of two vectors just means taking each of the terms in the vectors and multiplying them together, w0 multiply it by 1, w1 multiply it by x1, w2 multiply it by x2, and that's why these vectors need to be the same length. And then we just add all of the results together. So the dot product of w and x, our weight vector and our input vector, that's just going to be w0 times 1, or just w0, plus w1 times x1, multiplying these two terms together, plus w2 times x2, multiplying those terms together. So we have our weight vector, which we need to figure out. We need our machine learning algorithm to figure out what the weights should be. We have the input vector representing the data point that we're trying to predict a category for, predict a label for. And we're able to do that calculation by taking this dot product, which you'll often see represented in vector form. But if you haven't seen vectors before, you can think of it as identical to just this mathematical expression, just doing the multiplication, adding the results together, and then seeing whether the result is greater than or equal to 0 or not. This expression here is identical to the expression that we're calculating to see whether or not that answer is greater than or equal to 0 in this case. And so for that reason, you'll often see the hypothesis function written as something like this, a simpler representation where the hypothesis takes as input some input vector x, some humidity and pressure for some day. And we want to predict an output like rain or no rain or 1 or 0 if we choose to represent things numerically. And the way we do that is by taking the dot product of the weights and our input. If it's greater than or equal to 0, we'll go ahead and say the output is 1. Otherwise, the output is going to be 0. And this hypothesis, we say, is parameterized by the weights. Depending on what weights we choose, we'll end up getting a different hypothesis. If we choose the weights randomly, we're probably not going to get a very good hypothesis function. We'll get a 1 or a 0. But it's probably not accurately going to reflect whether we think a day is going to be rainy or not rainy. But if we choose the weights right, we can often do a pretty good job of trying to estimate whether we think the output of the function should be a 1 or a 0. And so the question, then, is how to figure out what these weights should be, how to be able to tune those parameters. And there are a number of ways you can do that. One of the most common is known as the perceptron learning rule. And we'll see more of this later. But the idea of the perceptron learning rule, and we're not going to get too deep into the mathematics, we'll mostly just introduce it more conceptually, is to say that given some data point that we would like to learn from, some data point that has an input x and an output y, where y is like 1 for rain or 0 for not rain, then we're going to update the weights. And we'll look at the formula in just a moment. But the big picture idea is that we can start with random weights, but then learn from the data. Take the data points one at a time. And for each one of the data points, figure out, all right, what parameters do we need to change inside of the weights in order to better match that input point. And so that is the value of having access to a lot of data in the supervised machine learning algorithm, is that you take each of the data points and maybe look at them multiple times and constantly try and figure out whether you need to shift your weights in order to better create some weight vector that is able to correctly or more accurately try to estimate what the output should be, whether we think it's going to be raining or whether we think it's not going to be raining. So what does that weight update look like? Without going into too much of the mathematics, we're going to update each of the weights to be the result of the original weight plus some additional expression. And to understand this expression, y, well, y is what the actual output is. And hypothesis of x, the input, that's going to be what we thought the input was. And so I can replace this by saying what the actual value was minus what our estimate was. And based on the difference between the actual value and what our estimate was, we might want to change our hypothesis, change the way that we do that estimation. If the actual value and the estimate were the same thing, meaning we were correctly able to predict what category this data point belonged to, well, then actual value minus estimate, that's just going to be 0, which means this whole term on the right-hand side goes to be 0, and the weight doesn't change. Weight i, where i is like weight 1 or weight 2 or weight 0, weight i just stays at weight i. And none of the weights change if we were able to correctly predict what category the input belonged to. But if our hypothesis didn't correctly predict what category the input belonged to, well, then maybe then we need to make some changes, adjust the weights so that we're better able to predict this kind of data point in the future. And what is the way we might do that? Well, if the actual value was bigger than the estimate, then, and for now we'll go ahead and assume that these x's are positive values, then if the actual value was bigger than the estimate, well, that means we need to increase the weight in order to make it such that the output is bigger, and therefore we're more likely to get to the right actual value. And so if the actual value is bigger than the estimate, then actual value minus estimate, that'll be a positive number. And so you imagine we're just adding some positive number to the weight just to increase it ever so slightly. And likewise, the inverse case is true, that if the actual value was less than the estimate, the actual value was 0, but we estimated 1, meaning it actually was not raining, but we predicted it was going to be raining. Well, then we want to decrease the value of the weight, because then in that case, we want to try and lower the total value of computing that dot product in order to make it less likely that we would predict that it would actually be raining. So no need to get too deep into the mathematics of that, but the general idea is that every time we encounter some data point, we can adjust these weights accordingly to try and make the weights better line up with the actual data that we have access to. And you can repeat this process with data point after data point until eventually, hopefully, your algorithm converges to some set of weights that do a pretty good job of trying to figure out whether a day is going to be rainy or not raining. And just as a final point about this particular equation, this value alpha here is generally what we'll call the learning rate. It's just some parameter, some number we choose for how quickly we're actually going to be updating these weight values. So that if alpha is bigger, then we're going to update these weight values by a lot. And if alpha is smaller, then we'll update the weight values by less. And you can choose a value of alpha. Depending on the problem, different values might suit the situation better or worse than others. So after all of that, after we've done this training process of take all this data and using this learning rule, look at all the pieces of data and use each piece of data as an indication to us of do the weights stay the same, do we increase the weights, do we decrease the weights, and if so, by how much? What you end up with is effectively a threshold function. And we can look at what the threshold function looks like like this. On the x-axis here, we have the output of that function, taking the weights, taking the dot product of it with the input. And on the y-axis, we have what the output is going to be, 0, which in this case represented not raining, and 1, which in this case represented raining. And the way that our hypothesis function works is it calculates this value. And if it's greater than 0 or greater than some threshold value, then we declare that it's a rainy day. And otherwise, we declare that it's a not rainy day. And this then graphically is what that function looks like, that initially when the value of this dot product is small, it's not raining, it's not raining, it's not raining. But as soon as it crosses that threshold, we suddenly say, OK, now it's raining, now it's raining, now it's raining. And the way to interpret this kind of representation is that anything on this side of the line, that would be the category of data points where we say, yes, it's raining. Anything that falls on this side of the line are the data points where we would say, it's not raining. And again, we want to choose some value for the weights that results in a function that does a pretty good job of trying to do this estimation. But one tricky thing with this type of hard threshold is that it only leaves two possible outcomes. We plug in some data as input. And the output we get is raining or not raining. And there's no room for anywhere in between. And maybe that's what you want. Maybe all you want is given some data point, you would like to be able to classify it into one or two or more of these various different categories. But it might also be the case that you care about knowing how strong that prediction is, for example. So if we go back to this instance here, where we have rainy days on this side of the line, not rainy days on that side of the line, you might imagine that let's look now at these two white data points. This data point here that we would like to predict a label or a category for. And this data point over here that we would also like to predict a label or a category for. It seems likely that you could pretty confidently say that this data point, that should be a rainy day. Seems close to the other rainy days if we're going by the nearest neighbor strategy. It's on this side of the line if we're going by the strategy of just saying, which side of the line does it fall on by figuring out what those weights should be. And if we're using the line strategy of just which side of the line does it fall on, which side of this decision boundary, well, we'd also say that this point here is also a rainy day because it falls on the side of the line that corresponds to rainy days. But it's likely that even in this case, we would know that we don't feel nearly as confident about this data point on the left as compared to this data point on the right. That for this one on the right, we can feel very confident that yes, it's a rainy day. This one, it's pretty close to the line if we're judging just by distance. And so you might be less sure. But our threshold function doesn't allow for a notion of less sure or more sure about something. It's what we would call a hard threshold. It's once you've crossed this line, then immediately we say, yes, this is going to be a rainy day. Anywhere before it, we're going to say it's not a rainy day. And that may not be helpful in a number of cases. One, this is not a particularly easy function to deal with. As you get deeper into the world of machine learning and are trying to do things like taking derivatives of these curves with this type of function makes things challenging. But the other challenge is that we don't really have any notion of gradation between things. We don't have a notion of yes, this is a very strong belief that it's going to be raining as opposed to it's probably more likely than not that it's going to be raining, but maybe not totally sure about that either. So what we can do by taking advantage of a technique known as logistic regression is instead of using this hard threshold type of function, we can use instead a logistic function, something we might call a soft threshold. And that's going to transform this into looking something a little more like this, something that more nicely curves. And as a result, the possible output values are no longer just 0 and 1, 0 for not raining, 1 for raining. But you can actually get any real numbered value between 0 and 1. But if you're way over on this side, then you get a value of 0. OK, it's not going to be raining, and we're pretty sure about that. And if you're over on this side, you get a value of 1. And yes, we're very sure that it's going to be raining. But in between, you could get some real numbered value, where a value like 0.7 might mean we think it's going to rain. It's more probable that it's going to rain than not based on the data. But we're not as confident as some of the other data points might be. So one of the advantages of the soft threshold is that it allows us to have an output that could be some real number that potentially reflects some sort of probability, the likelihood that we think that this particular data point belongs to that particular category. And there are some other nice mathematical properties of that as well. So that then is two different approaches to trying to solve this type of classification problem. One is this nearest neighbor type of approach, where you just take a data point and look at the data points that are nearby to try and estimate what category we think it belongs to. And the other approach is the approach of saying, all right, let's just try and use linear regression, figure out what these weights should be, adjust the weights in order to figure out what line or what decision boundary is going to best separate these two categories. It turns out that another popular approach, a very popular approach if you just have a data set and you want to start trying to do some learning on it, is what we call the support vector machine. And we're not going to go too much into the mathematics of the support vector machine, but we'll at least explore it graphically to see what it is that it looks like. And the idea or the motivation behind the support vector machine is the idea that there are actually a lot of different lines that we could draw, a lot of different decision boundaries that we could draw to separate two groups. So for example, I had the red data points over here and the blue data points over here. One possible line I could draw is a line like this, that this line here would separate the red points from the blue points. And it does so perfectly. All the red points are on one side of the line. All the blue points are on the other side of the line. But this should probably make you a little bit nervous. If you come up with a model and the model comes up with a line that looks like this. And the reason why is that you worry about how well it's going to generalize to other data points that are not necessarily in the data set that we have access to. For example, if there was a point that fell like right here, for example, on the right side of the line, well, then based on that, we might want to guess that it is, in fact, a red point, but it falls on the side of the line where instead we would estimate that it's a blue point instead. And so based on that, this line is probably not a great choice just because it is so close to these various data points. We might instead prefer like a diagonal line that just goes diagonally through the data set like we've seen before. But there too, there's a lot of diagonal lines that we could draw as well. For example, I could draw this diagonal line here, which also successfully separates all the red points from all of the blue points. From the perspective of something like just trying to figure out some setting of weights that allows us to predict the correct output, this line will predict the correct output for this particular set of data every single time because the red points are on one side, the blue points are on the other. But yet again, you should probably be a little nervous because this line is so close to these red points, even though we're able to correctly predict on the input data, if there was a point that fell somewhere in this general area, our algorithm, this model, would say that, yeah, we think it's a blue point, when in actuality, it might belong to the red category instead just because it looks like it's close to the other red points. What we really want to be able to say, given this data, how can you generalize this as best as possible, is to come up with a line like this that seems like the intuitive line to draw. And the reason why it's intuitive is because it seems to be as far apart as possible from the red data and the blue data. So that if we generalize a little bit and assume that maybe we have some points that are different from the input but still slightly further away, we can still say that something on this side probably red, something on that side probably blue, and we can make those judgments that way. And that is what support vector machines are designed to do. They're designed to try and find what we call the maximum margin separator, where the maximum margin separator is just some boundary that maximizes the distance between the groups of points rather than come up with some boundary that's very close to one set or the other, where in the case before, we wouldn't have cared. As long as we're categorizing the input well, that seems all we need to do. The support vector machine will try and find this maximum margin separator, some way of trying to maximize that particular distance. And it does so by finding what we call the support vectors, which are the vectors that are closest to the line, and trying to maximize the distance between the line and those particular points. And it works that way in two dimensions. It also works in higher dimensions, where we're not looking for some line that separates the two data points, but instead looking for what we generally call a hyperplane, some decision boundary, effectively, that separates one set of data from the other set of data. And this ability of support vector machines to work in higher dimensions actually has a number of other applications as well. But one is that it helpfully deals with cases where data may not be linearly separable. So we talked about linear separability before, this idea that you can take data and just draw a line or some linear combination of the inputs that allows us to perfectly separate the two sets from each other. There are some data sets that are not linearly separable. And some were even two. You would not be able to find a good line at all that would try to do that kind of separation. Something like this, for example. Or if you imagine here are the red points and the blue points around it. If you try to find a line that divides the red points from the blue points, it's actually going to be difficult, if not impossible, to do that any line you choose, well, if you draw a line here, then you ignore all of these blue points that should actually be blue and not red. Anywhere else you draw a line, there's going to be a lot of error, a lot of mistakes, a lot of what we'll soon call loss to that line that you draw, a lot of points that you're going to categorize incorrectly. What we really want is to be able to find a better decision boundary that may not be just a straight line through this two dimensional space. And what support vector machines can do is they can begin to operate in higher dimensions and be able to find some other decision boundary, like the circle in this case, that actually is able to separate one of these sets of data from the other set of data a lot better. So oftentimes in data sets where the data is not linearly separable, support vector machines by working in higher dimensions can actually figure out a way to solve that kind of problem effectively. So that then, three different approaches to trying to solve these sorts of problems. We've seen support vector machines. We've seen trying to use linear regression and the perceptron learning rule to be able to figure out how to categorize inputs and outputs. We've seen the nearest neighbor approach. No one necessarily better than any other again. It's going to depend on the data set, the information you have access to. It's going to depend on what the function looks like that you're ultimately trying to predict. And this is where a lot of research and experimentation can be involved in trying to figure out how it is to best perform that kind of estimation. But classification is only one of the tasks that you might encounter in supervised machine learning. Because in classification, what we're trying to predict is some discrete category. We're trying to predict red or blue, rain or not rain, authentic or counterfeit. But sometimes what we want to predict is a real numbered value. And for that, we have a related problem, not classification, but instead known as regression. And regression is the supervised learning problem where we try and learn a function mapping inputs to outputs same as before. But instead of the outputs being discrete categories, things like rain or not rain, in a regression problem, the output values are generally continuous values, some real number that we would like to predict. This happens all the time as well. You might imagine that a company might take this approach if it's trying to figure out, for instance, what the effect of its advertising is. How do advertising dollars spent translate into sales for the company's product, for example? And so they might like to try to predict some function that takes as input the amount of money spent on advertising. And here, we're just going to use one input. But again, you could scale this up to many more inputs as well if you have a lot of different kinds of data you have access to. And the goal is to learn a function that given this amount of spending on advertising, we're going to get this amount in sales. And you might judge, based on having access to a whole bunch of data, like for every past month, here is how much we spent on advertising, and here is what sales were. And we would like to predict some sort of hypothesis function that, again, given the amount spent on advertising, we can predict, in this case, some real number, some number estimate of how much sales we expect that company to do in this month or in this quarter or whatever unit of time we're choosing to measure things in. And so again, the approach to solving this type of problem, we could try using a linear regression type approach where we take this data and we just plot it. On the x-axis, we have advertising dollars spent. On the y-axis, we have sales. And we might just want to try and draw a line that does a pretty good job of trying to estimate this relationship between advertising and sales. And in this case, unlike before, we're not trying to separate the data points into discrete categories. But instead, in this case, we're just trying to find a line that approximates this relationship between advertising and sales so that if we want to figure out what the estimated sales are for a particular advertising budget, you just look it up in this line, figure out for this amount of advertising, we would have this amount of sales and just try and make the estimate that way. And so you can try and come up with a line, again, figuring out how to modify the weights using various different techniques to try and make it so that this line fits as well as possible. So with all of these approaches, then, to trying to solve machine learning style problems, the question becomes, how do we evaluate these approaches? How do we evaluate the various different hypotheses that we could come up with? Because each of these algorithms will give us some sort of hypothesis, some function that maps inputs to outputs, and we want to know, how well does that function work? And you can think of evaluating these hypotheses and trying to get a better hypothesis as kind of like an optimization problem. In an optimization problem, as you recall from before, we were either trying to maximize some objective function by trying to find a global maximum, or we were trying to minimize some cost function by trying to find some global minimum. And in the case of evaluating these hypotheses, one thing we might say is that this cost function, the thing we're trying to minimize, we might be trying to minimize what we would call a loss function. And what a loss function is, is it is a function that is going to estimate for us how poorly our function performs. More formally, it's like a loss of utility by whenever we predict something that is wrong, that is a loss of utility. That's going to add to the output of our loss function. And you could come up with any loss function that you want, just some mathematical way of estimating, given each of these data points, given what the actual output is, and given what our projected output is, our estimate, you could calculate some sort of numerical loss for it. But there are a couple of popular loss functions that are worth discussing, just so that you've seen them before. When it comes to discrete categories, things like rain or not rain, counterfeit or not counterfeit, one approaches the 0, 1 loss function. And the way that works is for each of the data points, our loss function takes as input what the actual output is, like whether it was actually raining or not raining, and takes our prediction into account. Did we predict, given this data point, that it was raining or not raining? And if the actual value equals the prediction, well, then the 0, 1 loss function will just say the loss is 0. There was no loss of utility, because we were able to predict correctly. And otherwise, if the actual value was not the same thing as what we predicted, well, then in that case, our loss is 1. We lost something, lost some utility, because what we predicted was the output of the function, was not what it actually was. And the goal, then, in a situation like this would be to come up with some hypothesis that minimizes the total empirical loss, the total amount that we've lost, if you add up for all these data points what the actual output is and what your hypothesis would have predicted. So in this case, for example, if we go back to classifying days as raining or not raining, and we came up with this decision boundary, how would we evaluate this decision boundary? How much better is it than drawing the line here or drawing the line there? Well, we could take each of the input data points, and each input data point has a label, whether it was raining or whether it was not raining. And we could compare it to the prediction, whether we predicted it would be raining or not raining, and assign it a numerical value as a result. So for example, these points over here, they were all rainy days, and we predicted they would be raining, because they fall on the bottom side of the line. So they have a loss of 0, nothing lost from those situations. And likewise, same is true for some of these points over here, where it was not raining and we predicted it would not be raining either. Where we do have loss are points like this point here and that point there, where we predicted that it would not be raining, but in actuality, it's a blue point. It was raining. Or likewise here, we predicted that it would be raining, but in actuality, it's a red point. It was not raining. And so as a result, we miscategorized these data points that we were trying to train on. And as a result, there is some loss here. One loss here, there, here, and there, for a total loss of 4, for example, in this case. And that might be how we would estimate or how we would say that this line is better than a line that goes somewhere else or a line that's further down, because this line might minimize the loss. So there is no way to do better than just these four points of loss if you're just drawing a straight line through our space. So the 0, 1 loss function checks. Did we get it right? Did we get it wrong? If we got it right, the loss is 0, nothing lost. If we got it wrong, then our loss function for that data point says 1. And we add up all of those losses across all of our data points to get some sort of empirical loss, how much we have lost across all of these original data points that our algorithm had access to. There are other forms of loss as well that work especially well when we deal with more real valued cases, cases like the mapping between advertising budget and amount that we do in sales, for example. Because in that case, you care not just that you get the number exactly right, but you care how close you were to the actual value. If the actual value is you did like $2,800 in sales and you predicted that you would do $2,900 in sales, maybe that's pretty good. That's much better than if you had predicted you'd do $1,000 in sales, for example. And so we would like our loss function to be able to take that into account as well, take into account not just whether the actual value and the expected value are exactly the same, but also take into account how far apart they were. And so for that one approach is what we call L1 loss. L1 loss doesn't just look at whether actual and predicted are equal to each other, but we take the absolute value of the actual value minus the predicted value. In other words, we just ask how far apart were the actual and predicted values, and we sum that up across all of the data points to be able to get what our answer ultimately is. So what might this actually look like for our data set? Well, if we go back to this representation where we had advertising along the x-axis, sales along the y-axis, our line was our prediction, our estimate for any given amount of advertising, what we predicted sales was going to be. And our L1 loss is just how far apart vertically along the sales axis our prediction was from each of the data points. So we could figure out exactly how far apart our prediction was from each of the data points and figure out as a result of that what our loss is overall for this particular hypothesis just by adding up all of these various different individual losses for each of these data points. And our goal then is to try and minimize that loss, to try and come up with some line that minimizes what the utility loss is by judging how far away our estimate amount of sales is from the actual amount of sales. And turns out there are other loss functions as well. One that's quite popular is the L2 loss. The L2 loss, instead of just using the absolute value, like how far away the actual value is from the predicted value, it uses the square of actual minus predicted. So how far apart are the actual and predicted value? And it squares that value, effectively penalizing much more harshly anything that is a worse prediction. So you imagine if you have two data points that you predict as being one value away from their actual value, as opposed to one data point that you predict as being two away from its actual value, the L2 loss function will more harshly penalize that one that is two away, because it's going to square, however, much the differences between the actual value and the predicted value. And depending on the situation, you might want to choose a loss function depending on what you care about minimizing. If you really care about minimizing the error on more outlier cases, then you might want to consider something like this. But if you've got a lot of outliers, and you don't necessarily care about modeling them, then maybe an L1 loss function is preferable. But there are trade-offs here that you need to decide, based on a particular set of data. But what you do run the risk of with any of these loss functions, with anything that we're trying to do, is a problem known as overfitting. And overfitting is a big problem that you can encounter in machine learning, which happens anytime a model fits too closely with a data set, and as a result, fails to generalize. We would like our model to be able to accurately predict data and inputs and output pairs for the data that we have access to. But the reason we wanted to do so is because we want our model to generalize well to data that we haven't seen before. I would like to take data from the past year of whether it was raining or not raining, and use that data to generalize it towards the future. Say, in the future, is it going to be raining or not raining? Or if I have a whole bunch of data on what counterfeit and not counterfeit US dollar bills look like in the past when people have encountered them, I'd like to train a computer to be able to, in the future, generalize to other dollar bills that I might see as well. And the problem with overfitting is that if you try and tie yourself too closely to the data set that you're training your model on, you can end up not generalizing very well. So what does this look like? Well, we might imagine the rainy day and not rainy day example again from here, where the blue points indicate rainy days and the red points indicate not rainy days. And we decided that we felt pretty comfortable with drawing a line like this as the decision boundary between rainy days and not rainy days. So we can pretty comfortably say that points on this side more likely to be rainy days, points on that side more likely to be not rainy days. But the loss, the empirical loss, isn't zero in this particular case because we didn't categorize everything perfectly. There was this one outlier, this one day that it wasn't raining, but yet our model still predicts that it is raining. But that doesn't necessarily mean our model is bad. It just means the model isn't 100% accurate. If you really wanted to try and find a hypothesis that resulted in minimizing the loss, you could come up with a different decision boundary. It wouldn't be a line, but it would look something like this. This decision boundary does separate all of the red points from all of the blue points because the red points fall on this side of this decision boundary, the blue points fall on the other side of the decision boundary. But this, we would probably argue, is not as good of a prediction. Even though it seems to be more accurate based on all of the available training data that we have for training this machine learning model, we might say that it's probably not going to generalize well. That if there were other data points like here and there, we might still want to consider those to be rainy days because we think this was probably just an outlier. So if the only thing you care about is minimizing the loss on the data you have available to you, you run the risk of overfitting. And this can happen in the classification case. It can also happen in the regression case, that here we predicted what we thought was a pretty good line relating advertising to sales, trying to predict what sales were going to be for a given amount of advertising. But I could come up with a line that does a better job of predicting the training data, and it would be something that looks like this, just connecting all of the various different data points. And now there is no loss at all. Now I've perfectly predicted, given any advertising, what sales are. And for all the data available to me, it's going to be accurate. But it's probably not going to generalize very well. I have overfit my model on the training data that is available to me. And so in general, we want to avoid overfitting. We'd like strategies to make sure that we haven't overfit our model to a particular data set. And there are a number of ways that you could try to do this. One way is by examining what it is that we're optimizing for. In an optimization problem, all we do is we say, there is some cost, and I want to minimize that cost. And so far, we've defined that cost function, the cost of a hypothesis, just as being equal to the empirical loss of that hypothesis, like how far away are the actual data points, the outputs, away from what I predicted them to be based on that particular hypothesis. And if all you're trying to do is minimize cost, meaning minimizing the loss in this case, then the result is going to be that you might overfit, that to minimize cost, you're going to try and find a way to perfectly match all the input data. And that might happen as a result of overfitting on that particular input data. So in order to address this, you could add something to the cost function. What counts as cost will not just loss, but also some measure of the complexity of the hypothesis. The word the complexity of the hypothesis is something that you would need to define for how complicated does our line look. This is sort of an Occam's razor-style approach where we want to give preference to a simpler decision boundary, like a straight line, for example, some simpler curve, as opposed to something far more complex that might represent the training data better but might not generalize as well. We'll generally say that a simpler solution is probably the better solution and probably the one that is more likely to generalize well to other inputs. So we measure what the loss is, but we also measure the complexity. And now that all gets taken into account when we consider the overall cost, that yes, something might have less loss if it better predicts the training data, but if it's much more complex, it still might not be the best option that we have. And we need to come up with some balance between loss and complexity. And for that reason, you'll often see this represented as multiplying the complexity by some parameter that we have to choose, parameter lambda in this case, where we're saying if lambda is a greater value, then we really want to penalize more complex hypotheses. Whereas if lambda is smaller, we're going to penalize more complex hypotheses a little bit, and it's up to the machine learning programmer to decide where they want to set that value of lambda for how much do I want to penalize a more complex hypothesis that might fit the data a little better. And again, there's no one right answer to a lot of these things, but depending on the data set, depending on the data you have available to you and the problem you're trying to solve, your choice of these parameters may vary, and you may need to experiment a little bit to figure out what the right choice of that is ultimately going to be. This process, then, of considering not only loss, but also some measure of the complexity is known as regularization. Regularization is the process of penalizing a hypothesis that is more complex in order to favor a simpler hypothesis that is more likely to generalize well, more likely to be able to apply to other situations that are dealing with other input points unlike the ones that we've necessarily seen before. So oftentimes, you'll see us add some regularizing term to what we're trying to minimize in order to avoid this problem of overfitting. Now, another way of making sure we don't overfit is to run some experiments and to see whether or not we are able to generalize our model that we've created to other data sets as well. And it's for that reason that oftentimes when you're doing a machine learning experiment, when you've got some data and you want to try and come up with some function that predicts, given some input, what the output is going to be, you don't necessarily want to do your training on all of the data you have available to you that you could employ a method known as holdout cross-validation, where in holdout cross-validation, we split up our data. We split up our data into a training set and a testing set. The training set is the set of data that we're going to use to train our machine learning model. And the testing set is the set of data that we're going to use in order to test to see how well our machine learning model actually performed. So the learning happens on the training set. We figure out what the parameters should be. We figure out what the right model is. And then we see, all right, now that we've trained the model, we'll see how well it does at predicting things inside of the testing set, some set of data that we haven't seen before. And the hope then is that we're going to be able to predict the testing set pretty well if we're able to generalize based on the training data that's available to us. If we've overfit the training data, though, and we're not able to generalize, well, then when we look at the testing set, it's likely going to be the case that we're not going to predict things in the testing set nearly as effectively. So this is one method of cross-validation, validating to make sure that the work we have done is actually going to generalize to other data sets as well. And there are other statistical techniques we can use as well. One of the downsides of this just hold out cross-validation is if you say I just split it 50-50, I train using 50% of the data and test using the other 50%, or you could choose other percentages as well, is that there is a fair amount of data that I am now not using to train, that I might be able to get a better model as a result, for example. So one approach is known as k-fold cross-validation. In k-fold cross-validation, rather than just divide things into two sets and run one experiment, we divide things into k different sets. So maybe I divide things up into 10 different sets and then run 10 different experiments. So if I split up my data into 10 different sets of data, then what I'll do is each time for each of my 10 experiments, I will hold out one of those sets of data, where I'll say, let me train my model on these nine sets, and then test to see how well it predicts on set number 10. And then pick another set of nine sets to train on, and then test it on the other one that I held out, where each time I train the model on everything minus the one set that I'm holding out, and then test to see how well our model performs on the test that I did hold out. And what you end up getting is 10 different results, 10 different answers for how accurately our model worked. And oftentimes, you could just take the average of those 10 to get an approximation for how well we think our model performs overall. But the key idea is separating the training data from the testing data, because you want to test your model on data that is different from what you trained the model on. Because the training, you want to avoid overfitting. You want to be able to generalize. And the way you test whether you're able to generalize is by looking at some data that you haven't seen before and seeing how well we're actually able to perform. And so if we want to actually implement any of these techniques inside of a programming language like Python, number of ways we could do that. We could write this from scratch on our own, but there are libraries out there that allow us to take advantage of existing implementations of these algorithms, that we can use the same types of algorithms in a lot of different situations. And so there's a library, very popular one, known as Scikit-learn, which allows us in Python to be able to very quickly get set up with a lot of these different machine learning models. This library has already written an algorithm for nearest neighbor classification, for doing perceptron learning, for doing a bunch of other types of inference and supervised learning that we haven't yet talked about. But using it, we can begin to try actually testing how these methods work and how accurately they perform. So let's go ahead and take a look at one approach to trying to solve this type of problem. All right, so I'm first going to pull up banknotes.csv, which is a whole bunch of data provided by UC Irvine, which is information about various different banknotes that people took pictures of various different banknotes and measured various different properties of those banknotes. And in particular, some human categorized each of those banknotes as either a counterfeit banknote or as not counterfeit. And so what you're looking at here is each row represents one banknote. This is formatted as a CSV spreadsheet, where just comma separated values separating each of these various different fields. We have four different input values for each of these data points, just information, some measurement that was made on the banknote. And what those measurements exactly are aren't as important as the fact that we do have access to this data. But more importantly, we have access for each of these data points to a label, where 0 indicates something like this was not a counterfeit bill, meaning it was an authentic bill. And a data point labeled 1 means that it is a counterfeit bill, at least according to the human researcher who labeled this particular data. So we have a whole bunch of data representing a whole bunch of different data points, each of which has these various different measurements that were made on that particular bill, and each of which has an output value, 0 or 1, 0 meaning it was a genuine bill, 1 meaning it was a counterfeit bill. And what we would like to do is use supervised learning to begin to predict or model some sort of function that can take these four values as input and predict what the output would be. We want our learning algorithm to find some sort of pattern that is able to predict based on these measurements, something that you could measure just by taking a photo of a bill, predict whether that bill is authentic or whether that bill is counterfeit. And so how can we do that? Well, I'm first going to open up banknote0.py and see how it is that we do this. I'm first importing a lot of things from Scikit-learn, but importantly, I'm going to set my model equal to the perceptron model, which is one of those models that we talked about before. We're just going to try and figure out some setting of weights that is able to divide our data into two different groups. Then I'm going to go ahead and read data in for my file from banknotes.csv. And basically, for every row, I'm going to separate that row into the first four values of that row, which is the evidence for that row. And then the label, where if the final column in that row is a 0, the label is authentic. And otherwise, it's going to be counterfeit. So I'm effectively reading data in from the CSV file, dividing into a whole bunch of rows where each row has some evidence, those four input values that are going to be inputs to my hypothesis function. And then the label, the output, whether it is authentic or counterfeit, that is the thing that I am then trying to predict. So the next step is that I would like to split up my data set into a training set and a testing set, some set of data that I would like to train my machine learning model on, and some set of data that I would like to use to test that model, see how well it performed. So what I'll do is I'll go ahead and figure out length of the data, how many data points do I have. I'll go ahead and take half of them, save that number as a number called holdout. That is how many items I'm going to hold out for my data set to save for the testing phase. I'll randomly shuffle the data so it's in some random order. And then I'll say my testing set will be all of the data up to the holdout. So I'll take holdout many data items, and that will be my testing set. My training data will be everything else, the information that I'm going to train my model on. And then I'll say I need to divide my training data into two different sets. I need to divide it into my x values, where x here represents the inputs. So the x values, the x values that I'm going to train on, are basically for every row in my training set, I'm going to get the evidence for that row, those four values, where it's basically a vector of four numbers, where that is going to be all of the input. And then I need the y values. What are the outputs that I want to learn from, the labels that belong to each of these various different input points? Well, that's going to be the same thing for each row in the training data. But this time, I take that row and get what its label is, whether it is authentic or counterfeit. So I end up with one list of all of these vectors of my input data, and one list, which follows the same order, but is all of the labels that correspond with each of those vectors. And then to train my model, which in this case is just this perceptron model, I just call model.fit, pass in the training data, and what the labels for those training data are. And scikit-learn will take care of fitting the model, will do the entire algorithm for me. And then when it's done, I can then test to see how well that model performed. So I can say, let me get all of these input vectors for what I want to test on. So for each row in my testing data set, go ahead and get the evidence. And the y values, those are what the actual values were for each of the rows in the testing data set, what the actual label is. But then I'm going to generate some predictions. I'm going to use this model and try and predict, based on the testing vectors, I want to predict what the output is. And my goal then is to now compare y testing with predictions. I want to see how well my predictions, based on the model, actually reflect what the y values were, what the output is, that were actually labeled. Because I now have this label data, I can assess how well the algorithm worked. And so now I can just compute how well we did. I'm going to, this zip function basically just lets me look through two different lists, one by one at the same time. So for each actual value and for each predicted value, if the actual is the same thing as what I predicted, I'll go ahead and increment the counter by one. Otherwise, I'll increment my incorrect counter by one. And so at the end, I can print out, here are the results, here's how many I got right, here's how many I got wrong, and here was my overall accuracy, for example. So I can go ahead and run this. I can run python banknote0.py. And it's going to train on half the data set and then test on half the data set. And here are the results for my perceptron model. In this case, it correctly was able to classify 679 bills as correctly either authentic or counterfeit and incorrectly classified seven of them for an overall accuracy of close to 99% accurate. So on this particular data set, using this perceptron model, we were able to predict very well what the output was going to be. And we can try different models, too, that scikit-learn makes it very easy just to swap out one model for another model. So instead of the perceptron model, I can use the support vector machine using the SVC, otherwise known as a support vector classifier, using a support vector machine to classify things into two different groups. And now see, all right, how well does this perform? And all right, this time, we were able to correctly predict 682 and incorrectly predicted four for accuracy of 99.4%. And we could even try the k-neighbors classifier as the model instead. And this takes a parameter, n neighbors, for how many neighbors do you want to look at? Let's just look at one neighbor, the one nearest neighbor, and use that to predict. Go ahead and run this as well. And it looks like, based on the k-neighbors classifier, looking at just one neighbor, we were able to correctly classify 685 data points, incorrectly classified one. Maybe let's try three neighbors instead, instead of just using one neighbor. Do more of a k-nearest neighbors approach, where I look at the three nearest neighbors and see how that performs. And that one, in this case, seems to have gotten 100% of all of the predictions correctly described as either authentic banknotes or as counterfeit banknotes. And we could run these experiments multiple times, because I'm randomly reorganizing the data every time. We're technically training these on slightly different data sets. And so you might want to run multiple experiments to really see how well they're actually going to perform. But in short, they all perform very well. And while some of them perform slightly better than others here, that might not always be the case for every data set. But you can begin to test now by very quickly putting together these machine learning models using Scikit-learn to be able to train on some training set and then test on some testing set as well. And this splitting up into training groups and testing groups and testing happens so often that Scikit-learn has functions built in for trying to do it. I did it all by hand just now. But if we take a look at banknotes one, we take advantage of some other features that exist in Scikit-learn, where we can really simplify a lot of our logic, that there is a function built into Scikit-learn called train test split, which will automatically split data into a training group and a testing group. I just have to say what proportion should be in the testing group, something like 0.5, half the data inside the testing group. Then I can fit the model on the training data, make the predictions on the testing data, and then just count up. And Scikit-learn has some nice methods for just counting up how many times our testing data match the predictions, how many times our testing data didn't match the predictions. So very quickly, you can write programs with not all that many lines of code. It's maybe like 40 lines of code to get through all of these predictions. And then as a result, see how well we're able to do. So these types of libraries can allow us, without really knowing the implementation details of these algorithms, to be able to use the algorithms in a very practical way to be able to solve these types of problems. So that then was supervised learning, this task of given a whole set of data, some input output pairs, we would like to learn some function that maps those inputs to those outputs. But turns out there are other forms of learning as well. And another popular type of machine learning, especially nowadays, is known as reinforcement learning. And the idea of reinforcement learning is rather than just being given a whole data set at the beginning of input output pairs, reinforcement learning is all about learning from experience. In reinforcement learning, our agent, whether it's like a physical robot that's trying to make actions in the world or just some virtual agent that is a program running somewhere, our agent is going to be given a set of rewards or punishments in the form of numerical values. But you can think of them as reward or punishment. And based on that, it learns what actions to take in the future, that our agent, our AI, will be put in some sort of environment. It will make some actions. And based on the actions that it makes, it learns something. It either gets a reward when it does something well, it gets a punishment when it does something poorly, and it learns what to do or what not to do in the future based on those individual experiences. And so what this will often look like is it will often start with some agent, some AI, which might, again, be a physical robot, if you're imagining a physical robot moving around, but it can also just be a program. And our agent is situated in their environment, where the environment is where they're going to make their actions, and it's what's going to give them rewards or punishments for various actions that they're in. So for example, the environment is going to start off by putting our agent inside of a state. Our agent has some state that, in a game, might be the state of the game that the agent is playing. In a world that the agent is exploring might be some position inside of a grid representing the world that they're exploring. But the agent is in some sort of state. And in that state, the agent needs to choose to take an action. The agent likely has multiple actions they can choose from, but they pick an action. So they take an action in a particular state. And as a result of that, the agent will generally get two things in response as we model them. The agent gets a new state that they find themselves in. After being in this state, taking one action, they end up in some other state. And they're also given some sort of numerical reward, positive meaning reward, meaning it was a good thing, negative generally meaning they did something bad, they received some sort of punishment. And that is all the information the agent has. It's told what state it's in. It makes some sort of action. And based on that, it ends up in another state. And it ends up getting some particular reward. And it needs to learn, based on that information, what actions to begin to take in the future. And so you could imagine generalizing this to a lot of different situations. This is oftentimes how you train if you've ever seen those robots that are now able to walk around the way humans do. It would be quite difficult to program the robot in exactly the right way to get it to walk the way humans do. You could instead train it through reinforcement learning, give it some sort of numerical reward every time it does something good, like take steps forward, and punish it every time it does something bad, like fall over, and then let the AI just learn based on that sequence of rewards, based on trying to take various different actions. You can begin to have the agent learn what to do in the future and what not to do. So in order to begin to formalize this, the first thing we need to do is formalize this notion of what we mean about states and actions and rewards, like what does this world look like? And oftentimes, we'll formulate this world as what's known as a Markov decision process, similar in spirit to Markov chains, which you might recall from before. But a Markov decision process is a model that we can use for decision making, for an agent trying to make decisions in its environment. And it's a model that allows us to represent the various different states that an agent can be in, the various different actions that they can take, and also what the reward is for taking one action as opposed to another action. So what then does it actually look like? Well, if you recall a Markov chain from before, a Markov chain looked a little something like this, where we had a whole bunch of these individual states, and each state immediately transitioned to another state based on some probability distribution. We saw this in the context of the weather before, where if it was sunny, we said with some probability, it'll be sunny the next day. With some other probability, it'll be rainy, for example. But we could also imagine generalizing this. It's not just sun and rain anymore. We just have these states, where one state leads to another state according to some probability distribution. But in this original model, there was no agent that had any control over this process. It was just entirely probability based, where with some probability, we moved to this next state. But maybe it's going to be some other state with some other probability. What we'll now have is the ability for the agent in this state to choose from a set of actions, where maybe instead of just one path forward, they have three different choices of actions that each lead up down different paths. And even this is a bit of an oversimplification, because in each of these states, you might imagine more branching points where there are more decisions that can be taken as well. So we've extended the Markov chain to say that from a state, you now have available action choices. And each of those actions might be associated with its own probability distribution of going to various different states. Then in addition, we'll add another extension, where any time you move from a state, taking an action, going into this other state, we can associate a reward with that outcome, saying either r is positive, meaning some positive reward, or r is negative, meaning there was some sort of punishment. And this then is what we'll consider to be a Markov decision process. That a Markov decision process has some initial set of states, of states in the world that we can be in. We have some set of actions that, given a state, I can say, what are the actions that are available to me in that state, an action that I can choose from? Then we have some transition model. The transition model before just said that, given my current state, what is the probability that I end up in that next state or this other state? The transition model now has effectively two things we're conditioning on. We're saying, given that I'm in this state and that I take this action, what's the probability that I end up in this next state? Now maybe we live in a very deterministic world in this Markov decision process. We're given a state and given an action. We know for sure what next state we'll end up in. But maybe there's some randomness in the world that when you take in a state and you take an action, you might not always end up in the exact same state. There might be some probabilities involved there as well. The Markov decision process can handle both of those possible cases. And then finally, we have a reward function, generally called r, that in this case says, what is the reward for being in this state, taking this action, and then getting to s prime this next state? So I'm in this original state. I take this action. I get to this next state. What is the reward for doing that process? And you can add up these rewards every time you take an action to get the total amount of rewards that an agent might get from interacting in a particular environment modeled using this Markov decision process. So what might this actually look like in practice? Well, let's just create a little simulated world here where I have this agent that is just trying to navigate its way. This agent is this yellow dot here, like a robot in the world, trying to navigate its way through this grid. And ultimately, it's trying to find its way to the goal. And if it gets to the green goal, then it's going to get some sort of reward. But then we might also have some red squares that are places where you get some sort of punishment, some bad place where we don't want the agent to go. And if it ends up in the red square, then our agent is going to get some sort of punishment as a result of that. But the agent originally doesn't know all of these details. It doesn't know that these states are associated with punishments. But maybe it does know that this state is associated with a reward. Maybe it doesn't. But it just needs to sort of interact with the environment to try and figure out what to do and what not to do. So the first thing the agent might do is, given no additional information, if it doesn't know what the punishments are, it doesn't know where the rewards are, it just might try and take an action. And it takes an action and ends up realizing that it got some sort of punishment. And so what does it learn from that experience? Well, it might learn that when you're in this state in the future, don't take the action move to the right, that that is a bad action to take. That in the future, if you ever find yourself back in the state, don't take this action of going to the right when you're in this particular state, because that leads to punishment. That might be the intuition at least. And so you could try doing other actions. You move up, all right, that didn't lead to any immediate rewards. Maybe try something else. Then maybe try something else. And all right, now you found that you got another punishment. And so you learn something from that experience. So the next time you do this whole process, you know that if you ever end up in this square, you shouldn't take the down action, because being in this state and taking that action ultimately leads to some sort of punishment, a negative reward, in other words. And this process repeats. You might imagine just letting our agent explore the world, learning over time what states tend to correspond with poor actions, learning over time what states correspond with poor actions, until eventually, if it tries enough things randomly, it might find that eventually when you get to this state, if you take the up action in this state, it might find that you actually get a reward from that. And what it can learn from that is that if you're in this state, you should take the up action, because that leads to a reward. And over time, you can also learn that if you're in this state, you should take the left action, because that leads to this state that also lets you eventually get to the reward. So you begin to learn over time not only which actions are good in particular states, but also which actions are bad, such that once you know some sequence of good actions that leads you to some sort of reward, our agent can just follow those instructions, follow the experience that it has learned. We didn't tell the agent what the goal was. We didn't tell the agent where the punishments were. But the agent can begin to learn from this experience and learn to begin to perform these sorts of tasks better in the future. And so let's now try to formalize this idea, formalize the idea that we would like to be able to learn in this state taking this action, is that a good thing or a bad thing? There are lots of different models for reinforcement learning. We're just going to look at one of them today. And the one that we're going to look at is a method known as Q-learning. And what Q-learning is all about is about learning a function, a function Q, that takes inputs S and A, where S is a state and A is an action that you take in that state. And what this Q function is going to do is it is going to estimate the value. How much reward will I get from taking this action in this state? Originally, we don't know what this Q function should be. But over time, based on experience, based on trying things out and seeing what the result is, I would like to try and learn what Q of SA is for any particular state and any particular action that I might take in that state. So what is the approach? Well, the approach originally is we'll start with Q SA equal to 0 for all states S and for all actions A. That initially, before I've ever started anything, before I've had any experiences, I don't know the value of taking any action in any given state. So I'm going to assume that the value is just 0 all across the board. But then as I interact with the world, as I experience rewards or punishments, or maybe I go to a cell where I don't get either reward or a punishment, I want to somehow update my estimate of Q SA. I want to continually update my estimate of Q SA based on the experiences and rewards and punishments that I've received, such that in the future, my knowledge of what actions are good and what states will be better. So when we take an action and receive some sort of reward, I want to estimate the new value of Q SA. And I estimate that based on a couple of different things. I estimate it based on the reward that I'm getting from taking this action and getting into the next state. But assuming the situation isn't over, assuming there are still future actions that I might take as well, I also need to take into account the expected future rewards. That if you imagine an agent interacting with the environment, then sometimes you'll take an action and get a reward, but then you can keep taking more actions and get more rewards, that these both are relevant, both the current reward I'm getting from this current step and also my future reward. And it might be the case that I'll want to take a step that doesn't immediately lead to a reward, because later on down the line, I know it will lead to more rewards as well. So there's a balancing act between current rewards that the agent experiences and future rewards that the agent experiences as well. And then we need to update QSA. So we estimate the value of QSA based on the current reward and the expected future rewards. And then we need to update this Q function to take into account this new estimate. Now, we already, as we go through this process, we'll already have an estimate for what we think the value is. Now we have a new estimate, and then somehow we need to combine these two estimates together, and we'll look at more formal ways that we can actually begin to do that. So to actually show you what this formula looks like, here is the approach we'll take with Q learning. We're going to, again, start with Q of S and A being equal to 0 for all states. And then every time we take an action A in state S and observer reward R, we're going to update our value, our estimate, for Q of SA. And the idea is that we're going to figure out what the new value estimate is minus what our existing value estimate is. And so we have some preconceived notion for what the value is for taking this action in this state. Maybe our expectation is we currently think the value is 10. But then we're going to estimate what we now think it's going to be. Maybe the new value estimate is something like 20. So there's a delta of 10 that our new value estimate is 10 points higher than what our current value estimate happens to be. And so we have a couple of options here. We need to decide how much we want to adjust our current expectation of what the value is of taking this action in this particular state. And what that difference is, how much we add or subtract from our existing notion of how much do we expect the value to be, is dependent on this parameter alpha, also called a learning rate. And alpha represents, in effect, how much we value new information compared to how much we value old information. An alpha value of 1 means we really value new information. But if we have a new estimate, then it doesn't matter what our old estimate is. We're only going to consider our new estimate because we always just want to take into consideration our new information. So the way that works is that if you imagine alpha being 1, well, then we're taking the old value of QSA and then adding 1 times the new value minus the old value. And that just leaves us with the new value. So when alpha is 1, all we take into consideration is what our new estimate happens to be. But over time, as we go through a lot of experiences, we already have some existing information. We might have tried taking this action nine times already. And now we just tried it a 10th time. And we don't only want to consider this 10th experience. I also want to consider the fact that my prior nine experiences, those were meaningful, too. And that's data I don't necessarily want to lose. And so this alpha controls that decision, controls how important is the new information. 0 would mean ignore all the new information. Just keep this Q value the same. 1 means replace the old information entirely with the new information. And somewhere in between, keep some sort of balance between these two values. We can put this equation a little bit more formally as well. The old value estimate is our old estimate for what the value is of taking this action in a particular state. That's just Q of SNA. So we have it once here, and we're going to add something to it. We're going to add alpha times the new value estimate minus the old value estimate. But the old value estimate, we just look up by calling this Q function. And what then is the new value estimate? Based on this experience we have just taken, what is our new estimate for the value of taking this action in this particular state? Well, it's going to be composed of two parts. It's going to be composed of what reward did I just get from taking this action in this state. And then it's going to be, what can I expect my future rewards to be from this point forward? So it's going to be R, some reward I'm getting right now, plus whatever I estimate I'm going to get in the future. And how do I estimate what I'm going to get in the future? Well, it's a bit of another call to this Q function. It's going to be take the maximum across all possible actions I could take next and say, all right, of all of these possible actions I could take, which one is going to have the highest reward? And so this then looks a little bit complicated. This is going to be our notion for how we're going to perform this kind of update. I have some estimate, some old estimate, for what the value is of taking this action in this state. And I'm going to update it based on new information that I experience some reward. I predict what my future reward is going to be. And using that I update what I estimate the reward will be for taking this action in this particular state. And there are other additions you might make to this algorithm as well. Sometimes it might not be the case that future rewards you want to wait equally to current rewards. Maybe you want an agent that values reward now over reward later. And so sometimes you can even add another term in here, some other parameter, where you discount future rewards and say future rewards are not as valuable as rewards immediately. That getting reward in the current time step is better than waiting a year and getting rewards later. But that's something up to the programmer to decide what that parameter ought to be. But the big picture idea of this entire formula is to say that every time we experience some new reward, we take that into account. We update our estimate of how good is this action. And then in the future, we can make decisions based on that algorithm. Once we have some good estimate for every state and for every action, what the value is of taking that action, then we can do something like implement a greedy decision making policy. That if I am in a state and I want to know what action should I take in that state, well, then I consider for all of my possible actions, what is the value of QSA? What is my estimated value of taking that action in that state? And I will just pick the action that has the highest value after I evaluate that expression. So I pick the action that has the highest value. And based on that, that tells me what action I should take. At any given state that I'm in, I can just greedily say across all my actions, this action gives me the highest expected value. And so I'll go ahead and choose that action as the action that I take as well. But there is a downside to this kind of approach. And then downside comes up in a situation like this, where we know that there is some solution that gets me to the reward. And our agent has been able to figure that out. But it might not necessarily be the best way or the fastest way. If the agent is allowed to explore a little bit more, it might find that it can get the reward faster by taking some other route instead, by going through this particular path that is a faster way to get to that ultimate goal. And maybe we would like for the agent to be able to figure that out as well. But if the agent always takes the actions that it knows to be best, well, when it gets to this particular square, it doesn't know that this is a good action because it's never really tried it. But it knows that going down eventually leads its way to this reward. So it might learn in the future that it should just always take this route and it's never going to explore and go along that route instead. So in reinforcement learning, there is this tension between exploration and exploitation. And exploitation generally refers to using knowledge that the AI already has. The AI already knows that this is a move that leads to reward. So we'll go ahead and use that move. And exploration is all about exploring other actions that we may not have explored as thoroughly before because maybe one of these actions, even if I don't know anything about it, might lead to better rewards faster or to more rewards in the future. And so an agent that only ever exploits information and never explores might be able to get reward, but it might not maximize its rewards because it doesn't know what other possibilities are out there, possibilities that we only know about by taking advantage of exploration. And so how can we try and address this? Well, one possible solution is known as the Epsilon greedy algorithm, where we set Epsilon equal to how often we want to just make a random move, where occasionally we will just make a random move in order to say, let's try to explore and see what happens. And then the logic of the algorithm will be with probability 1 minus Epsilon, choose the estimated best move. In a greedy case, we'd always choose the best move. But in Epsilon greedy, we're most of the time going to choose the best move or sometimes going to choose the best move. But sometimes with probability Epsilon, we're going to choose a random move instead. So every time we're faced with the ability to take an action, sometimes we're going to choose the best move. Sometimes we're just going to choose a random move. So this type of algorithm can be quite powerful in a reinforcement learning context by not always just choosing the best possible move right now, but sometimes, especially early on, allowing yourself to make random moves that allow you to explore various different possible states and actions more, and maybe over time, you might decrease your value of Epsilon. More and more often, choosing the best move after you're more confident that you've explored what all of the possibilities actually are. So we can put this into practice. And one very common application of reinforcement learning is in game playing, that if you want to teach an agent how to play a game, you just let the agent play the game a whole bunch. And then the reward signal happens at the end of the game. When the game is over, if our AI won the game, it gets a reward of like 1, for example. And if it lost the game, it gets a reward of negative 1. And from that, it begins to learn what actions are good and what actions are bad. You don't have to tell the AI what's good and what's bad, but the AI figures it out based on that reward. Winning the game is some signal, losing the game is some signal, and based on all of that, it begins to figure out what decisions it should actually make. So one very simple game, which you may have played before, is a game called Nim. And in the game of Nim, you've got a whole bunch of objects in a whole bunch of different piles, where here I've represented each pile as an individual row. So you've got one object in the first pile, three in the second pile, five in the third pile, seven in the fourth pile. And the game of Nim is a two player game where players take turns removing objects from piles. And the rule is that on any given turn, you were allowed to remove as many objects as you want from any one of these piles, any one of these rows. You have to remove at least one object, but you remove as many as you want from exactly one of the piles. And whoever takes the last object loses. So player one might remove four from this pile here. Player two might remove four from this pile here. So now we've got four piles left, one, three, one, and three. Player one might remove the entirety of the second pile. Player two, if they're being strategic, might remove two from the third pile. Now we've got three piles left, each with one object left. Player one might remove one from one pile. Player two removes one from the other pile. And now player one is left with choosing this one object from the last pile, at which point player one loses the game. So fairly simple game. Piles of objects, any turn you choose how many objects to remove from a pile, whoever removes the last object loses. And this is the type of game you could encode into an AI fairly easily, because the states are really just four numbers. Every state is just how many objects in each of the four piles. And the actions are things like, how many am I going to remove from each one of these individual piles? And the reward happens at the end, that if you were the player that had to remove the last object, then you get some sort of punishment. But if you were not, and the other player had to remove the last object, well, then you get some sort of reward. So we could actually try and show a demonstration of this, that I've implemented an AI to play the game of Nim. All right, so here, what we're going to do is create an AI as a result of training the AI on some number of games, that the AI is going to play against itself, where the idea is the AI will play games against itself, learn from each of those experiences, and learn what to do in the future. And then I, the human, will play against the AI. So initially, we'll say train zero times, meaning we're not going to let the AI play any practice games against itself in order to learn from its experiences. We're just going to see how well it plays. And it looks like there are four piles. I can choose how many I remove from any one of the piles. So maybe from pile three, I will remove five objects, for example. So now, AI chose to take one item from pile zero. So I'm left with these piles now, for example. And so here, I could choose maybe to say, I would like to remove from pile two, I'll remove all five of them, for example. And so AI chose to take two away from pile one. Now I'm left with one pile that has one object, one pile that has two objects. So from pile three, I will remove two objects. And now I've left the AI with no choice but to take that last one. And so the game is over, and I was able to win. But I did so because the AI was really just playing randomly. It didn't have any prior experience that it was using in order to make these sorts of judgments. Now let me let the AI train itself on 10,000 games. I'm going to let the AI play 10,000 games of nim against itself. Every time it wins or loses, it's going to learn from that experience and learn in the future what to do and what not to do. So here then, I'll go ahead and run this again. And now you see the AI running through a whole bunch of training games, 10,000 training games against itself. And now it's going to let me make these sorts of decisions. So now I'm going to play against the AI. Maybe I'll remove one from pile three. And the AI took everything from pile three, so I'm left with three piles. I'll go ahead and from pile two maybe remove three items. And the AI removes one item from pile zero. I'm left with two piles, each of which has two items in it. I'll remove one from pile one, I guess. And the AI took two from pile two, leaving me with no choice but to take one away from pile one. So it seems like after playing 10,000 games of nim against itself, the AI has learned something about what states and what actions tend to be good and has begun to learn some sort of pattern for how to predict what actions are going to be good and what actions are going to be bad in any given state. So reinforcement learning can be a very powerful technique for achieving these sorts of game-playing agents, agents that are able to play a game well just by learning from experience, whether that's playing against other people or by playing against itself and learning from those experiences as well. Now, nim is a bit of an easy game to use reinforcement learning for because there are so few states. There are only states that are as many as how many different objects are in each of these various different piles. You might imagine that it's going to be harder if you think of a game like chess or games where there are many, many more states and many, many more actions that you can imagine taking, where it's not going to be as easy to learn for every state and for every action what the value is going to be. So oftentimes in that case, we can't necessarily learn exactly what the value is for every state and for every action, but we can approximate it. So much as we saw with minimax, so we could use a depth-limiting approach to stop calculating at a certain point in time, we can do a similar type of approximation known as function approximation in a reinforcement learning context where instead of learning a value of q for every state and every action, we just have some function that estimates what the value is for taking this action in this particular state that might be based on various different features of the state that the agent happens to be in, where you might have to choose what those features actually are. But you can begin to learn some patterns that generalize beyond one specific state and one specific action that you can begin to learn if certain features tend to be good things or bad things. Reinforcement learning can allow you, using a very similar mechanism, to generalize beyond one particular state and say, if this other state looks kind of like this state, then maybe the similar types of actions that worked in one state will also work in another state as well. And so this type of approach can be quite helpful as you begin to deal with reinforcement learning that exist in larger and larger state spaces where it's just not feasible to explore all of the possible states that could actually exist. So there, then, are two of the main categories of reinforcement learning. Supervised learning, where you have labeled input and output pairs, and reinforcement learning, where an agent learns from rewards or punishments that it receives. The third major category of machine learning that we'll just touch on briefly is known as unsupervised learning. And unsupervised learning happens when we have data without any additional feedback, without labels, that in the supervised learning case, all of our data had labels. We labeled the data point with whether that was a rainy day or not rainy day. And using those labels, we were able to infer what the pattern was. Or we labeled data as a counterfeit banknote or not a counterfeit. And using those labels, we were able to draw inferences and patterns to figure out what does a banknote look like versus not. In unsupervised learning, we don't have any access to any of those labels. But we still would like to learn some of those patterns. And one of the tasks that you might want to perform in unsupervised learning is something like clustering, where clustering is just the task of, given some set of objects, organize it into distinct clusters, groups of objects that are similar to one another. And there's lots of applications for clustering. It comes up in genetic research, where you might have a whole bunch of different genes and you want to cluster them into similar genes if you're trying to analyze them across a population or across species. It comes up in an image if you want to take all the pixels of an image, cluster them into different parts of the image. Comes a lot up in market research if you want to divide your consumers into different groups so you know which groups to target with certain types of product advertisements, for example, and a number of other contexts as well in which clustering can be very applicable. One technique for clustering is an algorithm known as k-means clustering. And what k-means clustering is going to do is it is going to divide all of our data points into k different clusters. And it's going to do so by repeating this process of assigning points to clusters and then moving around those clusters at centers. We're going to define a cluster by its center, the middle of the cluster, and then assign points to that cluster based on which center is closest to that point. And I'll show you an example of that now. Here, for example, I have a whole bunch of unlabeled data, just various data points that are in some sort of graphical space. And I would like to group them into various different clusters. But I don't know how to do that originally. And let's say I want to assign like three clusters to this group. And you have to choose how many clusters you want in k-means clustering that you could try multiple and see how well those values perform. But I'll start just by randomly picking some places to put the centers of those clusters. Maybe I have a blue cluster, a red cluster, and a green cluster. And I'm going to start with the centers of those clusters just being in these three locations here. And what k-means clustering tells us to do is once I have the centers of the clusters, assign every point to a cluster based on which cluster center it is closest to. So we end up with something like this, where all of these points are closer to the blue cluster center than any other cluster center. All of these points here are closer to the green cluster center than any other cluster center. And then these two points plus these points over here, those are all closest to the red cluster center instead. So here then is one possible assignment of all these points to three different clusters. But it's not great that it seems like in this red cluster, these points are kind of far apart. In this green cluster, these points are kind of far apart. It might not be my ideal choice of how I would cluster these various different data points. But k-means clustering is an iterative process that after I do this, there is a next step, which is that after I've assigned all of the points to the cluster center that it is nearest to, we are going to re-center the clusters, meaning take the cluster centers, these diamond shapes here, and move them to the middle, or the average, effectively, of all of the points that are in that cluster. So we'll take this blue point, this blue center, and go ahead and move it to the middle or to the center of all of the points that were assigned to the blue cluster, moving it slightly to the right in this case. And we'll do the same thing for red. We'll move the cluster center to the middle of all of these points, weighted by how many points there are. There are more points over here, so the red center ends up moving a little bit further that way. And likewise, for the green center, there are many more points on this side of the green center. So the green center ends up being pulled a little bit further in this direction. So we re-center all of the clusters, and then we repeat the process. We go ahead and now reassign all of the points to the cluster center that they are now closest to. And now that we've moved around the cluster centers, these cluster assignments might change. That this point originally was closer to the red cluster center, but now it's actually closer to the blue cluster center. Same goes for this point as well. And these three points that were originally closer to the green cluster center are now closer to the red cluster center instead. So we can reassign what colors or which clusters each of these data points belongs to, and then repeat the process again, moving each of these cluster means and the middles of the clusterism to the mean, the average, of all of the other points that happen to be there, and repeat the process again. Go ahead and assign each of the points to the cluster that they are closest to. So once we reach a point where we've assigned all the points to clusters to the cluster that they are nearest to, and nothing changed, we've reached a sort of equilibrium in this situation, where no points are changing their allegiance. And as a result, we can declare this algorithm is now over. And we now have some assignment of each of these points into three different clusters. And it looks like we did a pretty good job of trying to identify which points are more similar to one another than they are to points in other groups. So we have the green cluster down here, this blue cluster here, and then this red cluster over there as well. And we did so without any access to some labels to tell us what these various different clusters were. We just used an algorithm in an unsupervised sense without any of those labels to figure out which points belonged to which categories. And again, lots of applications for this type of clustering technique. And there are many more algorithms in each of these various different fields within machine learning, supervised and reinforcement and unsupervised. But those are many of the big picture foundational ideas that underlie a lot of these techniques, where these are the problems that we're trying to solve. And we try and solve those problems using a number of different methods of trying to take data and learn patterns in that data, whether that's trying to find neighboring data points that are similar or trying to minimize some sort of loss function or any number of other techniques that allow us to begin to try to solve these sorts of problems. That then was a look at some of the principles that are at the foundation of modern machine learning, this ability to take data and learn from that data so that the computer can perform a task even if they haven't explicitly been given instructions in order to do so. Next time, we'll continue this conversation about machine learning, looking at other techniques we can use for solving these sorts of problems. We'll see you then. All right, welcome back, everyone, to an introduction to artificial intelligence with Python. Now, last time, we took a look at machine learning, a set of techniques that computers can use in order to take a set of data and learn some patterns inside of that data, learn how to perform a task even if we the programmers didn't give the computer explicit instructions for how to perform that task. Today, we transition to one of the most popular techniques and tools within machine learning, that of neural networks. And neural networks were inspired as early as the 1940s by researchers who were thinking about how it is that humans learn, studying neuroscience in the human brain and trying to see whether or not we could apply those same ideas to computers as well and model computer learning off of human learning. So how is the brain structured? Well, very simply put, the brain consists of a whole bunch of neurons. And those neurons are connected to one another and communicate with one another in some way. In particular, if you think about the structure of a biological neural network, something like this, there are a couple of key properties that scientists observed. One was that these neurons are connected to each other and receive electrical signals from one another, that one neuron can propagate electrical signals to another neuron. And another point is that neurons process those input signals and then can be activated, that a neuron becomes activated at a certain point and then can propagate further signals onto neurons in the future. And so the question then became, could we take this biological idea of how it is that humans learn with brains and with neurons and apply that to a machine as well, in effect designing an artificial neural network, or an ANN, which will be a mathematical model for learning that is inspired by these biological neural networks? And what artificial neural networks will allow us to do is they will first be able to model some sort of mathematical function. Every time you look at a neural network, which we'll see more of later today, each one of them is really just some mathematical function that is mapping certain inputs to particular outputs based on the structure of the network, that depending on where we place particular units inside of this neural network, that's going to determine how it is that the network is going to function. And in particular, artificial neural networks are going to lend themselves to a way that we can learn what the network's parameters should be. We'll see more on that in just a moment. But in effect, we want a model such that it is easy for us to be able to write some code that allows for the network to be able to figure out how to model the right mathematical function given a particular set of input data. So in order to create our artificial neural network, instead of using biological neurons, we're just going to use what we're going to call units, units inside of a neural network, which we can represent kind of like a node in a graph, which will here be represented just by a blue circle like this. And these artificial units, these artificial neurons, can be connected to one another. So here, for instance, we have two units that are connected by this edge inside of this graph, effectively. And so what we're going to do now is think of this idea as some sort of mapping from inputs to outputs. So we have one unit that is connected to another unit that we might think of this side of the input and that side of the output. And what we're trying to do then is to figure out how to solve a problem, how to model some sort of mathematical function. And this might take the form of something we saw last time, which was something like we have certain inputs, like variables x1 and x2. And given those inputs, we want to perform some sort of task, a task like predicting whether or not it's going to rain. And ideally, we'd like some way, given these inputs, x1 and x2, which stand for some sort of variables to do with the weather, we would like to be able to predict, in this case, a Boolean classification. Is it going to rain, or is it not going to rain? And we did this last time by way of a mathematical function. We defined some function, h, for our hypothesis function, that took as input x1 and x2, the two inputs that we cared about processing, in order to determine whether we thought it was going to rain or whether we thought it was not going to rain. The question then becomes, what does this hypothesis function do in order to make that determination? And we decided last time to use a linear combination of these input variables to determine what the output should be. So our hypothesis function was equal to something like this. Weight 0 plus weight 1 times x1 plus weight 2 times x2. So what's going on here is that x1 and x2, those are input variables, the inputs to this hypothesis function. And each of those input variables is being multiplied by some weight, which is just some number. So x1 is being multiplied by weight 1, x2 is being multiplied by weight 2. And we have this additional weight, weight 0, that doesn't get multiplied by an input variable at all, that just serves to either move the function up or move the function's value down. You can think of this as either a weight that's just multiplied by some dummy value, like the number 1. It's multiplied by 1, and so it's not multiplied by anything. Or sometimes, you'll see in the literature, people call this variable weight 0 a bias, so that you can think of these variables as slightly different. We have weights that are multiplied by the input, and we separately add some bias to the result as well. You'll hear both of those terminologies used when people talk about neural networks and machine learning. So in effect, what we've done here is that in order to define a hypothesis function, we just need to decide and figure out what these weights should be to determine what values to multiply by our inputs to get some sort of result. Of course, at the end of this, what we need to do is make some sort of classification, like rainy or not rainy. And to do that, we use some sort of function that defines some sort of threshold. And so we saw, for instance, the step function, which is defined as 1 if the result of multiplying the weights by the inputs is at least 0, otherwise it's 0. And you can think of this line down the middle as kind of like a dotted line. Effectively, it stays at 0 all the way up to one point, and then the function steps or jumps up to 1. So it's 0 before it reaches some threshold, and then it's 1 after it reaches a particular threshold. And so this was one way we could define what will come to call an activation function, a function that determines when it is that this output becomes active, changes to 1 instead of being a 0. But we also saw that if we didn't just want a purely binary classification, we didn't want purely 1 or 0, but we wanted to allow for some in-between real numbered values, we could use a different function. And there are a number of choices, but the one that we looked at was the logistic sigmoid function that has sort of an s-shaped curve, where we could represent this as a probability that may be somewhere in between the probability of rain or something like 0.5. Maybe a little bit later, the probability of rain is 0.8. And so rather than just have a binary classification of 0 or 1, we could allow for numbers that are in between as well. And it turns out there are many other different types of activation functions, where an activation function just takes the output of multiplying the weights together and adding that bias, and then figuring out what the actual output should be. Another popular one is the rectified linear unit, otherwise known as ReLU. And the way that works is that it just takes its input and takes the maximum of that input and 0. So if it's positive, it remains unchanged. But if it's 0, if it's negative, it goes ahead and levels out at 0. And there are other activation functions that we could choose as well. But in short, each of these activation functions, you can just think of as a function that gets applied to the result of all of this computation. We take some function g and apply it to the result of all of that calculation. And this then is what we saw last time, the way of defining some hypothesis function that takes in inputs, calculate some linear combination of those inputs, and then passes it through some sort of activation function to get our output. And this actually turns out to be the model for the simplest of neural networks, that we're going to instead represent this mathematical idea graphically by using a structure like this. Here then is a neural network that has two inputs. We can think of this as x1 and this as x2. And then one output, which you can think of as classifying whether or not we think it's going to rain or not rain, for example, in this particular instance. And so how exactly does this model work? Well, each of these two inputs represents one of our input variables, x1 and x2. And notice that these inputs are connected to this output via these edges, which are going to be defined by their weights. So these edges each have a weight associated with them, weight 1 and weight 2. And then this output unit, what it's going to do is it is going to calculate an output based on those inputs and based on those weights. This output unit is going to multiply all the inputs by their weights, add in this bias term, which you can think of as an extra w0 term that gets added into it, and then we pass it through an activation function. So this then is just a graphical way of representing the same idea we saw last time just mathematically. And we're going to call this a very simple neural network. And we'd like for this neural network to be able to learn how to calculate some function, that we want some function for the neural network to learn. And the neural network is going to learn what should the values of w0, w1, and w2 be? What should the activation function be in order to get the result that we would expect? So we can actually take a look at an example of this. What then is a very simple function that we might calculate? Well, if we recall back from when we were looking at propositional logic, one of the simplest functions we looked at was something like the or function that takes two inputs, x and y, and outputs 1, otherwise known as true, if either one of the inputs or both of them are 1, and outputs of 0 if both of the inputs are 0 or false. So this then is the or function. And this was the truth table for the or function, that as long as either of the inputs are 1, the output of the function is 1, and the only case where the output is 0 is where both of the inputs are 0. So the question is, how could we take this and train a neural network to be able to learn this particular function? What would those weights look like? Well, we could do something like this. Here's our neural network. And I'll propose that in order to calculate the or function, we're going to use a value of 1 for each of the weights. And we'll use a bias of negative 1. And then we'll just use this step function as our activation function. How then does this work? Well, if I wanted to calculate something like 0 or 0, which we know to be 0 because false or false is false, then what are we going to do? Well, our output unit is going to calculate this input multiplied by the weight, 0 times 1, that's 0. Same thing here, 0 times 1, that's 0. And we'll add to that the bias minus 1. So that'll give us a result of negative 1. If we plot that on our activation function, negative 1 is here. It's before the threshold, which means either 0 or 1. It's only 1 after the threshold. Since negative 1 is before the threshold, the output that this unit provides is going to be 0. And that's what we would expect it to be, that 0 or 0 should be 0. What if instead we had had 1 or 0, where this is the number 1? Well, in this case, in order to calculate what the output is going to be, we again have to do this weighted sum, 1 times 1, that's 1. 0 times 1, that's 0. Sum of that so far is 1. Add negative 1 to that. Well, then the output is 0. And if we plot 0 on the step function, 0 ends up being here. It's just at the threshold. And so the output here is going to be 1, because the output of 1 or 0, that's 1. So that's what we would expect as well. And just for one more example, if I had 1 or 1, what would the result be? Well, 1 times 1 is 1. 1 times 1 is 1. The sum of those is 2. I add the bias term to that. I get the number 1. 1 plotted on this graph is way over there. That's well beyond the threshold. And so this output is going to be 1 as well. The output is always 0 or 1, depending on whether or not we're past the threshold. And this neural network then models the OR function, a very simple function, definitely. But it still is able to model it correctly. If I give it the inputs, it will tell me what x1 or x2 happens to be. And you could imagine trying to do this for other functions as well. A function like the AND function, for instance, that takes two inputs and calculates whether both x and y are true. So if x is 1 and y is 1, then the output of x and y is 1. But in all the other cases, the output is 0. How could we model that inside of a neural network as well? Well, it turns out we could do it in the same way, except instead of negative 1 as the bias, we can use negative 2 as the bias instead. What does that end up looking like? Well, if I had 1 and 1, that should be 1, because 1 true and true is equal to true. Well, I take 1 times 1, that's 1. 1 times 1 is 1. I get a total sum of 2 so far. Now I add the bias of negative 2, and I get the value 0. And 0, when I plot it on the activation function, is just past that threshold, and so the output is going to be 1. But if I had any other input, for example, like 1 and 0, well, the weighted sum of these is 1 plus 0 is going to be 1. Minus 2 is going to give us negative 1, and negative 1 is not past that threshold, and so the output is going to be 0. So those then are some very simple functions that we can model using a neural network that has two inputs and one output, where our goal is to be able to figure out what those weights should be in order to determine what the output should be. And you could imagine generalizing this to calculate more complex functions as well, that maybe, given the humidity and the pressure, we want to calculate what's the probability that it's going to rain, for example. Or we might want to do a regression-style problem. We're given some amount of advertising, and given what month it is maybe, we want to predict what our expected sales are going to be for that particular month. So you could imagine these inputs and outputs being different as well. And it turns out that in some problems, we're not just going to have two inputs, and the nice thing about these neural networks is that we can compose multiple units together, make our networks more complex just by adding more units into this particular neural network. So the network we've been looking at has two inputs and one output. But we could just as easily say, let's go ahead and have three inputs in there, or have even more inputs, where we could arbitrarily decide however many inputs there are to our problem, all going to be calculating some sort of output that we care about figuring out the value of. How then does the math work for figuring out that output? Well, it's going to work in a very similar way. In the case of two inputs, we had two weights indicated by these edges, and we multiplied the weights by the numbers, adding this bias term. And we'll do the same thing in the other cases as well. If I have three inputs, you'll imagine multiplying each of these three inputs by each of these weights. If I had five inputs instead, we're going to do the same thing. Here I'm saying sum up from 1 to 5, xi multiplied by weight i. So take each of the five input variables, multiply them by their corresponding weight, and then add the bias to that. So this would be a case where there are five inputs into this neural network, for example. But there could be more, arbitrarily many nodes that we want inside of this neural network, where each time we're just going to sum up all of those input variables multiplied by their weight and then add the bias term at the very end. And so this allows us to be able to represent problems that have even more inputs just by growing the size of our neural network. Now, the next question we might ask is a question about how it is that we train these neural networks. In the case of the or function and the and function, they were simple enough functions that I could just tell you, like here, what the weights should be. And you could probably reason through it yourself what the weights should be in order to calculate the output that you want. But in general, with functions like predicting sales or predicting whether or not it's going to rain, these are much trickier functions to be able to figure out. We would like the computer to have some mechanism of calculating what it is that the weights should be, how it is to set the weights so that our neural network is able to accurately model the function that we care about trying to estimate. And it turns out that the strategy for doing this, inspired by the domain of calculus, is a technique called gradient descent. And what gradient descent is, it is an algorithm for minimizing loss when you're training a neural network. And recall that loss refers to how bad our hypothesis function happens to be, that we can define certain loss functions. And we saw some examples of loss functions last time that just give us a number for any particular hypothesis, saying, how poorly does it model the data? How many examples does it get wrong? How are they worse or less bad as compared to other hypothesis functions that we might define? And this loss function is just a mathematical function. And when you have a mathematical function, in calculus what you could do is calculate something known as the gradient, which you can think of as like a slope. It's the direction the loss function is moving at any particular point. And what it's going to tell us is, in which direction should we be moving these weights in order to minimize the amount of loss? And so generally speaking, we won't get into the calculus of it. But the high level idea for gradient descent is going to look something like this. If we want to train a neural network, we'll go ahead and start just by choosing the weights randomly. Just pick random weights for all of the weights in the neural network. And then we'll use the input data that we have access to in order to train the network, in order to figure out what the weights should actually be. So we'll repeat this process again and again. The first step is we're going to calculate the gradient based on all of the data points. So we'll look at all the data and figure out what the gradient is at the place where we currently are for the current setting of the weights, which means in which direction should we move the weights in order to minimize the total amount of loss, in order to make our solution better. And once we've calculated that gradient, which direction we should move in the loss function, well, then we can just update those weights according to the gradient. Take a small step in the direction of those weights in order to try to make our solution a little bit better. And the size of the step that we take, that's going to vary. And you can choose that when you're training a particular neural network. But in short, the idea is going to be take all the data points, figure out based on those data points in what direction the weights should move, and then move the weights one small step in that direction. And if you repeat that process over and over again, adjusting the weights a little bit at a time based on all the data points, eventually you should end up with a pretty good solution to trying to solve this sort of problem. At least that's what we would hope to happen. Now, if you look at this algorithm, a good question to ask anytime you're analyzing an algorithm is what is going to be the expensive part of doing the calculation? What's going to take a lot of work to try to figure out? What is going to be expensive to calculate? And in particular, in the case of gradient descent, the really expensive part is this all data points part right here, having to take all of the data points and using all of those data points figure out what the gradient is at this particular setting of all of the weights. Because odds are in a big machine learning problem where you're trying to solve a big problem with a lot of data, you have a lot of data points in order to calculate. And figuring out the gradient based on all of those data points is going to be expensive. And you'll have to do it many times. You'll likely repeat this process again and again and again, going through all the data points, taking one small step over and over as you try and figure out what the optimal setting of those weights happens to be. It turns out that we would ideally like to be able to train our neural networks faster, to be able to more quickly converge to some sort of solution that is going to be a good solution to the problem. So in that case, there are alternatives to just standard gradient descent, which looks at all of the data points at once. We can employ a method like stochastic gradient descent, which will randomly just choose one data point at a time to calculate the gradient based on, instead of calculating it based on all of the data points. So the idea there is that we have some setting of the weights. We pick a data point. And based on that one data point, we figure out in which direction should we move all of the weights and move the weights in that small direction, then take another data point and do that again and repeat this process again and again, maybe looking at each of the data points multiple times, but each time only using one data point to calculate the gradient, to calculate which direction we should move in. Now, just using one data point instead of all of the data points probably gives us a less accurate estimate of what the gradient actually is. But on the plus side, it's going to be much faster to be able to calculate, that we can much more quickly calculate what the gradient is based on one data point, instead of calculating based on all of the data points and having to do all of that computational work again and again. So there are trade-offs here between looking at all of the data points and just looking at one data point. And it turns out that a middle ground that is also quite popular is a technique called mini-batch gradient descent, where the idea there is instead of looking at all of the data versus just a single point, we instead divide our data set up into small batches, groups of data points, where you can decide how big a particular batch is. But in short, you're just going to look at a small number of points at any given time, hopefully getting a more accurate estimate of the gradient, but also not requiring all of the computational effort needed to look at every single one of these data points. So gradient descent, then, is this technique that we can use in order to train these neural networks, in order to figure out what the setting of all of these weights should be if we want some way to try and get an accurate notion of how it is that this function should work, some way of modeling how to transform the inputs into particular outputs. Now, so far, the networks that we've taken a look at have all been structured similar to this. We have some number of inputs, maybe two or three or five or more. And then we have one output that is just predicting like rain or no rain or just predicting one particular value. But often in machine learning problems, we don't just care about one output. We might care about an output that has multiple different values associated with it. So in the same way that we could take a neural network and add units to the input layer, we can likewise add inputs or add outputs to the output layer as well. Instead of just one output, you could imagine we have two outputs, or we could have four outputs, for example, where in each case, as we add more inputs or add more outputs, if we want to keep this network fully connected between these two layers, we just need to add more weights, that now each of these input nodes has four weights associated with each of the four outputs. And that's true for each of these various different input nodes. So as we add nodes, we add more weights in order to make sure that each of the inputs can somehow be connected to each of the outputs so that each output value can be calculated based on what the value of the input happens to be. So what might a case be where we want multiple different output values? Well, you might consider that in the case of weather predicting, for example, we might not just care whether it's raining or not raining. There might be multiple different categories of weather that we would like to categorize the weather into. With just a single output variable, we can do a binary classification, like rain or no rain, for instance, 1 or 0. But it doesn't allow us to do much more than that. With multiple output variables, I might be able to use each one to predict something a little different. Maybe I want to categorize the weather into one of four different categories, something like is it going to be raining or sunny or cloudy or snowy. And I now have four output variables that can be used to represent maybe the probability that it is rainy as opposed to sunny as opposed to cloudy or as opposed to snowy. How then would this neural network work? Well, we have some input variables that represent some data that we have collected about the weather. Each of those inputs gets multiplied by each of these various different weights. We have more multiplications to do, but these are fairly quick mathematical operations to perform. And then what we get is after passing them through some sort of activation function in the outputs, we end up getting some sort of number, where that number, you might imagine, you could interpret as a probability, like a probability that it is one category as opposed to another category. So here we're saying that based on the inputs, we think there is a 10% chance that it's raining, a 60% chance that it's sunny, a 20% chance of cloudy, a 10% chance that it's snowy. And given that output, if these represent a probability distribution, well, then you could just pick whichever one has the highest value, in this case, sunny, and say that, well, most likely, we think that this categorization of inputs means that the output should be snowy or should be sunny. And that is what we would expect the weather to be in this particular instance. And so this allows us to do these sort of multi-class classifications, where instead of just having a binary classification, 1 or 0, we can have as many different categories as we want. And we can have our neural network output these probabilities over which categories are more likely than other categories. And using that data, we're able to draw some sort of inference on what it is that we should do. So this was sort of the idea of supervised machine learning. I can give this neural network a whole bunch of data, a whole bunch of input data corresponding to some label, some output data, like we know that it was raining on this day, we know that it was sunny on that day. And using all of that data, the algorithm can use gradient descent to figure out what all of the weights should be in order to create some sort of model that hopefully allows us a way to predict what we think the weather is going to be. But neural networks have a lot of other applications as well. You could imagine applying the same sort of idea to a reinforcement learning sort of example as well, where you remember that in reinforcement learning, what we wanted to do is train some sort of agent to learn what action to take, depending on what state they currently happen to be in. So depending on the current state of the world, we wanted the agent to pick from one of the available actions that is available to them. And you might model that by having each of these input variables represent some information about the state, some data about what state our agent is currently in. And then the output, for example, could be each of the various different actions that our agent could take, action 1, 2, 3, and 4. And you might imagine that this network would work in the same way, but based on these particular inputs, we go ahead and calculate values for each of these outputs. And those outputs could model which action is better than other actions. And we could just choose, based on looking at those outputs, which action we should take. And so these neural networks are very broadly applicable, that all they're really doing is modeling some mathematical function. So anything that we can frame as a mathematical function, something like classifying inputs into various different categories or figuring out based on some input state what action we should take, these are all mathematical functions that we could attempt to model by taking advantage of this neural network structure, and in particular, taking advantage of this technique, gradient descent, that we can use in order to figure out what the weights should be in order to do this sort of calculation. Now, how is it that you would go about training a neural network that has multiple outputs instead of just one? Well, with just a single output, we could see what the output for that value should be, and then you update all of the weights that corresponded to it. And when we have multiple outputs, at least in this particular case, we can really think of this as four separate neural networks, that really we just have one network here that has these three inputs corresponding with these three weights corresponding to this one output value. And the same thing is true for this output value. This output value effectively defines yet another neural network that has these same three inputs, but a different set of weights that correspond to this output. And likewise, this output has its own set of weights as well, and same thing for the fourth output too. And so if you wanted to train a neural network that had four outputs instead of just one, in this case where the inputs are directly connected to the outputs, you could really think of this as just training four independent neural networks. We know what the outputs for each of these four should be based on our input data, and using that data, we can begin to figure out what all of these individual weights should be. And maybe there's an additional step at the end to make sure that we turn these values into a probability distribution such that we can interpret which one is better than another or more likely than another as a category or something like that. So this then seems like it does a pretty good job of taking inputs and trying to predict what outputs should be. And we'll see some real examples of this in just a moment as well. But it's important then to think about what the limitations of this sort of approach is, of just taking some linear combination of inputs and passing it into some sort of activation function. And it turns out that when we do this in the case of binary classification, trying to predict does it belong to one category or another, we can only predict things that are linearly separable. Because we're taking a linear combination of inputs and using that to define some decision boundary or threshold, then what we get is a situation where if we have this set of data, we can predict a line that separates linearly the red points from the blue points, but a single unit that is making a binary classification, otherwise known as a perceptron, can't deal with a situation like this, where we've seen this type of situation before, where there is no straight line that just goes straight through the data that will divide the red points away from the blue points. It's a more complex decision boundary. The decision boundary somehow needs to capture the things inside of this circle. And there isn't really a line that will allow us to deal with that. So this is the limitation of the perceptron, these units that just make these binary decisions based on their inputs, that a single perceptron is only capable of learning a linearly separable decision boundary. All it can do is define a line. And sure, it can give us probabilities based on how close to that decision boundary we are, but it can only really decide based on a linear decision boundary. And so this doesn't seem like it's going to generalize well to situations where real world data is involved, because real world data often isn't linearly separable. It often isn't the case that we can just draw a line through the data and be able to divide it up into multiple groups. So what then is the solution to this? Well, what was proposed was the idea of a multilayer neural network, that so far all of the neural networks we've seen have had a set of inputs and a set of outputs, and the inputs are connected to those outputs. But in a multilayer neural network, this is going to be an artificial neural network that has an input layer still. It has an output layer, but also has one or more hidden layers in between. Other layers of artificial neurons or units that are going to calculate their own values as well. So instead of a neural network that looks like this with three inputs and one output, you might imagine in the middle here injecting a hidden layer, something like this. This is a hidden layer that has four nodes. You could choose how many nodes or units end up going into the hidden layer. You can have multiple hidden layers as well. And so now each of these inputs isn't directly connected to the output. Each of the inputs is connected to this hidden layer. And then all of the nodes in the hidden layer, those are connected to the one output. And so this is just another step that we can take towards calculating more complex functions. Each of these hidden units will calculate its output value, otherwise known as its activation, based on a linear combination of all the inputs. And once we have values for all of these nodes, as opposed to this just being the output, we do the same thing again. Calculate the output for this node based on multiplying each of the values for these units by their weights as well. So in effect, the way this works is that we start with inputs. They get multiplied by weights in order to calculate values for the hidden nodes. Those get multiplied by weights in order to figure out what the ultimate output is going to be. And the advantage of layering things like this is it gives us an ability to model more complex functions, that instead of just having a single decision boundary, a single line dividing the red points from the blue points, each of these hidden nodes can learn a different decision boundary. And we can combine those decision boundaries to figure out what the ultimate output is going to be. And as we begin to imagine more complex situations, you could imagine each of these nodes learning some useful property or learning some useful feature of all of the inputs and us somehow learning how to combine those features together in order to get the output that we actually want. Now, the natural question when we begin to look at this now is to ask the question of, how do we train a neural network that has hidden layers inside of it? And this turns out to initially be a bit of a tricky question, because the input data that we are given is we are given values for all of the inputs, and we're given what the value of the output should be, what the category is, for example. But the input data doesn't tell us what the values for all of these nodes should be. So we don't know how far off each of these nodes actually is because we're only given data for the inputs and the outputs. The reason this is called the hidden layer is because the data that is made available to us doesn't tell us what the values for all of these intermediate nodes should actually be. And so the strategy people came up with was to say that if you know what the error or the losses on the output node, well, then based on what these weights are, if one of these weights is higher than another, you can calculate an estimate for how much the error from this node was due to this part of the hidden node, or this part of the hidden layer, or this part of the hidden layer, based on the values of these weights, in effect saying that based on the error from the output, I can back propagate the error and figure out an estimate for what the error is for each of these nodes in the hidden layer as well. And there's some more calculus here that we won't get into the details of, but the idea of this algorithm is known as back propagation. It's an algorithm for training a neural network with multiple different hidden layers. And the idea for this, the pseudocode for it, will again be if we want to run gradient descent with back propagation. We'll start with a random choice of weights, as we did before. And now we'll go ahead and repeat the training process again and again. But what we're going to do each time is now we're going to calculate the error for the output layer first. We know the output and what it should be, and we know what we calculated so we can figure out what the error there is. But then we're going to repeat for every layer, starting with the output layer, moving back into the hidden layer, then the hidden layer before that if there are multiple hidden layers, going back all the way to the very first hidden layer, assuming there are multiple, we're going to propagate the error back one layer. Whatever the error was from the output, figure out what the error should be a layer before that based on what the values of those weights are. And then we can update those weights. So graphically, the way you might think about this is that we first start with the output. We know what the output should be. We know what output we calculated. And based on that, we can figure out, all right, how do we need to update those weights? Backpropagating the error to these nodes. And using that, we can figure out how we should update these weights. And you might imagine if there are multiple layers, we could repeat this process again and again to begin to figure out how all of these weights should be updated. And this backpropagation algorithm is really the key algorithm that makes neural networks possible. It makes it possible to take these multi-level structures and be able to train those structures depending on what the values of these weights are in order to figure out how it is that we should go about updating those weights in order to create some function that is able to minimize the total amount of loss, to figure out some good setting of the weights that will take the inputs and translate it into the output that we expect. And this works, as we said, not just for a single hidden layer. But you can imagine multiple hidden layers, where each hidden layer we just define however many nodes we want, where each of the nodes in one layer, we can connect to the nodes in the next layer, defining more and more complex networks that are able to model more and more complex types of functions. And so this type of network is what we might call a deep neural network, part of a larger family of deep learning algorithms, if you've ever heard that term. And all deep learning is about is it's using multiple layers to be able to predict and be able to model higher level features inside of the input, to be able to figure out what the output should be. And so a deep neural network is just a neural network that has multiple of these hidden layers, where we start at the input, calculate values for this layer, then this layer, then this layer, and then ultimately get an output. And this allows us to be able to model more and more sophisticated types of functions, that each of these layers can calculate something a little bit different, and we can combine that information to figure out what the output should be. Of course, as with any situation of machine learning, as we begin to make our models more and more complex, to model more and more complex functions, the risk we run is something like overfitting. And we talked about overfitting last time in the context of overfitting based on when we were training our models to be able to learn some sort of decision boundary, where overfitting happens when we fit too closely to the training data. And as a result, we don't generalize well to other situations as well. And one of the risks we run with a far more complex neural network that has many, many different nodes is that we might overfit based on the input data. We might grow over reliant on certain nodes to calculate things just purely based on the input data that doesn't allow us to generalize very well to the output. And there are a number of strategies for dealing with overfitting. But one of the most popular in the context of neural networks is a technique known as dropout. And what dropout does is it, when we're training the neural network, what we'll do in dropout is temporarily remove units, temporarily remove these artificial neurons from our network chosen at random. And the goal here is to prevent over-reliance on certain units. What generally happens in overfitting is that we begin to over-rely on certain units inside the neural network to be able to tell us how to interpret the input data. What dropout will do is randomly remove some of these units in order to reduce the chance that we over-rely on certain units to make our neural network more robust, to be able to handle the situations even when we just drop out particular neurons entirely. So the way that might work is we have a network like this. And as we're training it, when we go about trying to update the weights the first time, we'll just randomly pick some percentage of the nodes to drop out of the network. It's as if those nodes aren't there at all. It's as if the weights associated with those nodes aren't there at all. And we'll train it this way. Then the next time we update the weights, we'll pick a different set and just go ahead and train that way. And then again, randomly choose and train with other nodes that have been dropped out as well. And the goal of that is that after the training process, if you train by dropping out random nodes inside of this neural network, you hopefully end up with a network that's a little bit more robust, that doesn't rely too heavily on any one particular node, but more generally learns how to approximate a function in general. So that then is a look at some of these techniques that we can use in order to implement a neural network, to get at the idea of taking this input, passing it through these various different layers in order to produce some sort of output. And what we'd like to do now is take those ideas and put them into code. And to do that, there are a number of different machine learning libraries, neural network libraries that we can use that allow us to get access to someone's implementation of back propagation and all of these hidden layers. And one of the most popular, developed by Google, is known as TensorFlow, a library that we can use for quickly creating neural networks and modeling them and running them on some sample data to see what the output is going to be. And before we actually start writing code, we'll go ahead and take a look at TensorFlow's playground, which will be an opportunity for us just to play around with this idea of neural networks in different layers, just to get a sense for what it is that we can do by taking advantage of neural networks. So let's go ahead and go into TensorFlow's playground, which you can go to by visiting that URL from before. And what we're going to do now is we're going to try and learn the decision boundary for this particular output. I want to learn to separate the orange points from the blue points. And I'd like to learn some sort of setting of weights inside of a neural network that will be able to separate those from each other. The features we have access to, our input data, are the x value and the y value, so the two values along each of the two axes. And what I'll do now is I can set particular parameters, like what activation function I would like to use. And I'll just go ahead and press play and see what happens. And what happens here is that you'll see that just by using these two input features, the x value and the y value, with no hidden layers, just take the input, x and y values, and figure out what the decision boundary is. Our neural network learns pretty quickly that in order to divide these two points, we should just use this line. This line acts as a decision boundary that separates this group of points from that group of points, and it does it very well. You can see up here what the loss is. The training loss is 0, meaning we were able to perfectly model separating these two points from each other inside of our training data. So this was a fairly simple case of trying to apply a neural network because the data is very clean. It's very nicely linearly separable. We could just draw a line that separates all of those points from each other. Let's now consider a more complex case. So I'll go ahead and pause the simulation, and we'll go ahead and look at this data set here. This data set is a little bit more complex now. In this data set, we still have blue and orange points that we'd like to separate from each other. But there's no single line that we can draw that is going to be able to figure out how to separate the blue from the orange, because the blue is located in these two quadrants, and the orange is located here and here. It's a more complex function to be able to learn. So let's see what happens. If we just try and predict based on those inputs, the x and y coordinates, what the output should be, I'll press Play. And what you'll notice is that we're not really able to draw much of a conclusion, that we're not able to very cleanly see how we should divide the orange points from the blue points, and you don't see a very clean separation there. So it seems like we don't have enough sophistication inside of our network to be able to model something that is that complex. We need a better model for this neural network. And I'll do that by adding a hidden layer. So now I have a hidden layer that has two neurons inside of it. So I have two inputs that then go to two neurons inside of a hidden layer that then go to our output. And now I'll press Play. And what you'll notice here is that we're able to do slightly better. We're able to now say, all right, these points are definitely blue. These points are definitely orange. We're still struggling a little bit with these points up here, though. And what we can do is we can see for each of these hidden neurons, what is it exactly that these hidden neurons are doing? Each hidden neuron is learning its own decision boundary. And we can see what that boundary is. This first neuron is learning, all right, this line that seems to separate some of the blue points from the rest of the points. This other hidden neuron is learning another line that seems to be separating the orange points in the lower right from the rest of the points. So that's why we're able to figure out these two areas in the bottom region. But we're still not able to perfectly classify all of the points. So let's go ahead and add another neuron. Now we've got three neurons inside of our hidden layer and see what we're able to learn now. All right, well, now we seem to be doing a better job. By learning three different decision boundaries, which each of the three neurons inside of our hidden layer, we're able to much better figure out how to separate these blue points from the orange points. And we can see what each of these hidden neurons is learning. Each one is learning a slightly different decision boundary. And then we're combining those decision boundaries together to figure out what the overall output should be. And then we can try it one more time by adding a fourth neuron there and try learning that. And it seems like now we can do even better at trying to separate the blue points from the orange points. But we were only able to do this by adding a hidden layer, by adding some layer that is learning some other boundaries and combining those boundaries to determine the output. And the strength, the size and thickness of these lines indicate how high these weights are, how important each of these inputs is for making this sort of calculation. And we can do maybe one more simulation. Let's go ahead and try this on a data set that looks like this. Go ahead and get rid of the hidden layer. Here now we're trying to separate the blue points from the orange points where all the blue points are located, again, inside of a circle effectively. So we're not going to be able to learn a line. Notice I press Play. And we're really not able to draw any sort of classification at all because there is no line that cleanly separates the blue points from the orange points. So let's try to solve this by introducing a hidden layer. I'll go ahead and press Play. And all right, with two neurons in a hidden layer, we're able to do a little better because we effectively learned two different decision boundaries. We learned this line here. And we learned this line on the right-hand side. And right now we're just saying, all right, well, if it's in between, we'll call it blue. And if it's outside, we'll call it orange. So not great, but certainly better than before, that we're learning one decision boundary and another. And based on those, we can figure out what the output should be. But let's now go ahead and add a third neuron and see what happens now. I go ahead and train it. And now, using three different decision boundaries that are learned by each of these hidden neurons, we're able to much more accurately model this distinction between blue points and orange points. We're able to figure out maybe with these three decision boundaries, combining them together, you can imagine figuring out what the output should be and how to make that sort of classification. And so the goal here is just to get a sense for having more neurons in these hidden layers allows us to learn more structure in the data, allows us to figure out what the relevant and important decision boundaries are. And then using this backpropagation algorithm, we're able to figure out what the values of these weights should be in order to train this network to be able to classify one category of points away from another category of points instead. And this is ultimately what we're going to be trying to do whenever we're training a neural network. So let's go ahead and actually see an example of this. You'll recall from last time that we had this banknotes file that included information about counterfeit banknotes as opposed to authentic banknotes, where I had four different values for each banknote and then a categorization of whether that banknote is considered to be authentic or a counterfeit note. And what I wanted to do was, based on that input information, figure out some function that could calculate based on the input information what category it belonged to. And what I've written here in banknotes.py is a neural network that will learn just that, a network that learns based on all of the input whether or not we should categorize a banknote as authentic or as counterfeit. The first step is the same as what we saw from last time. I'm really just reading the data in and getting it into an appropriate format. And so this is where more of the writing Python code on your own comes in, in terms of manipulating this data, massaging the data into a format that will be understood by a machine learning library like scikit-learn or like TensorFlow. And so here I separate it into a training and a testing set. And now what I'm doing down below is I'm creating a neural network. Here I'm using TF, which stands for TensorFlow. Up above, I said import TensorFlow as TF, TF just an abbreviation that we'll often use so we don't need to write out TensorFlow every time we want to use anything inside of the library. I'm using TF.keras. Keras is an API, a set of functions that we can use in order to manipulate neural networks inside of TensorFlow. And it turns out there are other machine learning libraries that also use the Keras API. But here I'm saying, all right, go ahead and give me a model that is a sequential model, a sequential neural network, meaning one layer after another. And now I'm going to add to that model what layers I want inside of my neural network. So here I'm saying model.add. Go ahead and add a dense layer. And when we say a dense layer, we mean a layer that is just each of the nodes inside of the layer is going to be connected to each of the nodes from the previous layer. So we have a densely connected layer. This layer is going to have eight units inside of it. So it's going to be a hidden layer inside of a neural network with eight different units, eight artificial neurons, each of which might learn something different. And I just sort of chose eight arbitrarily. You could choose a different number of hidden nodes inside of the layer. And as we saw before, depending on the number of units there are inside of your hidden layer, more units means you can learn more complex functions. So maybe you can more accurately model the training data. But it comes at the cost. More units means more weights that you need to figure out how to update. So it might be more expensive to do that calculation. And you also run the risk of overfitting on the data. If you have too many units and you learn to just overfit on the training data, that's not good either. So there is a balance. And there's often a testing process where you'll train on some data and maybe validate how well you're doing on a separate set of data, often called a validation set, to see, all right, which setting of parameters. How many layers should I have? How many units should be in each layer? Which one of those performs the best on the validation set? So you can do some testing to figure out what these hyper parameters, so called, should be equal to. Next, I specify what the input shape is. Meaning, all right, what does my input look like? My input has four values. And so the input shape is just four, because we have four inputs. And then I specify what the activation function is. And the activation function, again, we can choose. There are a number of different activation functions. Here I'm using relu, which you might recall from earlier. And then I'll add an output layer. So I have my hidden layer. Now I'm adding one more layer that will just have one unit, because all I want to do is predict something like counterfeit build or authentic build. So I just need a single unit. And the activation function I'm going to use here is that sigmoid activation function, which, again, was that S-shaped curve that just gave us a probability of what is the probability that this is a counterfeit build, as opposed to an authentic build. So that, then, is the structure of my neural network, a sequential neural network that has one hidden layer with eight units inside of it, and then one output layer that just has a single unit inside of it. And I can choose how many units there are. I can choose the activation function. Then I'm going to compile this model. TensorFlow gives you a choice of how you would like to optimize the weights. There are various different algorithms for doing that. What type of loss function you want to use. Again, many different options for doing that. And then how I want to evaluate my model, well, I care about accuracy. I care about how many of my points am I able to classify correctly versus not correctly as counterfeit or not counterfeit. And I would like it to report to me how accurate my model is performing. Then, now that I've defined that model, I call model.fit to say go ahead and train the model. Train it on all the training data plus all of the training labels. So labels for each of those pieces of training data. And I'm saying run it for 20 epics, meaning go ahead and go through each of these training points 20 times, effectively. Go through the data 20 times and keep trying to update the weights. If I did it for more, I could train for even longer and maybe get a more accurate result. But then after I fit it on all the data, I'll go ahead and just test it. I'll evaluate my model using model.evaluate built into TensorFlow that is just going to tell me how well do I perform on the testing data. So ultimately, this is just going to give me some numbers that tell me how well we did in this particular case. So now what I'm going to do is go into banknotes and go ahead and run banknotes.py. And what's going to happen now is it's going to read in all of that training data. It's going to generate a neural network with all my inputs, my eight hidden units inside my layer, and then an output unit. And now what it's doing is it's training. It's training 20 times. And each time you can see how my accuracy is increasing on my training data. It starts off the very first time not very accurate, though better than random, something like 79% of the time. It's able to accurately classify one bill from another. But as I keep training, notice this accuracy value improves and improves and improves until after I've trained through all the data points 20 times, it looks like my accuracy is above 99% on the training data. And here's where I tested it on a whole bunch of testing data. And it looks like in this case, I was also like 99.8% accurate. So just using that, I was able to generate a neural network that can detect counterfeit bills from authentic bills based on this input data 99.8% of the time, at least based on this particular testing data. And I might want to test it with more data as well, just to be confident about that. But this is really the value of using a machine learning library like TensorFlow. And there are others available for Python and other languages as well. But all I have to do is define the structure of the network and define the data that I'm going to pass into the network. And then TensorFlow runs the backpropagation algorithm for learning what all of those weights should be, for figuring out how to train this neural network to be able to accurately, as accurately as possible, figure out what the output values should be there as well. And so this then was a look at what it is that neural networks can do just using these sequences of layer after layer after layer. And you can begin to imagine applying these to much more general problems. And one big problem in computing and artificial intelligence more generally is the problem of computer vision. Computer vision is all about computational methods for analyzing and understanding images. You might have pictures that you want the computer to figure out how to deal with, how to process those images and figure out how to produce some sort of useful result out of this. You've seen this in the context of social media websites that are able to look at a photo that contains a whole bunch of faces. And it's able to figure out what's a picture of whom and label those and tag them with appropriate people. This is becoming increasingly relevant as we begin to discuss self-driving cars, that these cars now have cameras. And we would like for the computer to have some sort of algorithm that looks at the image and figures out what color is the light, what cars are around us and in what direction, for example. And so computer vision is all about taking an image and figuring out what sort of computation, what sort of calculation we can do with that image. It's also relevant in the context of something like handwriting recognition. This, what you're looking at, is an example of the MNIST data set. It's a big data set just of handwritten digits that we could use to ideally try and figure out how to predict, given someone's handwriting, given a photo of a digit that they have drawn, can you predict whether it's a 0, 1, 2, 3, 4, 5, 6, 7, 8, or 9, for example. So this sort of handwriting recognition is yet another task that we might want to use computer vision tasks and tools to be able to apply it towards. This might be a task that we might care about. So how, then, can we use neural networks to be able to solve a problem like this? Well, neural networks rely upon some sort of input where that input is just numerical data. We have a whole bunch of units where each one of them just represents some sort of number. And so in the context of something like handwriting recognition or in the context of just an image, you might imagine that an image is really just a grid of pixels, grid of dots where each dot has some sort of color. And in the context of something like handwriting recognition, you might imagine that if you just fill in each of these dots in a particular way, you can generate a 2 or an 8, for example, based on which dots happen to be shaded in and which dots are not. And we can represent each of these pixel values just using numbers. So for a particular pixel, for example, 0 might represent entirely black. Depending on how you're representing color, it's often common to represent color values on a 0 to 255 range so that you can represent a color using 8 bits for a particular value, like how much white is in the image. So 0 might represent all black. 255 might represent entirely white as a pixel. And somewhere in between might represent some shade of gray, for example. But you might imagine not just having a single slider that determines how much white is in the image, but if you had a color image, you might imagine three different numerical values, a red, green, and blue value, where the red value controls how much red is in the image. We have one value for controlling how much green is in the pixel and one value for how much blue is in the pixel as well. And depending on how it is that you set these values of red, green, and blue, you can get a different color. And so any pixel can really be represented, in this case, by three numerical values, a red value, a green value, and a blue value. And if you take a whole bunch of these pixels, assemble them together inside of a grid of pixels, then you really just have a whole bunch of numerical values that you can use in order to perform some sort of prediction task. And so what you might imagine doing is using the same techniques we talked about before, just design a neural network with a lot of inputs, that for each of the pixels, we might have one or three different inputs in the case of a color image, a different input that is just connected to a deep neural network, for example. And this deep neural network might take all of the pixels inside of the image of what digit a person drew. And the output might be like 10 neurons that classify it as a 0, or a 1, or a 2, or a 3, or just tells us in some way what that digit happens to be. Now, there are a couple of drawbacks to this approach. The first drawback to the approach is just the size of this input array, that we have a whole bunch of inputs. If we have a big image that has a lot of different channels, we're looking at a lot of inputs, and therefore a lot of weights that we have to calculate. And a second problem is the fact that by flattening everything into just this structure of all the pixels, we've lost access to a lot of the information about the structure of the image that's relevant, that really, when a person looks at an image, they're looking at particular features of the image. They're looking at curves. They're looking at shapes. They're looking at what things can you identify in different regions of the image, and maybe put those things together in order to get a better picture of what the overall image is about. And by just turning it into pixel values for each of the pixels, sure, you might be able to learn that structure, but it might be challenging in order to do so. It might be helpful to take advantage of the fact that you can use properties of the image itself, the fact that it's structured in a particular way, to be able to improve the way that we learn based on that image too. So in order to figure out how we can train our neural networks to better be able to deal with images, we'll introduce a couple of ideas, a couple of algorithms that we can apply that allow us to take the image and extract some useful information out of that image. And the first idea we'll introduce is the notion of image convolution. And what image convolution is all about is it's about filtering an image, sort of extracting useful or relevant features out of the image. And the way we do that is by applying a particular filter that basically adds the value for every pixel with the values for all of the neighboring pixels to it, according to some sort of kernel matrix, which we'll see in a moment, is going to allow us to weight these pixels in various different ways. And the goal of image convolution, then, is to extract some sort of interesting or useful features out of an image, to be able to take a pixel and, based on its neighboring pixels, maybe predict some sort of valuable information. Something like taking a pixel and looking at its neighboring pixels, you might be able to predict whether or not there's some sort of curve inside the image, or whether it's forming the outline of a particular line or a shape, for example. And that might be useful if you're trying to use all of these various different features to combine them to say something meaningful about an image as a whole. So how, then, does image convolution work? Well, we start with a kernel matrix. And the kernel matrix looks something like this. And the idea of this is that, given a pixel that will be the middle pixel, we're going to multiply each of the neighboring pixels by these values in order to get some sort of result by summing up all the numbers together. So if I take this kernel, which you can think of as a filter that I'm going to apply to the image, and let's say that I take this image. This is a 4 by 4 image. We'll think of it as just a black and white image, where each one is just a single pixel value. So somewhere between 0 and 255, for example. So we have a whole bunch of individual pixel values like this. And what I'd like to do is apply this kernel, this filter, so to speak, to this image. And the way I'll do that is, all right, the kernel is 3 by 3. You can imagine a 5 by 5 kernel or a larger kernel, too. And I'll take it and just first apply it to the first 3 by 3 section of the image. And what I'll do is I'll take each of these pixel values, multiply it by its corresponding value in the filter matrix, and add all of the results together. So here, for example, I'll say 10 times 0, plus 20 times negative 1, plus 30 times 0, so on and so forth, doing all of this calculation. And at the end, if I take all these values, multiply them by their corresponding value in the kernel, add the results together, for this particular set of 9 pixels, I get the value of 10, for example. And then what I'll do is I'll slide this 3 by 3 grid, effectively, over. I'll slide the kernel by 1 to look at the next 3 by 3 section. Here, I'm just sliding it over by 1 pixel. But you might imagine a different stride length, or maybe I jump by multiple pixels at a time if you really wanted to. You have different options here. But here, I'm just sliding over, looking at the next 3 by 3 section. And I'll do the same math, 20 times 0, plus 30 times negative 1, plus 40 times 0, plus 20 times negative 1, so on and so forth, plus 30 times 5. And what I end up getting is the number 20. Then you can imagine shifting over to this one, doing the same thing, calculating the number 40, for example, and then doing the same thing here, and calculating a value there as well. And so what we have now is what we'll call a feature map. We have taken this kernel, applied it to each of these various different regions, and what we get is some representation of a filtered version of that image. And so to give a more concrete example of why it is that this kind of thing could be useful, let's take this kernel matrix, for example, which is quite a famous one, that has an 8 in the middle, and then all of the neighboring pixels get a negative 1. And let's imagine we wanted to apply that to a 3 by 3 part of an image that looks like this, where all the values are the same. They're all 20, for instance. Well, in this case, if you do 20 times 8, and then subtract 20, subtract 20, subtract 20 for each of the eight neighbors, well, the result of that is you just get that expression, which comes out to be 0. You multiplied 20 by 8, but then you subtracted 20 eight times, according to that particular kernel. The result of all that is just 0. So the takeaway here is that when a lot of the pixels are the same value, we end up getting a value close to 0. If, though, we had something like this, 20 is along this first row, then 50 is in the second row, and 50 is in the third row, well, then when you do this, because it's the same kind of math, 20 times negative 1, 20 times negative 1, so on and so forth, then I get a higher value, a value like 90 in this particular case. And so the more general idea here is that by applying this kernel, negative 1s, 8 in the middle, and then negative 1s, what I get is when this middle value is very different from the neighboring values, like 50 is greater than these 20s, then you'll end up with a value higher than 0. If this number is higher than its neighbors, you end up getting a bigger output. But if this value is the same as all of its neighbors, then you get a lower output, something like 0. And it turns out that this sort of filter can therefore be used in something like detecting edges in an image. Or I want to detect the boundaries between various different objects inside of an image. I might use a filter like this, which is able to tell whether the value of this pixel is different from the values of the neighboring pixel, if it's greater than the values of the pixels that happen to surround it. And so we can use this in terms of image filtering. And so I'll show you an example of that. I have here in filter.py a file that uses Python's image library, or PIL, to do some image filtering. I go ahead and open an image. And then all I'm going to do is apply a kernel to that image. It's going to be a 3 by 3 kernel, same kind of kernel we saw before. And here is the kernel. This is just a list representation of the same matrix that I showed you a moment ago. It's negative 1, negative 1, negative 1. The second row is negative 1, 8, negative 1. And the third row is all negative 1s. And then at the end, I'm going to go ahead and show the filtered image. So if, for example, I go into convolution directory and I open up an image, like bridge.png, this is what an input image might look like, just an image of a bridge over a river. Now I'm going to go ahead and run this filter program on the bridge. And what I get is this image here. Just by taking the original image and applying that filter to each 3 by 3 grid, I've extracted all of the boundaries, all of the edges inside the image that separate one part of the image from another. So here I've got a representation of boundaries between particular parts of the image. And you might imagine that if a machine learning algorithm is trying to learn what an image is of, a filter like this could be pretty useful. Maybe the machine learning algorithm doesn't care about all of the details of the image. It just cares about certain useful features. It cares about particular shapes that are able to help it determine that based on the image, this is going to be a bridge, for example. And so this type of idea of image convolution can allow us to apply filters to images that allow us to extract useful results out of those images, taking an image and extracting its edges, for example. And you might imagine many other filters that could be applied to an image that are able to extract particular values as well. And a filter might have separate kernels for the red values, the green values, and the blue values that are all summed together at the end, such that you could have particular filters looking for, is there red in this part of the image? Are there green in other parts of the image? You can begin to assemble these relevant and useful filters that are able to do these calculations as well. So that then was the idea of image convolution, applying some sort of filter to an image to be able to extract some useful features out of that image. But all the while, these images are still pretty big. There's a lot of pixels involved in the image. And realistically speaking, if you've got a really big image, that poses a couple of problems. One, it means a lot of input going into the neural network. But two, it also means that we really have to care about what's in each particular pixel. Whereas realistically, we often, if you're looking at an image, you don't care whether something is in one particular pixel versus the pixel immediately to the right of it. They're pretty close together. You really just care about whether there's a particular feature in some region of the image. And maybe you don't care about exactly which pixel it happens to be in. And so there's a technique we can use known as pooling. And what pooling is, is it means reducing the size of an input by sampling from regions inside of the input. So we're going to take a big image and turn it into a smaller image by using pooling. And in particular, one of the most popular types of pooling is called max pooling. And what max pooling does is it pools just by choosing the maximum value in a particular region. So for example, let's imagine I had this 4 by 4 image. But I wanted to reduce its dimensions. I wanted to make it a smaller image so that I have fewer inputs to work with. Well, what I could do is I could apply a 2 by 2 max pool, where the idea would be that I'm going to first look at this 2 by 2 region and say, what is the maximum value in that region? Well, it's the number 50. So we'll go ahead and just use the number 50. And then we'll look at this 2 by 2 region. What is the maximum value here? It's 110, so that's going to be my value. Likewise here, the maximum value looks like 20. Go ahead and put that there. Then for this last region, the maximum value was 40. So we'll go ahead and use that. And what I have now is a smaller representation of this same original image that I obtained just by picking the maximum value from each of these regions. So again, the advantages here are now I only have to deal with a 2 by 2 input instead of a 4 by 4. And you can imagine shrinking the size of an image even more. But in addition to that, I'm now able to make my analysis independent of whether a particular value was in this pixel or this pixel. I don't care if the 50 was here or here. As long as it was generally in this region, I'll still get access to that value. So it makes our algorithms a little bit more robust as well. So that then is pooling, taking the size of the image, reducing it a little bit by just sampling from particular regions inside of the image. And now we can put all of these ideas together, pooling, image convolution, and neural networks all together into another type of neural network called a convolutional neural network, or a CNN, which is a neural network that uses this convolution step usually in the context of analyzing an image, for example. And so the way that a convolutional neural network works is that we start with some sort of input image, some grid of pixels. But rather than immediately put that into the neural network layers that we've seen before, we'll start by applying a convolution step, where the convolution step involves applying some number of different image filters to our original image in order to get what we call a feature map, the result of applying some filter to an image. And we could do this once, but in general, we'll do this multiple times, getting a whole bunch of different feature maps, each of which might extract some different relevant feature out of the image, some different important characteristic of the image that we might care about using in order to calculate what the result should be. And in the same way that when we train neural networks, we can train neural networks to learn the weights between particular units inside of the neural networks, we can also train neural networks to learn what those filters should be, what the values of the filters should be in order to get the most useful, most relevant information out of the original image just by figuring out what setting of those filter values, the values inside of that kernel, results in minimizing the loss function, minimizing how poorly our hypothesis actually performs in figuring out the classification of a particular image, for example. So we first apply this convolution step, get a whole bunch of these various different feature maps. But these feature maps are quite large. There's a lot of pixel values that happen to be here. And so a logical next step to take is a pooling step, where we reduce the size of these images by using max pooling, for example, extracting the maximum value from any particular region. There are other pooling methods that exist as well, depending on the situation. You could use something like average pooling, where instead of taking the maximum value from a region, you take the average value from a region, which has its uses as well. But in effect, what pooling will do is it will take these feature maps and reduce their dimensions so that we end up with smaller grids with fewer pixels. And this then is going to be easier for us to deal with. It's going to mean fewer inputs that we have to worry about. And it's also going to mean we're more resilient, more robust against potential movements of particular values, just by one pixel, when ultimately we really don't care about those one-pixel differences that might arise in the original image. And now, after we've done this pooling step, now we have a whole bunch of values that we can then flatten out and just put into a more traditional neural network. So we go ahead and flatten it, and then we end up with a traditional neural network that has one input for each of these values in each of these resulting feature maps after we do the convolution and after we do the pooling step. And so this then is the general structure of a convolutional network. We begin with the image, apply convolution, apply pooling, flatten the results, and then put that into a more traditional neural network that might itself have hidden layers. You can have deep convolutional networks that have hidden layers in between this flattened layer and the eventual output to be able to calculate various different features of those values. But this then can help us to be able to use convolution and pooling to use our knowledge about the structure of an image to be able to get better results, to be able to train our networks faster in order to better capture particular parts of the image. And there's no reason necessarily why you can only use these steps once. In fact, in practice, you'll often use convolution and pooling multiple times in multiple different steps. See, what you might imagine doing is starting with an image, first applying convolution to get a whole bunch of maps, then applying pooling, then applying convolution again, because these maps are still pretty big. You can apply convolution to try and extract relevant features out of this result. Then take those results, apply pooling in order to reduce their dimensions, and then take that and feed it into a neural network that maybe has fewer inputs. So here I have two different convolution and pooling steps. I do convolution and pooling once, and then I do convolution and pooling a second time, each time extracting useful features from the layer before it, each time using pooling to reduce the dimensions of what you're ultimately looking at. And the goal now of this sort of model is that in each of these steps, you can begin to learn different types of features of the original image. That maybe in the first step, you learn very low level features. Just learn and look for features like edges and curves and shapes, because based on pixels and their neighboring values, you can figure out, all right, what are the edges? What are the curves? What are the various different shapes that might be present there? But then once you have a mapping that just represents where the edges and curves and shapes happen to be, you can imagine applying the same sort of process again to begin to look for higher level features, look for objects, maybe look for people's eyes and facial recognition, for example. Maybe look for more complex shapes like the curves on a particular number if you're trying to recognize a digit in a handwriting recognition sort of scenario. And then after all of that, now that you have these results that represent these higher level features, you can pass them into a neural network, which is really just a deep neural network that looks like this, where you might imagine making a binary classification or classifying into multiple categories or performing various different tasks on this sort of model. So convolutional neural networks can be quite powerful and quite popular when it comes towards trying to analyze images. We don't strictly need them. We could have just used a vanilla neural network that just operates with layer after layer, as we've seen before. But these convolutional neural networks can be quite helpful, in particular, because of the way they model the way a human might look at an image, that instead of a human looking at every single pixel simultaneously and trying to convolve all of them by multiplying them together, you might imagine that what convolution is really doing is looking at various different regions of the image and extracting relevant information and features out of those parts of the image, the same way that a human might have visual receptors that are looking at particular parts of what they see and using those combining them to figure out what meaning they can draw from all of those various different inputs. And so you might imagine applying this to a situation like handwriting recognition. So we'll go ahead and see an example of that now, where I'll go ahead and open up handwriting.py. Again, what we do here is we first import TensorFlow. And then TensorFlow, it turns out, has a few data sets that are built into the library that you can just immediately access. And one of the most famous data sets in machine learning is the MNIST data set, which is just a data set of a whole bunch of samples of people's handwritten digits. I showed you a slide of that a little while ago. And what we can do is just immediately access that data set which is built into the library so that if I want to do something like train on a whole bunch of handwritten digits, I can just use the data set that is provided to me. Of course, if I had my own data set of handwritten images, I can apply the same idea. I'd first just need to take those images and turn them into an array of pixels, because that's the way that these are going to be formatted. They're going to be formatted as, effectively, an array of individual pixels. Now there's a bit of reshaping I need to do, just turning the data into a format that I can put into my convolutional neural network. So this is doing things like taking all the values and dividing them by 255. If you remember, these color values tend to range from 0 to 255. So I can divide them by 255 just to put them into 0 to 1 range, which might be a little bit easier to train on. And then doing various other modifications to the data just to get it into a nice usable format. But here's the interesting and important part. Here is where I create the convolutional neural network, the CNN, where here I'm saying, go ahead and use a sequential model. And before I could use model.add to say add a layer, add a layer, add a layer, another way I could define it is just by passing as input to this sequential neural network a list of all of the layers that I want. And so here, the very first layer in my model is a convolution layer, where I'm first going to apply convolution to my image. I'm going to use 13 different filters. So my model is going to learn 32, rather, 32 different filters that I would like to learn on the input image, where each filter is going to be a 3 by 3 kernel. So we saw those 3 by 3 kernels before, where we could multiply each value in a 3 by 3 grid by a value, multiply it, and add all the results together. So here, I'm going to learn 32 different of these 3 by 3 filters. I can, again, specify my activation function. And I specify what my input shape is. My input shape in the banknotes case was just 4. I had 4 inputs. My input shape here is going to be 28, 28, 1, because for each of these handwritten digits, it turns out that the MNIST data set organizes their data. Each image is a 28 by 28 pixel grid. So we're going to have a 28 by 28 pixel grid. And each one of those images only has one channel value. These handwritten digits are just black and white. So there's just a single color value representing how much black or how much white. You might imagine that in a color image, if you were doing this sort of thing, you might have three different channels, a red, a green, and a blue channel, for example. But in the case of just handwriting recognition, recognizing a digit, we're just going to use a single value for, like, shaded in or not shaded in. And it might range, but it's just a single color value. And that, then, is the very first layer of our neural network, a convolutional layer that will take the input and learn a whole bunch of different filters that we can apply to the input to extract meaningful features. Next step is going to be a max pooling layer, also built right into TensorFlow, where this is going to be a layer that is going to use a pool size of 2 by 2, meaning we're going to look at 2 by 2 regions inside of the image and just extract the maximum value. Again, we've seen why this can be helpful. It'll help to reduce the size of our input. And once we've done that, we'll go ahead and flatten all of the units just into a single layer that we can then pass into the rest of the neural network. And now, here's the rest of the neural network. Here, I'm saying, let's add a hidden layer to my neural network with 128 units, so a whole bunch of hidden units inside of the hidden layer. And just to prevent overfitting, I can add a dropout to that. Say, you know what, when you're training, randomly dropout half of the nodes from this hidden layer just to make sure we don't become over-reliant on any particular node, we begin to really generalize and stop ourselves from overfitting. So TensorFlow allows us, just by adding a single line, to add dropout into our model as well, such that when it's training, it will perform this dropout step in order to help make sure that we don't overfit on this particular data. And then finally, I add an output layer. The output layer is going to have 10 units, one for each category that I would like to classify digits into, so 0 through 9, 10 different categories. And the activation function I'm going to use here is called the softmax activation function. And in short, what the softmax activation function is going to do is it's going to take the output and turn it into a probability distribution. So ultimately, it's going to tell me, what did we estimate the probability is that this is a 2 versus a 3 versus a 4. And so it will turn it into that probability distribution for me. Next up, I'll go ahead and compile my model and fit it on all of my training data. And then I can evaluate how well the neural network performs. And then I've added to my Python program, if I've provided a command line argument like the name of a file, I'm going to go ahead and save the model to a file. And so this can be quite useful too. Once you've done the training step, which could take some time in terms of taking all the time, going through the data, running back propagation with gradient descent to be able to say, all right, how should we adjust the weight to this particular model? You end up calculating values for these weights, calculating values for these filters. You'd like to remember that information so you can use it later. And so TensorFlow allows us to just save a model to a file, such that later, if we want to use the model we've learned, use the weights that we've learned to make some sort of new prediction, we can just use the model that already exists. So what we're doing here is after we've done all the calculation, we go ahead and save the model to a file, such that we can use it a little bit later. So for example, if I go into digits, I'm going to run handwriting.py. I won't save it this time. We'll just run it and go ahead and see what happens. What will happen is we need to go through the model in order to train on all of these samples of handwritten digits. The MNIST data set gives us thousands and thousands of sample handwritten digits in the same format that we can use in order to train. And so now what you're seeing is this training process. And unlike the banknotes case, where there was much fewer data points, the data was very, very simple, here this data is more complex and this training process takes time. And so this is another one of those cases where when training neural networks, this is why computational power is so important that oftentimes you see people wanting to use sophisticated GPUs in order to more efficiently be able to do this sort of neural network training. It also speaks to the reason why more data can be helpful. The more sample data points you have, the better you can begin to do this training. So here we're going through 60,000 different samples of handwritten digits. And I said we're going to go through them 10 times. We're going to go through the data set 10 times, training each time, hopefully improving upon our weights with every time we run through this data set. And we can see over here on the right what the accuracy is each time we go ahead and run this model, that the first time it looks like we got an accuracy of about 92% of the digits correct based on this training set. We increased that to 96% or 97%. And every time we run this, we're going to see hopefully the accuracy improve as we continue to try and use that gradient descent, that process of trying to run the algorithm, to minimize the loss that we get in order to more accurately predict what the output should be. And what this process is doing is it's learning not only the weights, but it's learning the features to use, the kernel matrix to use when performing that convolution step. Because this is a convolutional neural network, where I'm first performing those convolutions and then doing the more traditional neural network structure, this is going to learn all of those individual steps as well. And so here we see the TensorFlow provides me with some very nice output, telling me about how many seconds are left with each of these training runs that allows me to see just how well we're doing. So we'll go ahead and see how this network performs. It looks like we've gone through the data set seven times. We're going through it an eighth time now. And at this point, the accuracy is pretty high. We saw we went from 92% up to 97%. Now it looks like 98%. And at this point, it seems like things are starting to level out. It's probably a limit to how accurate we can ultimately be without running the risk of overfitting. Of course, with enough nodes, you would just memorize the input and overfit upon them. But we'd like to avoid doing that. And Dropout will help us with this. But now we see we're almost done finishing our training step. We're at 55,000. All right, we finished training. And now it's going to go ahead and test for us on 10,000 samples. And it looks like on the testing set, we were at 98.8% accurate. So we ended up doing pretty well, it seems, on this testing set to see how accurately can we predict these handwritten digits. And so what we could do then is actually test it out. I've written a program called Recognition.py using PyGame. If you pass it a model that's been trained, and I pre-trained an example model using this input data, what we can do is see whether or not we've been able to train this convolutional neural network to be able to predict handwriting, for example. So I can try, just like drawing a handwritten digit. I'll go ahead and draw the number 2, for example. So there's my number 2. Again, this is messy. If you tried to imagine, how would you write a program with just ifs and thens to be able to do this sort of calculation, it would be tricky to do so. But here I'll press Classify, and all right, it seems I was able to correctly classify that what I drew was the number 2. I'll go ahead and reset it, try it again. We'll draw an 8, for example. So here is an 8. Press Classify. And all right, it predicts that the digit that I drew was an 8. And the key here is this really begins to show the power of what the neural network is doing, somehow looking at various different features of these different pixels, figuring out what the relevant features are, and figuring out how to combine them to get a classification. And this would be a difficult task to provide explicit instructions to the computer on how to do, to use a whole bunch of ifs ands to process all these pixel values to figure out what the handwritten digit is. Everyone's going to draw their 8s a little bit differently. If I drew the 8 again, it would look a little bit different. And yet, ideally, we want to train a network to be robust enough so that it begins to learn these patterns on its own. All I said was, here is the structure of the network, and here is the data on which to train the network. And the network learning algorithm just tries to figure out what is the optimal set of weights, what is the optimal set of filters to use them in order to be able to accurately classify a digit into one category or another. Just going to show the power of these sorts of convolutional neural networks. And so that then was a look at how we can use convolutional neural networks to begin to solve problems with regards to computer vision, the ability to take an image and begin to analyze it. So this is the type of analysis you might imagine that's happening in self-driving cars that are able to figure out what filters to apply to an image to understand what it is that the computer is looking at, or the same type of idea that might be applied to facial recognition and social media to be able to determine how to recognize faces in an image as well. You can imagine a neural network that instead of classifying into one of 10 different digits could instead classify like, is this person A or is this person B, trying to tell those people apart just based on convolution. And so now what we'll take a look at is yet another type of neural network that can be quite popular for certain types of tasks. But to do so, we'll try to generalize and think about our neural network a little bit more abstractly. That here we have a sample deep neural network where we have this input layer, a whole bunch of different hidden layers that are performing certain types of calculations, and then an output layer here that just generates some sort of output that we care about calculating. But we could imagine representing this a little more simply like this. Here is just a more abstract representation of our neural network. We have some input that might be like a vector of a whole bunch of different values as our input. That gets passed into a network that performs some sort of calculation or computation, and that network produces some sort of output. That output might be a single value. It might be a whole bunch of different values. But this is the general structure of the neural network that we've seen. There is some sort of input that gets fed into the network. And using that input, the network calculates what the output should be. And this sort of model for a neural network is what we might call a feed-forward neural network. Feed-forward neural networks have connections only in one direction. They move from one layer to the next layer to the layer after that, such that the inputs pass through various different hidden layers and then ultimately produce some sort of output. So feed-forward neural networks were very helpful for solving these types of classification problems that we saw before. We have a whole bunch of input. We want to learn what setting of weights will allow us to calculate the output effectively. But there are some limitations on feed-forward neural networks that we'll see in a moment. In particular, the input needs to be of a fixed shape, like a fixed number of neurons are in the input layer. And there's a fixed shape for the output, like a fixed number of neurons in the output layer. And that has some limitations of its own. And a possible solution to this, and we'll see examples of the types of problems we can solve for this in just a second, is instead of just a feed-forward neural network, where there are only connections in one direction from left to right effectively across the network, we could also imagine a recurrent neural network, where a recurrent neural network generates output that gets fed back into itself as input for future runs of that network. So whereas in a traditional neural network, we have inputs that get fed into the network, that get fed into the output. And the only thing that determines the output is based on the original input and based on the calculation we do inside of the network itself. This goes in contrast with a recurrent neural network, where in a recurrent neural network, you can imagine output from the network feeding back to itself into the network again as input for the next time you do the calculations inside of the network. What this allows is it allows the network to maintain some sort of state, to store some sort of information that can be used on future runs of the network. Previously, the network just defined some weights, and we passed inputs through the network, and it generated outputs. But the network wasn't saving any information based on those inputs to be able to remember for future iterations or for future runs. What a recurrent neural network will let us do is let the network store information that gets passed back in as input to the network again the next time we try and perform some sort of action. And this is particularly helpful when dealing with sequences of data. So we'll see a real world example of this right now, actually. Microsoft has developed an AI known as the caption bot. And what the caption bot does is it says, I can understand the content of any photograph, and I'll try to describe it as well as any human. I'll analyze your photo, but I won't store it or share it. And so what Microsoft's caption bot seems to be claiming to do is it can take an image and figure out what's in the image and just give us a caption to describe it. So let's try it out. Here, for example, is an image of Harvard Square. It's some people walking in front of one of the buildings at Harvard Square. I'll go ahead and take the URL for that image, and I'll paste it into caption bot and just press Go. So caption bot is analyzing the image, and then it says, I think it's a group of people walking in front of a building, which seems amazing. The AI is able to look at this image and figure out what's in the image. And the important thing to recognize here is that this is no longer just a classification task. We saw being able to classify images with a convolutional neural network where the job was take the image and then figure out, is it a 0 or a 1 or a 2, or is it this person's face or that person's face? What seems to be happening here is the input is an image, and we know how to get networks to take input of images, but the output is text. It's a sentence. It's a phrase, like a group of people walking in front of a building. And this would seem to pose a challenge for our more traditional feed-forward neural networks, for the reason being that in traditional neural networks, we just have a fixed-size input and a fixed-size output. There are a certain number of neurons in the input to our neural network and a certain number of outputs for our neural network, and then some calculation that goes on in between. But the size of the inputs and the number of values in the input and the number of values in the output, those are always going to be fixed based on the structure of the neural network. And that makes it difficult to imagine how a neural network could take an image like this and say it's a group of people walking in front of the building because the output is text, like it's a sequence of words. Now, it might be possible for a neural network to output one word, one word you could represent as a vector of values, and you can imagine ways of doing that. Next time, we'll talk a little bit more about AI as it relates to language and language processing. But a sequence of words is much more challenging because depending on the image, you might imagine the output is a different number of words. We could have sequences of different lengths, and somehow we still want to be able to generate the appropriate output. And so the strategy here is to use a recurrent neural network, a neural network that can feed its own output back into itself as input for the next time. And this allows us to do what we call a one-to-many relationship for inputs to outputs, that in vanilla, more traditional neural networks, these are what we might consider to be one-to-one neural networks. You pass in one set of values as input. You get one vector of values as the output. But in this case, we want to pass in one value as input, the image, and we want to get a sequence, many values as output, where each value is like one of these words that gets produced by this particular algorithm. And so the way we might do this is we might imagine starting by providing input, the image, into our neural network. And the neural network is going to generate output, but the output is not going to be the whole sequence of words, because we can't represent the whole sequence of words using just a fixed set of neurons. Instead, the output is just going to be the first word. We're going to train the network to output what the first word of the caption should be. And you could imagine that Microsoft has trained this by running a whole bunch of training samples through the AI, giving it a whole bunch of pictures and what the appropriate caption was, and having the AI begin to learn from that. But now, because the network generates output that can be fed back into itself, you could imagine the output of the network being fed back into the same network. This here looks like a separate network, but it's really the same network that's just getting different input, that this network's output gets fed back into itself, but it's going to generate another output. And that other output is going to be the second word in the caption. And this recurrent neural network then, this network is going to generate other output that can be fed back into itself to generate yet another word, fed back into itself to generate another word. And so recurrent neural networks allow us to represent this one-to-many structure. You provide one image as input, and the neural network can pass data into the next run of the network, and then again and again, such that you could run the network multiple times, each time generating a different output still based on that original input. And this is where recurrent neural networks become particularly useful when dealing with sequences of inputs or outputs. And my output is a sequence of words, and since I can't very easily represent outputting an entire sequence of words, I'll instead output that sequence one word at a time by allowing my network to pass information about what still needs to be said about the photo into the next stage of running the network. So you could run the network multiple times, the same network with the same weights, just getting different input each time. First, getting input from the image, and then getting input from the network itself as additional information about what additionally needs to be given in a particular caption, for example. So this then is a one-to-many relationship inside of a recurrent neural network, but it turns out there are other models that we can use, other ways we can try and use recurrent neural networks to be able to represent data that might be stored in other forms as well. We saw how we could use neural networks in order to analyze images in the context of convolutional neural networks that take an image, figure out various different properties of the image, and are able to draw some sort of conclusion based on that. But you might imagine that something like YouTube, they need to be able to do a lot of learning based on video. They need to look through videos to detect if they're like copyright violations, or they need to be able to look through videos to maybe identify what particular items are inside of the video, for example. And video, you might imagine, is much more difficult to put in as input to a neural network, because whereas an image, you could just treat each pixel as a different value, videos are sequences. They're sequences of images, and each sequence might be of different length. And so it might be challenging to represent that entire video as a single vector of values that you could pass in to a neural network. And so here, too, recurrent neural networks can be a valuable solution for trying to solve this type of problem. Then instead of just passing in a single input into our neural network, we could pass in the input one frame at a time, you might imagine. First, taking the first frame of the video, passing it into the network, and then maybe not having the network output anything at all yet. Let it take in another input, and this time, pass it into the network. But the network gets information from the last time we provided an input into the network. Then we pass in a third input, and then a fourth input, where each time, what the network gets is it gets the most recent input, like each frame of the video. But it also gets information the network processed from all of the previous iterations. So on frame number four, you end up getting the input for frame number four plus information the network has calculated from the first three frames. And using all of that data combined, this recurrent neural network can begin to learn how to extract patterns from a sequence of data as well. And so you might imagine, if you want to classify a video into a number of different genres, like an educational video, or a music video, or different types of videos, that's a classification task, where you want to take as input each of the frames of the video, and you want to output something like what it is, what category that it happens to belong to. And you can imagine doing this sort of thing, this sort of many-to-one learning, any time your input is a sequence. And so input is a sequence in the context of video. It could be in the context of, like, if someone has typed a message and you want to be able to categorize that message, like if you're trying to take a movie review and trying to classify it as, is it a positive review or a negative review? That input is a sequence of words, and the output is a classification, positive or negative. There, too, a recurrent neural network might be helpful for analyzing sequences of words. And they're quite popular when it comes to dealing with language. Could even be used for spoken language as well, that spoken language is an audio waveform that can be segmented into distinct chunks. And each of those could be passed in as an input into a recurrent neural network to be able to classify someone's voice, for instance. If you want to do voice recognition to say, is this one person or is this another, here are also cases where you might want this many-to-one architecture for a recurrent neural network. And then as one final problem, just to take a look at in terms of what we can do with these sorts of networks, imagine what Google Translate is doing. So what Google Translate is doing is it's taking some text written in one language and converting it into text written in some other language, for example, where now this input is a sequence of data. It's a sequence of words. And the output is a sequence of words as well. It's also a sequence. So here we want effectively a many-to-many relationship. Our input is a sequence and our output is a sequence as well. And it's not quite going to work to just say, take each word in the input and translate it into a word in the output. Because ultimately, different languages put their words in different orders. And maybe one language uses two words for something, whereas another language only uses one. So we really want some way to take this information, this input, encode it somehow, and use that encoding to generate what the output ultimately should be. And this has been one of the big advancements in automated translation technology, is the ability to use the neural networks to do this instead of older, more traditional methods. And this has improved accuracy dramatically. And the way you might imagine doing this is, again, using a recurrent neural network with multiple inputs and multiple outputs. We start by passing in all the input. Input goes into the network. Another input, like another word, goes into the network. And we do this multiple times, like once for each word in the input that I'm trying to translate. And only after all of that is done does the network now start to generate output, like the first word of the translated sentence, and the next word of the translated sentence, so on and so forth, where each time the network passes information to itself by allowing for this model of giving some sort of state from one run in the network to the next run, assembling information about all the inputs, and then passing in information about which part of the output in order to generate next. And there are a number of different types of these sorts of recurrent neural networks. One of the most popular is known as the long short-term memory neural network, otherwise known as LSTM. But in general, these types of networks can be very, very powerful whenever we're dealing with sequences, whether those are sequences of images or especially sequences of words when it comes towards dealing with natural language. And so that then were just some of the different types of neural networks that can be used to do all sorts of different computations. And these are incredibly versatile tools that can be applied to a number of different domains. We only looked at a couple of the most popular types of neural networks from more traditional feed-forward neural networks, convolutional neural networks, and recurrent neural networks. But there are other types as well. There are adversarial networks where networks compete with each other to try and be able to generate new types of data, as well as other networks that can solve other tasks based on what they happen to be structured and adapted for. And these are very powerful tools in machine learning from being able to very easily learn based on some set of input data and to be able to, therefore, figure out how to calculate some function from inputs to outputs, whether it's input to some sort of classification like analyzing an image and getting a digit or machine translation where the input is in one language and the output is in another. These tools have a lot of applications for machine learning more generally. Next time, we'll look at machine learning and AI in particular in the context of natural language. We talked a little bit about this today, but looking at how it is that our AI can begin to understand natural language and can begin to be able to analyze and do useful tasks with regards to human language, which turns out to be a challenging and interesting task. So we'll see you next time. And welcome back, everybody, to our final class in an introduction to artificial intelligence with Python. Now, so far in this class, we've been taking problems that we want to solve intelligently and framing them in ways that computers are going to be able to make sense of. We've been taking problems and framing them as search problems or constraint satisfaction problems or optimization problems, for example. In essence, we have been trying to communicate about problems in ways that our computer is going to be able to understand. Today, the goal is going to be to get computers to understand the way you and I communicate naturally via our own natural languages, languages like English. But natural language contains a lot of nuance and complexity that's going to make it challenging for computers to be able to understand. So we'll need to explore some new tools and some new techniques to allow computers to make sense of natural language. So what is it exactly that we're trying to get computers to do? Well, they all fall under this general heading of natural language processing, getting computers to work with natural language. And these tasks include tasks like automatic summarization. Given a long text, can we train the computer to be able to come up with a shorter representation of it? Information extraction, getting the computer to pull out relevant facts or details out of some text. Machine translation, like Google Translate, translating some text from one language into another language. Question answering, if you've ever asked a question to your phone or had a conversation with an AI chatbot where you provide some text to the computer, the computer is able to understand that text and then generate some text in response. Text classification, where we provide some text to the computer and the computer assigns it a label, positive or negative, inbox or spam, for example. And there are several other kinds of tasks that all fall under this heading of natural language processing. But before we take a look at how the computer might try to solve these kinds of tasks, it might be useful for us to think about language in general. What are the kinds of challenges that we might need to deal with as we start to think about language and getting a computer to be able to understand it? So one part of language that we'll need to consider is the syntax of language. Syntax is all about the structure of language. Language is composed of individual words. And those words are composed together in some kind of structured whole. And if our computer is going to be able to understand language, it's going to need to understand something about that structure. So let's take a couple of examples. Here, for instance, is a sentence. Just before 9 o'clock, Sherlock Holmes stepped briskly into the room. That sentence is made up of words. And those words together form a structured whole. This is syntactically valid as a sentence. But we could take some of those same words, rearrange them, and come up with a sentence that is not syntactically valid. Here, for example, just before Sherlock Holmes 9 o'clock stepped briskly the room is still composed of valid words. But they're not in any kind of logical whole. This is not a syntactically well-formed sentence. Another interesting challenge is that some sentences will have multiple possible valid structures. Here's a sentence, for example. I saw the man on the mountain with a telescope. And here, this is a valid sentence. But it actually has two different possible structures that lend themselves to two different interpretations and two different meanings. Maybe I, the one doing the seeing, am the one with the telescope. Or maybe the man on the mountain is the one with the telescope. And so natural language is ambiguous. Sometimes the same sentence can be interpreted in multiple ways. And that's something that we'll need to think about as well. And this lends itself to another problem within language that we'll need to think about, which is semantics. While syntax is all about the structure of language, semantics is about the meaning of language. It's not enough for a computer just to know that a sentence is well-structured if it doesn't know what that sentence means. And so semantics is going to concern itself with the meaning of words and the meaning of sentences. So if we go back to that same sentence as before, just before 9 o'clock, Sherlock Holmes stepped briskly into the room, I could come up with another sentence, say the sentence, a few minutes before 9, Sherlock Holmes walked quickly into the room. And those are two different sentences with some of the words the same and some of the words different. But the two sentences have essentially the same meaning. And so ideally, whatever model we build, we'll be able to understand that these two sentences, while different, mean something very similar. Some syntactically well-formed sentences don't mean anything at all. A famous example from linguist Noam Chomsky is the sentence, colorless green ideas sleep furiously. This is a syntactically, structurally well-formed sentence. We've got adjectives modifying a noun, ideas. We've got a verb and an adverb in the correct positions. But when taken as a whole, the sentence doesn't really mean anything. And so if our computers are going to be able to work with natural language and perform tasks in natural language processing, these are some concerns we'll need to think about. We'll need to be thinking about syntax. And we'll need to be thinking about semantics. So how could we go about trying to teach a computer how to understand the structure of natural language? Well, one approach we might take is by starting by thinking about the rules of natural language. Our natural languages have rules. In English, for example, nouns tend to come before verbs. Nouns can be modified by adjectives, for example. And so if only we could formalize those rules, then we could give those rules to a computer, and the computer would be able to make sense of them and understand them. And so let's try to do exactly that. We're going to try to define a formal grammar. Where a formal grammar is some system of rules for generating sentences in a language. This is going to be a rule-based approach to natural language processing. We're going to give the computer some rules that we know about language and have the computer use those rules to make sense of the structure of language. And there are a number of different types of formal grammars. Each one of them has slightly different use cases. But today, we're going to focus specifically on one kind of grammar known as a context-free grammar. So how does the context-free grammar work? Well, here is a sentence that we might want a computer to generate. She saw the city. And we're going to call each of these words a terminal symbol. A terminal symbol, because once our computer has generated the word, there's nothing else for it to generate. Once it's generated the sentence, the computer is done. We're going to associate each of these terminal symbols with a non-terminal symbol that generates it. So here we've got n, which stands for noun, like she or city. We've got v as a non-terminal symbol, which stands for a verb. And then we have d, which stands for determiner. A determiner is a word like the or a or an in English, for example. So each of these non-terminal symbols can generate the terminal symbols that we ultimately care about generating. But how do we know, or how does the computer know which non-terminal symbols are associated with which terminal symbols? Well, to do that, we need some kind of rule. Here are some what we call rewriting rules that have a non-terminal symbol on the left-hand side of an arrow. And on the right side is what that non-terminal symbol can be replaced with. So here we're saying the non-terminal symbol n, again, which stands for noun, could be replaced by any of these options separated by vertical bars. n could be replaced by she or city or car or hairy. d for determiner could be replaced by the a or an and so forth. Each of these non-terminal symbols could be replaced by any of these words. We can also have non-terminal symbols that are replaced by other non-terminal symbols. Here is an interesting rule, np arrow n bar dn. So what does that mean? Well, np stands for a noun phrase. Sometimes when we have a noun phrase in a sentence, it's not just a single word, it could be multiple words. And so here we're saying a noun phrase could be just a noun, or it could be a determiner followed by a noun. So we might have a noun phrase that's just a noun, like she, that's a noun phrase. Or we could have a noun phrase that's multiple words, something like the city also acts as a noun phrase. But in this case, it's composed of two words, a determiner, the, and a noun city. We could do the same for verb phrases. A verb phrase, or VP, might be just a verb, or it might be a verb followed by a noun phrase. So we could have a verb phrase that's just a single word, like the word walked, or we could have a verb phrase that is an entire phrase, something like saw the city, as an entire verb phrase. A sentence, meanwhile, we might then define as a noun phrase followed by a verb phrase. And so this would allow us to generate a sentence like she saw the city, an entire sentence made up of a noun phrase, which is just the word she, and then a verb phrase, which is saw the city, saw which is a verb, and then the city, which itself is also a noun phrase. And so if we could give these rules to a computer explaining to it what non-terminal symbols could be replaced by what other symbols, then a computer could take a sentence and begin to understand the structure of that sentence. And so let's take a look at an example of how we might do that. And to do that, we're going to use a Python library called NLTK, or the Natural Language Toolkit, which we'll see a couple of times today. It contains a lot of helpful features and functions that we can use for trying to deal with and process natural language. So here we'll take a look at how we can use NLTK in order to parse a context-free grammar. So let's go ahead and open up cfg0.py, cfg standing for context-free grammar. And what you'll see in this file is that I first import NLTK, the Natural Language Toolkit. And the first thing I do is define a context-free grammar, saying that a sentence is a noun phrase followed by a verb phrase. I'm defining what a noun phrase is, defining what a verb phrase is, and then giving some examples of what I can do with these non-terminal symbols, D for determiner, N for noun, and V for verb. We're going to use NLTK to parse that grammar. Then we'll ask the user for some input in the form of a sentence and split it into words. And then we'll use this context-free grammar parser to try to parse that sentence and print out the resulting syntax tree. So let's take a look at an example. We'll go ahead and go into my cfg directory, and we'll run cfg0.py. And here I'm asked to type in a sentence. Let's say I type in she walked. And when I do that, I see that she walked is a valid sentence, where she is a noun phrase, and walked is the corresponding verb phrase. I could try to do this with a more complex sentence too. I could do something like she saw the city. And here we see that she is the noun phrase, and then saw the city is the entire verb phrase that makes up this sentence. So that was a very simple grammar. Let's take a look at a slightly more complex grammar. Here is cfg1.py, where a sentence is still a noun phrase followed by a verb phrase, but I've added some other possible non-terminal symbols too. I have AP for adjective phrase and PP for prepositional phrase. And we specified that we could have an adjective phrase before a noun phrase or a prepositional phrase after a noun, for example. So lots of additional ways that we might try to structure a sentence and interpret and parse one of those resulting sentences. So let's see that one in action. We'll go ahead and run cfg1.py with this new grammar. And we'll try a sentence like she saw the wide street. Here, Python's NLTK is able to parse that sentence and identify that she saw the wide street has this particular structure, a sentence with a noun phrase and a verb phrase, where that verb phrase has a noun phrase that within it contains an adjective. And so it's able to get some sense for what the structure of this language actually is. Let's try another example. Let's say she saw the dog with the binoculars. And we'll try that sentence. And here, we get one possible syntax tree, she saw the dog with the binoculars. But notice that this sentence is actually a little bit ambiguous in our own natural language. Who has the binoculars? Is it she who has the binoculars or the dog who has the binoculars? And NLTK is able to identify both possible structures for the sentence. In this case, the dog with the binoculars is an entire noun phrase. It's all underneath this NP here. So it's the dog that has the binoculars. But we also got an alternative parse tree, where the dog is just the noun phrase. And with the binoculars is a prepositional phrase modifying saw. So she saw the dog and she used the binoculars in order to see the dog as well. So this allows us to get a sense for the structure of natural language. But it relies on us writing all of these rules. And it would take a lot of effort to write all of the rules for any possible sentence that someone might write or say in the English language. Language is complicated. And as a result, there are going to be some very complex rules. So what else might we try? We might try to take a statistical lens towards approaching this problem of natural language processing. If we were able to give the computer a lot of existing data of sentences written in the English language, what could we try to learn from that data? Well, it might be difficult to try and interpret long pieces of text all at once. So instead, what we might want to do is break up that longer text into smaller pieces of information instead. In particular, we might try to create n-grams out of a longer sequence of text. An n-gram is just some contiguous sequence of n items from a sample of text. It might be n characters in a row or n words in a row, for example. So let's take a passage from Sherlock Holmes. And let's look for all of the trigrams. A trigram is an n-gram where n is equal to 3. So in this case, we're looking for sequences of three words in a row. So the trigrams here would be phrases like how often have. That's three words in a row. Often have I is another trigram. Have I said, I said to, said to you, to you that. These are all trigrams, sequences of three words that appear in sequence. And if we could give the computer a large corpus of text and have it pull out all of the trigrams in this case, it could get a sense for what sequences of three words tend to appear next to each other in our own natural language and, as a result, get some sense for what the structure of the language actually is. So let's take a look at an example of that. How can we use NLTK to try to get access to information about n-grams? So here, we're going to open up ngrams.py. And this is a Python program that's going to load a corpus of data, just some text files, into our computer's memory. And then we're going to use NLTK's ngrams function, which is going to go through the corpus of text, pulling out all of the ngrams for a particular value of n. And then, by using Python's counter class, we're going to figure out what are the most common ngrams inside of this entire corpus of text. And we're going to need a data set in order to do this. And I've prepared a data set of some of the stories of Sherlock Holmes. So it's just a bunch of text files. A lot of words for it to analyze. And as a result, we'll get a sense for what sequences of two words or three words that tend to be most common in natural language. So let's give this a try. We'll go into my ngrams directory. And we'll run ngrams.py. We'll try an n value of 2. So we're looking for sequences of two words in a row. And we'll use our corpus of stories from Sherlock Holmes. And when we run this program, we get a list of the most common ngrams where n is equal to 2, otherwise known as a bigram. So the most common one is of the. That's a sequence of two words that appears quite frequently in natural language. Then in the. And it was. These are all common sequences of two words that appear in a row. Let's instead now try running ngrams with n equal to 3. Let's get all of the trigrams and see what we get. And now we see the most common trigrams are it was a. One of the. I think that. These are all sequences of three words that appear quite frequently. And we were able to do this essentially via a process known as tokenization. Tokenization is the process of splitting a sequence of characters into pieces. In this case, we're splitting a long sequence of text into individual words and then looking at sequences of those words to get a sense for the structure of natural language. So once we've done this, once we've done the tokenization, once we've built up our corpus of ngrams, what can we do with that information? So the one thing that we might try is we could build a Markov chain, which you might recall from when we talked about probability. Recall that a Markov chain is some sequence of values where we can predict one value based on the values that came before it. And as a result, if we know all of the common ngrams in the English language, what words tend to be associated with what other words in sequence, we can use that to predict what word might come next in a sequence of words. And so we could build a Markov chain for language in order to try to generate natural language that follows the same statistical patterns as some input data. So let's take a look at that and build a Markov chain for natural language. And as input, I'm going to use the works of William Shakespeare. So here I have a file Shakespeare.txt, which is just a bunch of the works of William Shakespeare. It's a long text file, so plenty of data to analyze. And here in generator.py, I'm using a third party Python library in order to do this analysis. We're going to read in the sample of text, and then we're going to train a Markov model based on that text. And then we're going to have the Markov chain generate some sentences. We're going to generate a sentence that doesn't appear in the original text, but that follows the same statistical patterns that's generating it based on the ngrams trying to predict what word is likely to come next that we would expect based on those statistical patterns. So we'll go ahead and go into our Markov directory, run this generator with the works of William Shakespeare's input. And what we're going to get are five new sentences, where these sentences are not necessarily sentences from the original input text itself, but just that follow the same statistical patterns. It's predicting what word is likely to come next based on the input data that we've seen and the types of words that tend to appear in sequence there too. And so we're able to generate these sentences. Of course, so far, there's no guarantee that any of the sentences that are generated actually mean anything or make any sense. They just happen to follow the statistical patterns that our computer is already aware of. So we'll return to this issue of how to generate text in perhaps a more accurate or more meaningful way a little bit later. So let's now turn our attention to a slightly different problem, and that's the problem of text classification. Text classification is the problem where we have some text and we want to put that text into some kind of category. We want to apply some sort of label to that text. And this kind of problem shows up in a wide variety of places. A commonplace might be your email inbox, for example. You get an email and you want your computer to be able to identify whether the email belongs in your inbox or whether it should be filtered out into spam. So we need to classify the text. Is it a good email or is it spam? Another common use case is sentiment analysis. We might want to know whether the sentiment of some text is positive or negative. And so how might we do that? This comes up in situations like product reviews, where we might have a bunch of reviews for a product on some website. My grandson loved it so much fun. Product broke after a few days. One of the best games I've played in a long time and kind of cheap and flimsy, not worth it. Here's some example sentences that you might see on a product review website. And you and I could pretty easily look at this list of product reviews and decide which ones are positive and which ones are negative. We might say the first one and the third one, those seem like positive sentiment messages. But the second one and the fourth one seem like negative sentiment messages. But how did we know that? And how could we train a computer to be able to figure that out as well? Well, you might have clued your eye in on particular key words, where those particular words tend to mean something positive or negative. So you might have identified words like loved and fun and best tend to be associated with positive messages. And words like broke and cheap and flimsy tend to be associated with negative messages. So if only we could train a computer to be able to learn what words tend to be associated with positive versus negative messages, then maybe we could train a computer to do this kind of sentiment analysis as well. So we're going to try to do just that. We're going to use a model known as the bag of words model, which is a model that represents text as just an unordered collection of words. For the purpose of this model, we're not going to worry about the sequence and the ordering of the words, which word came first, second, or third. We're just going to treat the text as a collection of words in no particular order. And we're losing information there, right? The order of words is important. And we'll come back to that a little bit later. But for now, to simplify our model, it'll help us tremendously just to think about text as some unordered collection of words. And in particular, we're going to use the bag of words model to build something known as a naive Bayes classifier. So what is a naive Bayes classifier? Well, it's a tool that's going to allow us to classify text based on Bayes rule, again, which you might remember from when we talked about probability. Bayes rule says that the probability of B given A is equal to the probability of A given B multiplied by the probability of B divided by the probability of A. So how are we going to use this rule to be able to analyze text? Well, what are we interested in? We're interested in the probability that a message has a positive sentiment and the probability that a message has a negative sentiment, which I'm here for simplicity going to represent just with these emoji, happy face and frown face, as positive and negative sentiment. And so if I had a review, something like my grandson loved it, then what I'm interested in is not just the probability that a message has positive sentiment, but the conditional probability that a message has positive sentiment given that this is the message my grandson loved it. But how do I go about calculating this value, the probability that the message is positive given that the review is this sequence of words? Well, here's where the bag of words model comes in. Rather than treat this review as a string of a sequence of words in order, we're just going to treat it as an unordered collection of words. We're going to try to calculate the probability that the review is positive given that all of these words, my grandson loved it, are in the review in no particular order, just this unordered collection of words. And this is a conditional probability, which we can then apply Bayes rule to try to make sense of. And so according to Bayes rule, this conditional probability is equal to what? It's equal to the probability that all of these four words are in the review given that the review is positive multiplied by the probability that the review is positive divided by the probability that all of these words happen to be in the review. So this is the value now that we're going to try to calculate. Now, one thing you might notice is that the denominator here, the probability that all of these words appear in the review, doesn't actually depend on whether or not we're looking at the positive sentiment or negative sentiment case. So we can actually get rid of this denominator. We don't need to calculate it. We can just say that this probability is proportional to the numerator. And then at the end, we're going to need to normalize the probability distribution to make sure that all of the values sum up to the value 1. So now, how do we calculate this value? Well, this is the probability of all of these words given positive times probability of positive. And that, by the definition of joint probability, is just one big joint probability, the probability that all of these things are the case, that it's a positive review, and that all four of these words are in the review. But still, it's not entirely obvious how we calculate that value. And here is where we need to make one more assumption. And this is where the naive part of naive Bayes comes in. We're going to make the assumption that all of the words are independent of each other. And by that, I mean that if the word grandson is in the review, that doesn't change the probability that the word loved is in the review or that the word it is in the review, for example. And in practice, this assumption might not be true. It's almost certainly the case that the probability of words do depend on each other. But it's going to simplify our analysis and still give us reasonably good results just to assume that the words are independent of each other and they only depend on whether it's positive or negative. You might, for example, expect the word loved to appear more often in a positive review than in a negative review. So what does that mean? Well, if we make this assumption, then we can say that this value, the probability we're interested in, is not directly proportional to, but it's naively proportional to this value. The probability that the review is positive times the probability that my is in the review, given that it's positive, times the probability that grandson is in the review, given that it's positive, and so on for the other two words that happen to be in this review. And now this value, which looks a little more complex, is actually a value that we can calculate pretty easily. So how are we going to estimate the probability that the review is positive? Well, if we have some training data, some example data of example reviews where each one has already been labeled as positive or negative, then we can estimate the probability that a review is positive just by counting the number of positive samples and dividing by the total number of samples that we have in our training data. And for the conditional probabilities, the probability of loved, given that it's positive, well, that's going to be the number of positive samples with loved in it divided by the total number of positive samples. So let's take a look at an actual example to see how we could try to calculate these values. Here I've put together some sample data. The way to interpret the sample data is that based on the training data, 49% of the reviews are positive, 51% are negative. And then over here in this table, we have some conditional probabilities. And then we have if the review is positive, then there is a 30% chance that my appears in it. And if the review is negative, there is a 20% chance that my appears in it. And based on our training data among the positive reviews, 1% of them contain the word grandson. And among the negative reviews, 2% contain the word grandson. So using this data, let's try to calculate this value, the value we're interested in. And to do that, we'll need to multiply all of these values together. The probability of positive, and then all of these positive conditional probabilities. And when we do that, we get some value. And then we can do the same thing for the negative case. We're going to do the same thing, take the probability that it's negative, multiply it by all of these conditional probabilities, and we're going to get some other value. And now these values don't sum to one. They're not a probability distribution yet. But I can normalize them and get some values. And that tells me that we're going to predict that my grandson loved it. We think there's a 68% chance, probability 0.68, that that is a positive sentiment review, and 0.32 probability that it's a negative review. So what problems might we run into here? What could potentially go wrong when doing this kind of analysis in order to analyze whether text has a positive or negative sentiment? Well, a couple of problems might arise. One problem might be, what if the word grandson never appears for any of the positive reviews? If that were the case, then when we try to calculate the value, the probability that we think the review is positive, we're going to multiply all these values together, and we're just going to get 0 for the positive case, because we're all going to ultimately multiply by that 0 value. And so we're going to say that we think there is no chance that the review is positive because it contains the word grandson. And in our training data, we've never seen the word grandson appear in a positive sentiment message before. And that's probably not the right analysis, because in cases of rare words, it might be the case that in nowhere in our training data did we ever see the word grandson appear in a message that has positive sentiment. So what can we do to solve this problem? Well, one thing we'll often do is some kind of additive smoothing, where we add some value alpha to each value in our distribution just to smooth out the data a little bit. And a common form of this is Laplace smoothing, where we add 1 to each value in our distribution. In essence, we pretend we've seen each value one more time than we actually have. So if we've never seen the word grandson for a positive review, we pretend we've seen it once. If we've seen it once, we pretend we've seen it twice, just to avoid the possibility that we might multiply by 0 and as a result, get some results we don't want in our analysis. So let's see what this looks like in practice. Let's try to do some naive Bayes classification in order to classify text as either positive or negative. We'll take a look at sentiment.py. And what this is going to do is load some sample data into memory, some examples of positive reviews and negative reviews. And then we're going to train a naive Bayes classifier on all of this training data, training data that includes all of the words we see in positive reviews and all of the words we see in negative reviews. And then we're going to try to classify some input. And so we're going to do this based on a corpus of data. I have some example positive reviews. Here are some positive reviews. It was great, so much fun, for example. And then some negative reviews, not worth it, kind of cheap. These are some examples of negative reviews. So now let's try to run this classifier and see how it would classify particular text as either positive or negative. We'll go ahead and run our sentiment analysis on this corpus. And we need to provide it with a review. So I'll say something like, I enjoyed it. And we see that the classifier says there is about a 0.92 probability that we think that this particular review is positive. Let's try something negative. We'll try kind of overpriced. And we see that there is a 0.96 probability now that we think that this particular review is negative. And so our naive Bayes classifier has learned what kinds of words tend to appear in positive reviews and what kinds of words tend to appear in negative reviews. And as a result of that, we've been able to design a classifier that can predict whether a particular review is positive or negative. And so this definitely is a useful tool that we can use to try and make some predictions. But we had to make some assumptions in order to get there. So what if we want to now try to build some more sophisticated models, use some tools from machine learning to try and take better advantage of language data to be able to draw more accurate conclusions and solve new kinds of tasks and new kinds of problems? Well, we've seen a couple of times now that when we want to take some data and take some input, put it in a way that the computer is going to be able to make sense of, it can be helpful to take that data and turn it into numbers, ultimately. And so what we might want to try to do is come up with some word representation, some way to take a word and translate its meaning into numbers. Because, for example, if we wanted to use a neural network to be able to process language, give our language to a neural network and have it make some predictions or perform some analysis there, a neural network takes its input and produces its output a vector of values, a vector of numbers. And so what we might want to do is take our data and somehow take words and convert them into some kind of numeric representation. So how might we do that? How might we take words and turn them into numbers? Let's take a look at an example. Here's a sentence, he wrote a book. And let's say I wanted to take each of those words and turn it into a vector of values. Here's one way I might do that. We'll say he is going to be a vector that has a 1 in the first position and the rest of the values are 0. Wrote will have a 1 in the second position and the rest of the values are 0. A has a 1 in the third position with the rest of the value 0. And book has a 1 in the fourth position with the rest of the value 0. So each of these words now has a distinct vector representation. And this is what we often call a one-hot representation, a representation of the meaning of a word as a vector with a single 1 and all of the rest of the values are 0. And so when doing this, we now have a numeric representation for every word and we could pass in those vector representations into a neural network or other models that require some kind of numeric data as input. But this one-hot representation actually has a couple of problems and it's not ideal for a few reasons. One reason is, here we're just looking at four words. But if you imagine a vocabulary of thousands of words or more, these vectors are going to get quite long in order to have a distinct vector for every possible word in a vocabulary. And as a result of that, these longer vectors are going to be more difficult to deal with, more difficult to train, and so forth. And so that might be a problem. Another problem is a little bit more subtle. If we want to represent a word as a vector, and in particular the meaning of a word as a vector, then ideally it should be the case that words that have similar meanings should also have similar vector representations, so that they're close to each other together inside a vector space. But that's not really going to be the case with these one-hot representations, because if we take some similar words, say the word wrote and the word authored, which means similar things, they have entirely different vector representations. Likewise, book and novel, those two words mean somewhat similar things, but they have entirely different vector representations because they each have a one in some different position. And so that's not ideal either. So what we might be interested in instead is some kind of distributed representation. A distributed representation is the representation of the meaning of a word distributed across multiple values, instead of just being one-hot with a one in one position. Here is what a distributed representation of words might be. Each word is associated with some vector of values, with the meaning distributed across multiple values, ideally in such a way that similar words have a similar vector representation. But how are we going to come up with those values? Where do those values come from? How can we define the meaning of a word in this distributed sequence of numbers? Well, to do that, we're going to draw inspiration from a quote from British linguist J.R. Firth, who said, you shall know a word by the company it keeps. In other words, we're going to define the meaning of a word based on the words that appear around it, the context words around it. Take, for example, this context, for blank he ate. You might wonder, what words could reasonably fill in that blank? Well, it might be words like breakfast or lunch or dinner. All of those could reasonably fill in that blank. And so what we're going to say is because the words breakfast and lunch and dinner appear in a similar context, that they must have a similar meaning. And that's something our computer could understand and try to learn. A computer could look at a big corpus of text, look at what words tend to appear in similar context to each other, and use that to identify which words have a similar meaning and should therefore appear close to each other inside a vector space. And so one common model for doing this is known as the word to vec model. It's a model for generating word vectors, a vector representation for every word by looking at data and looking at the context in which a word appears. The idea is going to be this. If you start out with all of the words just in some random position in space and train it on some training data, what the word to vec model will do is start to learn what words appear in similar contexts. And it will move these vectors around in such a way that hopefully words with similar meanings, breakfast, lunch, and dinner, book, memoir, novel, will hopefully appear to be near to each other as vectors as well. So let's now take a look at what word to vec might look like in practice when implemented in code. What I have here inside of words.txt is a pre-trained model where each of these words has some vector representation trained by word to vec. Each of these words has some sequence of values representing its meaning, hopefully in such a way that similar words are represented by similar vectors. I also have this file vectors.py, which is going to open up the words and form them into a dictionary. And we also define some useful functions like distance to get the distance between two word vectors and closest words to find which words are nearby in terms of having close vectors to each other. And so let's give this a try. We'll go ahead and open a Python interpreter. And I'm going to import these vectors. And we might say, all right, what is the vector representation of the word book? And we get this big long vector that represents the word book as a sequence of values. And this sequence of values by itself is not all that meaningful. But it is meaningful in the context of comparing it to other vectors for other words. So we could use this distance function, which is going to get us the distance between two word vectors. And we might say, what is the distance between the vector representation for the word book and the vector representation for the word novel? And we see that it's 0.34. You can kind of interpret 0 as being really close together and 1 being very far apart. And so now, what is the distance between book and, let's say, breakfast? Well, book and breakfast are more different from each other than book and novel are. So I would hopefully expect the distance to be larger. And in fact, it is 0.64 approximately. These two words are further away from each other. And what about now the distance between, let's say, lunch and breakfast? Well, that's about 0.2. Those are even closer together. They have a meaning that is closer to each other. Another interesting thing we might do is calculate the closest words. We might say, what are the closest words, according to Word2Vec, to the word book? And let's say, let's get the 10 closest words. What are the 10 closest vectors to the vector representation for the word book? And when we perform that analysis, we get this list of words. The closest one is book itself, but we also have books plural, and then essay, memoir, essays, novella, anthology, and so on. All of these words mean something similar to the word book, according to Word2Vec, at least, because they have a similar vector representation. So it seems like we've done a pretty good job of trying to capture this kind of vector representation of word meaning. One other interesting side effect of Word2Vec is that it's also able to capture something about the relationships between words as well. Let's take a look at an example. Here, for instance, are two words, man and king. And these are each represented by Word2Vec as vectors. So what might happen if I subtracted one from the other, calculated the value king minus man? Well, that will be the vector that will take us from man to king, somehow represent this relationship between the vector representation of the word man and the vector representation of the word king. And that's what this value, king minus man, represents. So what would happen if I took the vector representation of the word woman and added that same value, king minus man, to it? What would we get as the closest word to that, for example? Well, we could try it. Let's go ahead and go back to our Python interpreter and give this a try. I could say, what is the closest word to the vector representation of the word king minus the representation of the word man plus the representation of the word woman? And we see that the closest word is the word queen. We've somehow been able to capture the relationship between king and man. And then when we apply it to the word woman, we get, as the result, the word queen. So Word2Vec has been able to capture not just the words and how they're similar to each other, but also something about the relationships between words and how those words are connected to each other. So now that we have this vector representation of words, what can we now do with it? Now we can represent words as numbers. And so we might try to pass those words as input to, say, a neural network. Neural networks we've seen are very powerful tools for identifying patterns and making predictions. Recall that a neural network you can think of as all of these units. But really what the neural network is doing is taking some input, passing it into the network, and then producing some output. And by providing the neural network with training data, we're able to update the weights inside of the network so that the neural network can do a more accurate job of translating those inputs into those outputs. And now that we can represent words as numbers that could be the input or output, you could imagine passing a word in as input to a neural network and getting a word as output. And so when might that be useful? One common use for neural networks is in machine translation, when we want to translate text from one language into another, say translate English into French by passing English into the neural network and getting some French output. You might imagine, for instance, that we could take the English word for lamp, pass it into the neural network, get the French word for lamp as output. But in practice, when we're translating text from one language to another, we're usually not just interested in translating a single word from one language to another, but a sequence, say a sentence or a paragraph of words. Here, for example, is another paragraph, again taken from Sherlock Holmes, written in English. And what I might want to do is take that entire sentence, pass it into the neural network, and get as output a French translation of the same sentence. But recall that a neural network's input and output needs to be of some fixed size. And a sentence is not a fixed size. It's variable. You might have shorter sentences, and you might have longer sentences. So somehow, we need to solve the problem of translating a sequence into another sequence by means of a neural network. And that's going to be true not only for machine translation, but also for other problems, problems like question answering. If I want to pass as input a question, something like what is the capital of Massachusetts, feed that as input into the neural network, I would hope that what I would get as output is a sentence like the capital is Boston, again, translating some sequence into some other sequence. And if you've ever had a conversation with an AI chatbot, or have ever asked your phone a question, it needs to do something like this. It needs to understand the sequence of words that you, the human, provided as input. And then the computer needs to generate some sequence of words as output. So how can we do this? Well, one tool that we can use is the recurrent neural network, which we took a look at last time, which is a way for us to provide a sequence of values to a neural network by running the neural network multiple times. And each time we run the neural network, what we're going to do is we're going to keep track of some hidden state. And that hidden state is going to be passed from one run of the neural network to the next run of the neural network, keeping track of all of the relevant information. And so let's take a look at how we can apply that to something like this. And in particular, we're going to look at an architecture known as an encoder-decoder architecture, where we're going to encode this question into some kind of hidden state, and then use a decoder to decode that hidden state into the output that we're interested in. So what's that going to look like? We'll start with the first word, the word what. That goes into our neural network, and it's going to produce some hidden state. This is some information about the word what that our neural network is going to need to keep track of. Then when the second word comes along, we're going to feed it into that same encoder neural network, but it's going to get as input that hidden state as well. So we pass in the second word. We also get the information about the hidden state, and that's going to continue for the other words in the input. This is going to produce a new hidden state. And so then when we get to the third word, the, that goes into the encoder. It also gets access to the hidden state, and then it produces a new hidden state that gets passed into the next run when we use the word capital. And the same thing is going to repeat for the other words that appear in the input. So of Massachusetts, that produces one final piece of hidden state. Now somehow, we need to signal the fact that we're done. There's nothing left in the input. And we typically do this by passing some kind of special token, say an end token, into the neural network. And now the decoding process is going to start. We're going to generate the word the. But in addition to generating the word the, this decoder network is also going to generate some kind of hidden state. And so what happens the next time? Well, to generate the next word, it might be helpful to know what the first word was. So we might pass the first word the back into the decoder network. It's going to get as input this hidden state, and it's going to generate the next word capital. And that's also going to generate some hidden state. And we'll repeat that, passing capital into the network to generate the third word is, and then one more time in order to get the fourth word Boston. And at that point, we're done. But how do we know we're done? Usually, we'll do this one more time, pass Boston into the decoder network, and get an output some end token to indicate that that is the end of our input. And so this then is how we could use a recurrent neural network to take some input, encode it into some hidden state, and then use that hidden state to decode it into the output we're interested in. To visualize it in a slightly different way, we have some input sequence. This is just some sequence of words. That input sequence goes into the encoder, which in this case is a recurrent neural network generating these hidden states along the way until we generate some final hidden state, at which point we start the decoding process. Again, using a recurrent neural network, that's going to generate the output sequence as well. So we've got the encoder, which is encoding the information about the input sequence into this hidden state, and then the decoder, which takes that hidden state and uses it in order to generate the output sequence. But there are some problems. And for many years, this was the state of the art. The recurrent neural network and variance on this approach were some of the best ways we knew in order to perform tasks in natural language processing. But there are some problems that we might want to try to deal with and that have been dealt with over the years to try and improve upon this kind of model. And one problem you might notice happens in this encoder stage. We've taken this input sequence, the sequence of words, and encoded it all into this final piece of hidden state. And that final piece of hidden state needs to contain all of the information from the input sequence that we need in order to generate the output sequence. And while that's possible, it becomes increasingly difficult as the sequence gets larger and larger. For larger and larger input sequences, it's going to become more and more difficult to store all of the information we need about the input inside this single hidden state piece of context. That's a lot of information to pack into just a single value. It might be useful for us, when generating output, to not just refer to this one value, but to all of the previous hidden values that have been generated by the encoder. And so that might be useful, but how could we do that? We've got a lot of different values. We need to combine them somehow. So you could imagine adding them together, taking the average of them, for example. But doing that would assume that all of these pieces of hidden state are equally important. But that's not necessarily true either. Some of these pieces of hidden state are going to be more important than others, depending on what word they most closely correspond to. This piece of hidden state very closely corresponds to the first word of the input sequence. This one very closely corresponds to the second word of the input sequence, for example. And some of those are going to be more important than others. To make matters more complicated, depending on which word of the output sequence we're generating, different input words might be more or less important. And so what we really want is some way to decide for ourselves which of the input values are worth paying attention to, at what point in time. And this is the key idea behind a mechanism known as attention. Attention is all about letting us decide which values are important to pay attention to, when generating, in this case, the next word in our sequence. So let's take a look at an example of that. Here's a sentence. What is the capital of Massachusetts? Same sentence as before. And let's imagine that we were trying to answer that question by generating tokens of output. So what would the output look like? Well, it's going to look like something like the capital is. And let's say we're now trying to generate this last word here. What is that last word? How is the computer going to figure it out? Well, what it's going to need to do is decide which values it's going to pay attention to. And so the attention mechanism will allow us to calculate some attention scores for each word, some value corresponding to each word, determining how relevant is it for us to pay attention to that word right now? And in this case, when generating the fourth word of the output sequence, the most important words to pay attention to might be capital and Massachusetts, for example. That those words are going to be particularly relevant. And there are a number of different mechanisms that have been used in order to calculate these attention scores. It could be something as simple as a dot product to see how similar two vectors are, or we could train an entire neural network to calculate these attention scores. But the key idea is that during the training process for our neural network, we're going to learn how to calculate these attention scores. Our model is going to learn what is important to pay attention to in order to decide what the next word should be. So the result of all of this, calculating these attention scores, is that we can calculate some value, some value for each input word, determining how important is it for us to pay attention to that particular value. And recall that each of these input words is also associated with one of these hidden state context vectors, capturing information about the sentence up to that point, but primarily focused on that word in particular. And so what we can now do is if we have all of these vectors and we have values representing how important is it for us to pay attention to those particular vectors, is we can take a weighted average. We can take all of these vectors, multiply them by their attention scores, and add them up to get some new vector value, which is going to represent the context from the input, but specifically paying attention to the words that we think are most important. And once we've done that, that context vector can be fed into our decoder in order to say that the word should be, in this case, Boston. So attention is this very powerful tool that allows any word when we're trying to decode it to decide which words from the input should we pay attention to in order to determine what's important for generating the next word of the output. And one of the first places this was really used was in the field of machine translation. Here's an example of a diagram from the paper that introduced this idea, which was focused on trying to translate English sentences into French sentences. So we have an input English sentence up along the top, and then along the left side, the output French equivalent of that same sentence. And what you see in all of these squares are the attention scores visualized, where a lighter square indicates a higher attention score. And what you'll notice is that there's a strong correspondence between the French word and the equivalent English word, that the French word for agreement is really paying attention to the English word for agreement in order to decide what French word should be generated at that point in time. And sometimes you might pay attention to multiple words if you look at the French word for economic. That's primarily paying attention to the English word for economic, but also paying attention to the English word for European in this case too. And so attention scores are very easy to visualize to get a sense for what is our machine learning model really paying attention to, what information is it using in order to determine what's important and what's not in order to determine what the ultimate output token should be. And so when we combine the attention mechanism with a recurrent neural network, we can get very powerful and useful results where we're able to generate an output sequence by paying attention to the input sequence too. But there are other problems with this approach of using a recurrent neural network as well. In particular, notice that every run of the neural network depends on the output of the previous step. And that was important for getting a sense for the sequence of words and the ordering of those particular words. But we can't run this unit of the neural network until after we've calculated the hidden state from the run before it from the previous input token. And what that means is that it's very difficult to parallelize this process. That as the input sequence get longer and longer, we might want to use parallelism to try and speed up this process of training the neural network and making sense of all of this language data. But it's difficult to do that. And it's slow to do that with a recurrent neural network because all of it needs to be performed in sequence. And that's become an increasing challenge as we've started to get larger and larger language models. The more language data that we have available to us to use to train our machine learning models, the more accurate it can be, the better representation of language it can have, the better understanding it can have, and the better results that we can see. And so we've seen this growth of large language models that are using larger and larger data sets. But as a result, they take longer and longer to train. And so this problem that recurrent neural networks are not easy to parallelize has become an increasing problem. And as a result of that, that was one of the main motivations for a different architecture, for thinking about how to deal with natural language. And that's known as the transformer architecture. And this has been a significant milestone in the world of natural language processing for really increasing how well we can perform these kinds of natural language processing tasks, as well as how quickly we can train a machine learning model to be able to produce effective results. There are a number of different types of transformers in terms of how they work. But what we're going to take a look at here is the basic architecture for how one might work with a transformer to get a sense for what's involved and what we're doing. So let's start with the model we were looking at before, specifically at this encoder part of our encoder-decoder architecture, where we used a recurrent neural network to take this input sequence and capture all of this information about the hidden state and the information we need to know about that input sequence. Right now, it all needs to happen in this linear progression. But what the transformer is going to allow us to do is process each of the words independently in a way that's easy to parallelize, rather than have each word wait for some other word. Each word is going to go through this same neural network and produce some kind of encoded representation of that particular input word. And all of this is going to happen in parallel. Now, it's happening for all of the words at once, but we're really just going to focus on what's happening for one word to make it clear. But know that whatever you're seeing happen for this one word is going to happen for all of the other input words, too. So what's going on here? Well, we start with some input word. That input word goes into the neural network. And the output is hopefully some encoded representation of the input word, the information we need to know about the input word that's going to be relevant to us as we're generating the output. And because we're doing this each word independently, it's easy to parallelize. We don't have to wait for the previous word before we run this word through the neural network. But what did we lose in this process by trying to parallelize this whole thing? Well, we've lost all notion of word ordering. The order of words is important. The sentence, Sherlock Holmes gave the book to Watson, has a different meaning than Watson gave the book to Sherlock Holmes. And so we want to keep track of that information about word position. In the recurrent neural network, that happened for us automatically because we could run each word one at a time through the neural network, get the hidden state, pass it on to the next run of the neural network. But that's not the case here with the transformer, where each word is being processed independent of all of the other ones. So what are we going to do to try to solve that problem? One thing we can do is add some kind of positional encoding to the input word. The positional encoding is some vector that represents the position of the word in the sentence. This is the first word, the second word, the third word, and so forth. We're going to add that to the input word. And the result of that is going to be a vector that captures multiple pieces of information. It captures the input word itself as well as where in the sentence it appears. The result of that is we can pass the output of that addition, the addition of the input word and the positional encoding into the neural network. That way, the neural network knows the word and where it appears in the sentence and can use both of those pieces of information to determine how best to represent the meaning of that word in the encoded representation at the end of it. In addition to what we have here, in addition to the positional encoding and this feed forward neural network, we're also going to add one additional component, which is going to be a self-attention step. This is going to be attention where we're paying attention to the other input words. Because the meaning or interpretation of an input word might vary depending on the other words in the input as well. And so we're going to allow each word in the input to decide what other words in the input it should pay attention to in order to decide on its encoded representation. And that's going to allow us to get a better encoded representation for each word because words are defined by their context, by the words around them and how they're used in that particular context. This kind of self-attention is so valuable, in fact, that oftentimes the transformer will use multiple different self-attention layers at the same time to allow for this model to be able to pay attention to multiple facets of the input at the same time. And we call this multi-headed attention, where each attention head can pay attention to something different. And as a result, this network can learn to pay attention to many different parts of the input for this input word all at the same time. And in the spirit of deep learning, these two steps, this multi-headed self-attention layer and this neural network layer, that itself can be repeated multiple times, too, in order to get a deeper representation, in order to learn deeper patterns within the input text and ultimately get a better representation of language in order to get useful encoded representations of all of the input words. And so this is the process that a transformer might use in order to take an input word and get it its encoded representation. And the key idea is to really rely on this attention step in order to get information that's useful in order to determine how to encode that word. And that process is going to repeat for all of the input words that are in the input sequence. We're going to take all of the input words, encode them with some kind of positional encoding, feed those into these self-attention and feed-forward neural networks in order to ultimately get these encoded representations of the words. That's the result of the encoder. We get all of these encoded representations that will be useful to us when it comes time then to try to decode all of this information into the output sequence we're interested in. And again, this might take place in the context of machine translation, where the output is going to be the same sentence in a different language, or it might be an answer to a question in the case of an AI chatbot, for example. And so now let's take a look at how that decoder is going to work. Ultimately, it's going to have a very similar structure. Any time we're trying to generate the next output word, we need to know what the previous output word is, as well as its positional encoding. Where in the output sequence are we? And we're going to have these same steps, self-attention, because we might want an output word to be able to pay attention to other words in that same output, as well as a neural network. And that might itself repeat multiple times. But in this decoder, we're going to add one additional step. We're going to add an additional attention step, where instead of self-attention, where the output word is going to pay attention to other output words, in this step, we're going to allow the output word to pay attention to the encoded representations. So recall that the encoder is taking all of the input words and transforming them into these encoded representations of all of the input words. But it's going to be important for us to be able to decide which of those encoded representations we want to pay attention to when generating any particular token in the output sequence. And that's what this additional attention step is going to allow us to do. It's saying that every time we're generating a word of the output, we can pay attention to the other words in the output, because we might want to know, what are the words we've generated previously? And we want to pay attention to some of them to decide what word is going to be next in the sequence. But we also care about paying attention to the input words, too. And we want the ability to decide which of these encoded representations of the input words are going to be relevant in order for us to generate the next step. And so these two pieces combine together. We have this encoder that takes all of the input words and produces this encoded representation. And we have this decoder that is able to take the previous output word, pay attention to that encoded input, and then generate the next output word. And this is one of the possible architectures we could use for a transformer, with the key idea being these attention steps that allow words to pay attention to each other. During the training process here, we can now much more easily parallelize this, because we don't have to wait for all of the words to happen in sequence. And we can learn how we should perform these attention steps. The model is able to learn what is important to pay attention to, what things do I need to pay attention to, in order to be more accurate at predicting what the output word is. And this has proved to be a tremendously effective model for conversational AI agents, for building machine translation systems. And there have been many variants proposed on this model, too. Some transformers only use an encoder. Some only use a decoder. Some use some other combination of these different particular features. But the key ideas ultimately remain the same, this real focus on trying to pay attention to what is most important. And the world of natural language processing is fast growing and fast evolving. Year after year, we keep coming up with new models that allow us to do an even better job of performing these natural language related tasks, all on the surface of solving the tricky problem, which is our own natural language. We've seen how the syntax and semantics of our language is ambiguous, and it introduces all of these new challenges that we need to think about, if we're going to be able to design AI agents that are able to work with language effectively. So as we think about where we've been in this class, all of the different types of artificial intelligence we've considered, we've looked at artificial intelligence in a wide variety of different forms now. We started by taking a look at search problems, where we looked at how AI can search for solutions, play games, and find the optimal decision to make. We talked about knowledge, how AI can represent information that it knows and use that information to generate new knowledge as well. Then we looked at what AI can do when it's less certain, when it doesn't know things for sure, and we have to represent things in terms of probability. We then took a look at optimization problems. We saw how a lot of problems in AI can be boiled down to trying to maximize or minimize some function. And we looked at strategies that AI can use in order to do that kind of maximizing and minimizing. We then looked at the world of machine learning, learning from data in order to figure out some patterns and identify how to perform a task by looking at the training data that we have available to it. And one of the most powerful tools there was the neural network, the sequence of units whose weights can be trained in order to allow us to really effectively go from input to output and predict how to get there by learning these underlying patterns. And then today, we took a look at language itself, trying to understand how can we train the computer to be able to understand our natural language, to be able to understand syntax and semantics, make sense of and generate natural language, which introduces a number of interesting problems too. And we've really just scratched the surface of artificial intelligence. There is so much interesting research and interesting new techniques and algorithms and ideas being introduced to try to solve these types of problems. So I hope you enjoyed this exploration into the world of artificial intelligence. A huge thanks to all of the course's teaching staff and production team for making the class possible. This was an introduction to artificial intelligence with Python.